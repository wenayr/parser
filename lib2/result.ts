import {QueryStruct} from "./connector";
import {tWeights} from "./interfaces";
import {getWeight, MyBinanceClientBase, WeightVal} from "./header";

type INT = number
type DECIMAL = number
type INTEGER = number
type LONG = number
type BigDecimal = number
type DOUBLE = number
type NumberString = `${number}`
type ENUM = string;
//type ARRAY<T = any> = T[];

export type PortfolioDetail = { targetAsset :string, percentage :number };


export type OCOOrderStatus = 'EXECUTING' | 'ALL_DONE' | 'REJECT';

export type OCOStatus = 'RESPONSE' | 'EXEC_STARTED' | 'ALL_DONE';

export type OrderResponseType = 'ACK' | 'RESULT' | 'FULL';

export type OrderSide = 'BUY' | 'SELL';

export type OrderStatus = 
    'NEW' |
    'PARTIALLY_FILLED' |
    'FILLED' |
    'CANCELED' |
    'PENDING_CANCEL' |
    'REJECTED' |
    'EXPIRED' |
    'EXPIRED_IN_MATCH';

export type OrderType = 
    'LIMIT' |
    'MARKET' |
    'STOP_LOSS' |
    'STOP_LOSS_LIMIT' |
    'TAKE_PROFIT' |
    'TAKE_PROFIT_LIMIT' |
    'LIMIT_MAKER';

export type Permission = 
    'SPOT' |
    'MARGIN' |
    'LEVERAGED' |
    'TRD_GRP_002' |
    'TRD_GRP_003' |
    'TRD_GRP_004' |
    'TRD_GRP_005' |
    'TRD_GRP_006' |
    'TRD_GRP_007' |
    'TRD_GRP_008' |
    'TRD_GRP_009' |
    'TRD_GRP_010' |
    'TRD_GRP_011' |
    'TRD_GRP_012' |
    'TRD_GRP_013' |
    'TRD_GRP_014' |
    'TRD_GRP_015' |
    'TRD_GRP_016' |
    'TRD_GRP_017' |
    'TRD_GRP_018' |
    'TRD_GRP_019' |
    'TRD_GRP_020' |
    'TRD_GRP_021' |
    'TRD_GRP_022' |
    'TRD_GRP_023' |
    'TRD_GRP_024' |
    'TRD_GRP_025';

export type PositionSide = 'BOTH' | 'LONG' | 'SHORT';

export type PriceMatch = 
    'NONE' |
    'OPPONENT' |
    'OPPONENT_5' |
    'OPPONENT_10' |
    'OPPONENT_20' |
    'QUEUE' |
    'QUEUE_5' |
    'QUEUE_10' |
    'QUEUE_20';

export type RateLimitInterval = 'SECOND' | 'MINUTE' | 'DAY';

export type RateLimitType = 'REQUEST_WEIGHT' | 'ORDERS' | 'RAW_REQUESTS';

export type TimeInForce = 'GTC' | 'IOC' | 'FOC';

export type WorkingFloor = 'EXCHANGE' | 'SOR';

export type WorkingType = 'MARK_PRICE' | 'CONTRACT_PRICE';




type KeysByType<T, PickT extends T[keyof T]> = { [key in keyof T]: T[key] extends PickT ? key : never; }[keyof T];

type BinanceFunctionName = KeysByType<Omit<MyBinanceClient,"getWeight"|"getFunctionInfo">, (...arg :any)=>Promise<any>>



export default class MyBinanceClient extends MyBinanceClientBase {

  
  //======== SPOT/MARGIN/SAVINGS/MINING ========
  
  
  //***** Wallet Endpoints *****
  
  
  /** System Status (System)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#system-status-system}
   * 
   * Fetch system status.
   * 
   * EndPoint: /sapi/v1/system/status
   * 
   * Weight(IP): 1
   * 
   */
  systemStatus() : Promise<{
     status: 0|1,  // example: 0  // 0: normal,1:system maintenance
     msg: "normal"|"system_maintenance"  // example: "normal"  // "normal", "system_maintenance"
    }> {
      return this._sendRequest("/sapi/v1/system/status", "GET", "System", false, [], [], "systemStatus");
  }
  
  
  /** All Coins' Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#all-coins-39-information-user_data}
   * 
   * Get information of coins (available for deposit and withdraw) for user.
   * 
   * EndPoint: /sapi/v1/capital/config/getall
   * 
   * Weight(IP): 10
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  allCoinsInformation(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["allCoinsInformation"]>;
  
  
  /** All Coins' Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#all-coins-39-information-user_data}
   * 
   * Get information of coins (available for deposit and withdraw) for user.
   * 
   * EndPoint: /sapi/v1/capital/config/getall
   * 
   * Weight(IP): 10
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  allCoinsInformation(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       coin: string,  // example: "BTC"
       depositAllEnable: boolean,  // example: true
       free: NumberString,  // example: "0.08074558"
       freeze: NumberString,  // example: "0.00000000"
       ipoable: NumberString,  // example: "0.00000000"
       ipoing: NumberString,  // example: "0.00000000"
       isLegalMoney: boolean,  // example: false
       locked: NumberString,  // example: "0.00000000"
       name: string,  // example: "Bitcoin"
       networkList: (
         {
           addressRegex: string,  // example: "^(bnb1)[0-9a-z]{38}$"
           coin: string,  // example: "BTC"
           depositDesc: string,  // example: "Wallet Maintenance, Deposit Suspended"  // shown only when "depositEnable" is false.
           depositEnable: boolean,  // example: false
           isDefault: boolean,  // example: false
           memoRegex: string,  // example: "^[0-9A-Za-z\-_]{1,120}$"
           minConfirm: number,  // example: 1  // min number for balance confirmation
           name: string,  // example: "BEP2"
           network: string,  // example: "BNB"
           specialTips: string,  // example: "Both a MEMO and an Address are required to successfully deposit your BEP2-BTCB tokens to Binance."
           unLockConfirm: number,  // example: 0  // confirmation number for balance unlock
           withdrawDesc: string,  // example: "Wallet Maintenance, Withdrawal Suspended"  // shown only when "withdrawEnable" is false.
           withdrawEnable: boolean,  // example: false
           withdrawFee: NumberString,  // example: "0.00000220"
           withdrawIntegerMultiple: NumberString,  // example: "0.00000001"
           withdrawMax: NumberString,  // example: "9999999999.99999999"
           withdrawMin: NumberString,  // example: "0.00000440"
           sameAddress: boolean,  // example: true  // If the coin needs to provide memo to withdraw
           estimatedArrivalTime: number,  // example: 25
           busy: boolean,  // example: false
           contractAddressUrl: string,  // example: "https://bscscan.com/token/"
           contractAddress: NumberString  // example: "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c"
         } |
         {
           addressRegex: string,  // example: "^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$|^(bc1)[0-9A-Za-z]{39,59}$"
           coin: string,  // example: "BTC"
           depositEnable: boolean,  // example: true
           isDefault: boolean,  // example: true
           memoRegex: string,  // example: ""
           minConfirm: number,  // example: 1
           name: string,  // example: "BTC"
           network: string,  // example: "BTC"
           specialTips: string,  // example: ""
           unLockConfirm: number,  // example: 2
           withdrawEnable: boolean,  // example: true
           withdrawFee: NumberString,  // example: "0.00050000"
           withdrawIntegerMultiple: NumberString,  // example: "0.00000001"
           withdrawMax: NumberString,  // example: "750"
           withdrawMin: NumberString,  // example: "0.00100000"
           sameAddress: boolean,  // example: false
           estimatedArrivalTime: number,  // example: 25
           busy: boolean,  // example: false
           contractAddressUrl: string,  // example: ""
           contractAddress: string  // example: ""
         }
       )[],
       storage: NumberString,  // example: "0.00000000"
       trading: boolean,  // example: true
       withdrawAllEnable: boolean,  // example: true
       withdrawing: NumberString  // example: "0.00000000"
     }[]>;
  
  
  allCoinsInformation(...args : any) {
      return this._sendRequest("/sapi/v1/capital/config/getall", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "allCoinsInformation");
  }
  
  
  /** Daily Account Snapshot (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#daily-account-snapshot-user_data}
   * 
   * EndPoint: /sapi/v1/accountSnapshot
   * 
   * Weight(IP): 2400
   * 
   * @param {"SPOT"|"MARGIN"|"FUTURES"} type  -  "SPOT", "MARGIN", "FUTURES"
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  min 7, max 30, default 7
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dailyAccountSnapshot(type :"SPOT"|"MARGIN"|"FUTURES", startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dailyAccountSnapshot"]>;
  
  
  /** Daily Account Snapshot (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#daily-account-snapshot-user_data}
   * 
   * EndPoint: /sapi/v1/accountSnapshot
   * 
   * Weight(IP): 2400
   * 
   * @param {"SPOT"|"MARGIN"|"FUTURES"} options.type  -  "SPOT", "MARGIN", "FUTURES"
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  min 7, max 30, default 7
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dailyAccountSnapshot(options : { type :"SPOT"|"MARGIN"|"FUTURES", startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200  // 200 for success; others are error codes
     msg: string,  // example: ""  // error message
     snapshotVos: {
         data: {
           balances: {
               asset: string,  // example: "BTC"
               free: NumberString,  // example: "0.09905021"
               locked: NumberString  // example: "0.00000000"
             }[],
           totalAssetOfBtc: NumberString  // example: "0.09942700"
         },
         type: string,  // example: "spot"
         updateTime: number  // example: 1576281599000
       }[]
    } | {
     code: number,  // example: 200  // 200 for success; others are error codes
     msg: string,  // example: ""  // error message
     snapshotVos: {
         data: {
           marginLevel: NumberString,  // example: "2748.02909813"
           totalAssetOfBtc: NumberString,  // example: "0.00274803"
           totalLiabilityOfBtc: NumberString,  // example: "0.00000100"
           totalNetAssetOfBtc: NumberString,  // example: "0.00274750"
           userAssets: {
               asset: string,  // example: "XRP"
               borrowed: NumberString,  // example: "0.00000000"
               free: NumberString,  // example: "1.00000000"
               interest: NumberString,  // example: "0.00000000"
               locked: NumberString,  // example: "0.00000000"
               netAsset: NumberString  // example: "1.00000000"
             }[]
         },
         type: string,  // example: "margin"
         updateTime: number  // example: 1576281599000
       }[]
    } | {
     code: number,  // example: 200  // 200 for success; others are error codes
     msg: string,  // example: ""  // error message
     snapshotVos: {
         data: {
           assets: {
               asset: string,  // example: "USDT"
               marginBalance: NumberString,  // example: "118.99782335"  // Not real-time data, can ignore
               walletBalance: NumberString  // example: "120.23811389"
             }[],
           position: {
               entryPrice: NumberString,  // example: "7130.41000000"
               markPrice: NumberString,  // example: "7257.66239673"
               positionAmt: NumberString,  // example: "0.01000000"
               symbol: string,  // example: "BTCUSDT"
               unRealizedProfit: NumberString  // example: "1.24029054"  // Only show the value at the time of opening the position
             }[]
         },
         type: string,  // example: "futures"
         updateTime: number  // example: 1576281599000
       }[]
    }>;
  
  
  dailyAccountSnapshot(...args : any) {
      return this._sendRequest("/sapi/v1/accountSnapshot", "GET", "USER_DATA", false, args, ["type", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "dailyAccountSnapshot");
  }
  
  
  /** Disable Fast Withdraw Switch (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#disable-fast-withdraw-switch-user_data}
   * 
   * EndPoint: /sapi/v1/account/disableFastWithdrawSwitch
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  disableFastWithdrawSwitch(recvWindow? :LONG, timestamp? :LONG)  : Promise<{    }>;
  
  
  /** Disable Fast Withdraw Switch (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#disable-fast-withdraw-switch-user_data}
   * 
   * EndPoint: /sapi/v1/account/disableFastWithdrawSwitch
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  disableFastWithdrawSwitch(options? : { recvWindow? :LONG, timestamp? :LONG })  : Promise<{    }>;
  
  
  disableFastWithdrawSwitch(...args : any) {
      return this._sendRequest("/sapi/v1/account/disableFastWithdrawSwitch", "POST", "USER_DATA", false, args, ["recvWindow", "timestamp"], "disableFastWithdrawSwitch");
  }
  
  
  /** Enable Fast Withdraw Switch (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#enable-fast-withdraw-switch-user_data}
   * 
   * EndPoint: /sapi/v1/account/enableFastWithdrawSwitch
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  enableFastWithdrawSwitch(recvWindow? :LONG, timestamp? :LONG)  : Promise<{    }>;
  
  
  /** Enable Fast Withdraw Switch (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#enable-fast-withdraw-switch-user_data}
   * 
   * EndPoint: /sapi/v1/account/enableFastWithdrawSwitch
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  enableFastWithdrawSwitch(options? : { recvWindow? :LONG, timestamp? :LONG })  : Promise<{    }>;
  
  
  enableFastWithdrawSwitch(...args : any) {
      return this._sendRequest("/sapi/v1/account/enableFastWithdrawSwitch", "POST", "USER_DATA", false, args, ["recvWindow", "timestamp"], "enableFastWithdrawSwitch");
  }
  
  
  /** Withdraw(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#withdraw-user_data}
   * 
   * Submit a withdraw request.
   * 
   * EndPoint: /sapi/v1/capital/withdraw/apply
   * 
   * Weight(UID): 600
   * 
   * @param {string} coin
   * @param {string} withdrawOrderId  -  client id for withdraw
   * @param {string} network
   * @param {string} address
   * @param {string} addressTag  -  Secondary address identifier for coins like XRP,XMR etc.
   * @param {DECIMAL} amount
   * @param {boolean} transactionFeeFlag  -  When making internal transfer, true for returning the fee to the destination account; false for returning the fee back to the departure account. Default false.
   * @param {string} name  -  Description of the address. The upper limit of the address book is 200. Exceeding the limit will cause withdrawal failure. Space in name should be encoded into %20.
   * @param {INTEGER} walletType  -  The wallet type for withdraw，0-spot wallet ，1-funding wallet. Default walletType is the current "selected wallet" under wallet->Fiat and Spot/Funding->Deposit
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  withdraw(coin :string, withdrawOrderId :string|undefined, network :string|undefined, address :string, addressTag :string|undefined, amount :DECIMAL, transactionFeeFlag? :boolean, name? :string, walletType? :INTEGER, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["withdraw"]>;
  
  
  /** Withdraw(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#withdraw-user_data}
   * 
   * Submit a withdraw request.
   * 
   * EndPoint: /sapi/v1/capital/withdraw/apply
   * 
   * Weight(UID): 600
   * 
   * @param {string} options.coin
   * @param {string} options.withdrawOrderId  -  client id for withdraw
   * @param {string} options.network
   * @param {string} options.address
   * @param {string} options.addressTag  -  Secondary address identifier for coins like XRP,XMR etc.
   * @param {DECIMAL} options.amount
   * @param {boolean} options.transactionFeeFlag  -  When making internal transfer, true for returning the fee to the destination account; false for returning the fee back to the departure account. Default false.
   * @param {string} options.name  -  Description of the address. The upper limit of the address book is 200. Exceeding the limit will cause withdrawal failure. Space in name should be encoded into %20.
   * @param {INTEGER} options.walletType  -  The wallet type for withdraw，0-spot wallet ，1-funding wallet. Default walletType is the current "selected wallet" under wallet->Fiat and Spot/Funding->Deposit
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  withdraw(options : { coin :string, withdrawOrderId? :string, network? :string, address :string, addressTag? :string, amount :DECIMAL, transactionFeeFlag? :boolean, name? :string, walletType? :INTEGER, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     id: string  // example: "7213fea8e94b4a5593d507237e5a555b"
    }>;
  
  
  withdraw(...args : any) {
      return this._sendRequest("/sapi/v1/capital/withdraw/apply", "POST", "USER_DATA", false, args, ["coin", "withdrawOrderId", "network", "address", "addressTag", "amount", "transactionFeeFlag", "name", "walletType", "recvWindow", "timestamp"], "withdraw");
  }
  
  
  /** Deposit History (supporting network) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#deposit-history-supporting-network-user_data}
   * 
   * Fetch deposit history.
   * 
   * EndPoint: /sapi/v1/capital/deposit/hisrec
   * 
   * Weight(IP): 1
   * 
   * @param {boolean} includeSource  -  default false, if true source address for the transaction will be returned
   * @param {string} coin
   * @param {INT} status  -  0(0:pending,6: credited but cannot withdraw, 7=Wrong Deposit,8=Waiting User confirm, 1:success)
   * @param {LONG} startTime  -  Default: 90 days from current timestamp
   * @param {LONG} endTime  -  Default: present timestamp
   * @param {INT} offset  -  Default:0
   * @param {INT} limit  -  Default:1000, Max:1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   * @param {string} txId
   */
  depositHistorySupportingNetwork(includeSource? :boolean, coin? :string, status? :INT, startTime? :LONG, endTime? :LONG, offset? :INT, limit? :INT, recvWindow? :LONG, timestamp? :LONG, txId? :string)
  : ReturnType<MyBinanceClient["depositHistorySupportingNetwork"]>;
  
  
  /** Deposit History (supporting network) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#deposit-history-supporting-network-user_data}
   * 
   * Fetch deposit history.
   * 
   * EndPoint: /sapi/v1/capital/deposit/hisrec
   * 
   * Weight(IP): 1
   * 
   * @param {boolean} options.includeSource  -  default false, if true source address for the transaction will be returned
   * @param {string} options.coin
   * @param {INT} options.status  -  0(0:pending,6: credited but cannot withdraw, 7=Wrong Deposit,8=Waiting User confirm, 1:success)
   * @param {LONG} options.startTime  -  Default: 90 days from current timestamp
   * @param {LONG} options.endTime  -  Default: present timestamp
   * @param {INT} options.offset  -  Default:0
   * @param {INT} options.limit  -  Default:1000, Max:1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   * @param {string} options.txId
   */
  depositHistorySupportingNetwork(options? : { includeSource? :boolean, coin? :string, status? :INT, startTime? :LONG, endTime? :LONG, offset? :INT, limit? :INT, recvWindow? :LONG, timestamp? :LONG, txId? :string })
  : Promise<(
     {
       id: NumberString,  // example: "769800519366885376"
       amount: NumberString,  // example: "0.001"
       coin: string,  // example: "BNB"
       network: string,  // example: "BNB"
       status: number,  // example: 0
       address: string,  // example: "bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23"
       addressTag: NumberString,  // example: "101764890"
       txId: string,  // example: "98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC"
       insertTime: number,  // example: 1661493146000
       transferType: number,  // example: 0
       confirmTimes: string,  // example: "1/1"
       unlockConfirm: number,  // example: 0
       walletType: number  // example: 0
     } |
     {
       id: NumberString,  // example: "769754833590042625"
       amount: NumberString,  // example: "0.50000000"
       coin: string,  // example: "IOTA"
       network: string,  // example: "IOTA"
       status: number,  // example: 1
       address: string,  // example: "SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW"
       addressTag: string,  // example: ""
       txId: string,  // example: "ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999"
       insertTime: number,  // example: 1599620082000
       transferType: number,  // example: 0
       confirmTimes: string,  // example: "1/1"
       unlockConfirm: number,  // example: 0
       walletType: number  // example: 0
     }
    )[]>;
  
  
  depositHistorySupportingNetwork(...args : any) {
      return this._sendRequest("/sapi/v1/capital/deposit/hisrec", "GET", "USER_DATA", false, args, ["includeSource", "coin", "status", "startTime", "endTime", "offset", "limit", "recvWindow", "timestamp", "txId"], "depositHistorySupportingNetwork");
  }
  
  
  /** Withdraw History (supporting network) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#withdraw-history-supporting-network-user_data}
   * 
   * Fetch withdraw history.
   * 
   * EndPoint: /sapi/v1/capital/withdraw/history
   * 
   * Weight(UID): 18000
   * 
   * @param {string} coin
   * @param {string} withdrawOrderId
   * @param {INT} status  -  0(0:Email Sent,1:Cancelled 2:Awaiting Approval 3:Rejected 4:Processing 5:Failure 6:Completed)
   * @param {INT} offset
   * @param {INT} limit  -  Default: 1000, Max: 1000
   * @param {LONG} startTime  -  Default: 90 days from current timestamp
   * @param {LONG} endTime  -  Default: present timestamp
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  withdrawHistorySupportingNetwork(coin? :string, withdrawOrderId? :string, status? :INT, offset? :INT, limit? :INT, startTime? :LONG, endTime? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["withdrawHistorySupportingNetwork"]>;
  
  
  /** Withdraw History (supporting network) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#withdraw-history-supporting-network-user_data}
   * 
   * Fetch withdraw history.
   * 
   * EndPoint: /sapi/v1/capital/withdraw/history
   * 
   * Weight(UID): 18000
   * 
   * @param {string} options.coin
   * @param {string} options.withdrawOrderId
   * @param {INT} options.status  -  0(0:Email Sent,1:Cancelled 2:Awaiting Approval 3:Rejected 4:Processing 5:Failure 6:Completed)
   * @param {INT} options.offset
   * @param {INT} options.limit  -  Default: 1000, Max: 1000
   * @param {LONG} options.startTime  -  Default: 90 days from current timestamp
   * @param {LONG} options.endTime  -  Default: present timestamp
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  withdrawHistorySupportingNetwork(options? : { coin? :string, withdrawOrderId? :string, status? :INT, offset? :INT, limit? :INT, startTime? :LONG, endTime? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       id: string,  // example: "b6ae22b3aa844210a7041aee7589627c"  // Withdrawal id in Binance
       amount: NumberString,  // example: "8.91000000"  // withdrawal amount
       transactionFee: NumberString,  // example: "0.004"  // transaction fee
       coin: string,  // example: "USDT"
       status: number,  // example: 6
       address: NumberString,  // example: "0x94df8b352de7f46f64b01d3666bf6e936e44ce60"
       txId: NumberString,  // example: "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268"  // withdrawal transaction id
       applyTime: string,  // example: "2019-10-12 11:12:02"  // UTC time
       network: string,  // example: "ETH"
       transferType: number,  // example: 0  // 1 for internal transfer, 0 for external transfer
       withdrawOrderId: string,  // example: "WITHDRAWtest123"  // // will not be returned if there's no withdrawOrderId for this withdraw.
       info: string,  // example: "The address is not valid. Please confirm with the recipient"  // reason for withdrawal failure
       confirmNo: number,  // example: 3  // confirm times for withdraw
       walletType: number,  // example: 1  //1: Funding Wallet 0:Spot Wallet
       txKey: string,  // example: ""
       completeTime: string  // example: "2023-03-23 16:52:41"  // complete UTC time when user's asset is deduct from withdrawing, only if status =  6(success)
     } |
     {
       id: string,  // example: "156ec387f49b41df8724fa744fa82719"
       amount: NumberString,  // example: "0.00150000"
       transactionFee: NumberString,  // example: "0.004"
       coin: string,  // example: "BTC"
       status: number,  // example: 6
       address: string,  // example: "1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB"
       txId: string,  // example: "60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354"
       applyTime: string,  // example: "2019-09-24 12:43:45"
       network: string,  // example: "BTC"
       transferType: number,  // example: 0
       info: string,  // example: ""
       confirmNo: number,  // example: 2
       walletType: number,  // example: 1
       txKey: string,  // example: ""
       completeTime: string  // example: "2023-03-23 16:52:41"
     }
    )[]>;
  
  
  withdrawHistorySupportingNetwork(...args : any) {
      return this._sendRequest("/sapi/v1/capital/withdraw/history", "GET", "USER_DATA", false, args, ["coin", "withdrawOrderId", "status", "offset", "limit", "startTime", "endTime", "recvWindow", "timestamp"], "withdrawHistorySupportingNetwork");
  }
  
  
  /** Deposit Address (supporting network) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#deposit-address-supporting-network-user_data}
   * 
   * Fetch deposit address with network.
   * 
   * EndPoint: /sapi/v1/capital/deposit/address
   * 
   * Weight(IP): 10
   * 
   * @param {string} coin
   * @param {string} network
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  depositAddressSupportingNetwork(coin :string, network? :string, amount? :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["depositAddressSupportingNetwork"]>;
  
  
  /** Deposit Address (supporting network) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#deposit-address-supporting-network-user_data}
   * 
   * Fetch deposit address with network.
   * 
   * EndPoint: /sapi/v1/capital/deposit/address
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.coin
   * @param {string} options.network
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  depositAddressSupportingNetwork(options : { coin :string, network? :string, amount? :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     address: string,  // example: "1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv"
     coin: string,  // example: "BTC"
     tag: string,  // example: ""
     url: string  // example: "https://btc.com/1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv"
    }>;
  
  
  depositAddressSupportingNetwork(...args : any) {
      return this._sendRequest("/sapi/v1/capital/deposit/address", "GET", "USER_DATA", false, args, ["coin", "network", "amount", "recvWindow", "timestamp"], "depositAddressSupportingNetwork");
  }
  
  
  /** Account Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-status-user_data}
   * 
   * Fetch account status detail.
   * 
   * EndPoint: /sapi/v1/account/status
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  accountStatus(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["accountStatus"]>;
  
  
  /** Account Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-status-user_data}
   * 
   * Fetch account status detail.
   * 
   * EndPoint: /sapi/v1/account/status
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  accountStatus(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     data: string  // example: "Normal"
    }>;
  
  
  accountStatus(...args : any) {
      return this._sendRequest("/sapi/v1/account/status", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "accountStatus");
  }
  
  
  /** Account API Trading Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-api-trading-status-user_data}
   * 
   * Fetch account api trading status detail.
   * 
   * EndPoint: /sapi/v1/account/apiTradingStatus
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  accountAPITradingStatus(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["accountAPITradingStatus"]>;
  
  
  /** Account API Trading Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-api-trading-status-user_data}
   * 
   * Fetch account api trading status detail.
   * 
   * EndPoint: /sapi/v1/account/apiTradingStatus
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  accountAPITradingStatus(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     data: {
       isLocked: boolean,  // example: false  // API trading function is locked or not
       plannedRecoverTime: number,  // example: 0  // If API trading function is locked, this is the planned recover time
       triggerCondition: {
         GCR: number,   // example: 150  // Number of GTC orders
         IFER: number,  // example: 150  // Number of FOK/IOC orders
         UFR: number    // example: 300  // Number of orders
       },
       updateTime: number  // example: 1547630471725
     }
    }>;
  
  
  accountAPITradingStatus(...args : any) {
      return this._sendRequest("/sapi/v1/account/apiTradingStatus", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "accountAPITradingStatus");
  }
  
  
  /** DustLog(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#dustlog-user_data}
   * 
   * EndPoint: /sapi/v1/asset/dribblet
   * 
   * Weight(IP): 1
   * 
   * @param {string} accountType  -  SPOTor MARGIN,default SPOT
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dustLog(accountType? :string, startTime? :LONG, endTime? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dustLog"]>;
  
  
  /** DustLog(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#dustlog-user_data}
   * 
   * EndPoint: /sapi/v1/asset/dribblet
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.accountType  -  SPOTor MARGIN,default SPOT
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dustLog(options? : { accountType? :string, startTime? :LONG, endTime? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 8  //Total counts of exchange
     userAssetDribblets: {
         operateTime: number,  // example: 1615985535000
         totalTransferedAmount: NumberString,  // example: "0.00132256"  // Total transfered BNB amount for this exchange.
         totalServiceChargeAmount: NumberString,  // example: "0.00002699"  //Total service charge amount for this exchange.
         transId: number,  // example: 45178372831
         userAssetDribbletDetails: {
             transId: number,  // example: 4359321
             serviceChargeAmount: NumberString,  // example: "0.000009"
             amount: NumberString,  // example: "0.0009"
             operateTime: number,  // example: 1615985535000
             transferedAmount: NumberString,  // example: "0.000441"
             fromAsset: string  // example: "USDT"
           }[]
       }[]
    }>;
  
  
  dustLog(...args : any) {
      return this._sendRequest("/sapi/v1/asset/dribblet", "GET", "USER_DATA", false, args, ["accountType", "startTime", "endTime", "recvWindow", "timestamp"], "dustLog");
  }
  
  
  /** Get Assets That Can Be Converted Into BNB (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-assets-that-can-be-converted-into-bnb-user_data}
   * 
   * EndPoint: /sapi/v1/asset/dust-btc
   * 
   * Weight(IP): 1
   * 
   * @param {string} accountType  -  SPOTor MARGIN,default SPOT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getAssetsThatCanBeConvertedIntoBNB(accountType? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getAssetsThatCanBeConvertedIntoBNB"]>;
  
  
  /** Get Assets That Can Be Converted Into BNB (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-assets-that-can-be-converted-into-bnb-user_data}
   * 
   * EndPoint: /sapi/v1/asset/dust-btc
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.accountType  -  SPOTor MARGIN,default SPOT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getAssetsThatCanBeConvertedIntoBNB(options? : { accountType? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     details: {
         asset: string,  // example: "ADA"
         assetFullName: string,  // example: "ADA"
         amountFree: NumberString,  // example: "6.21"  //Convertible amount
         toBTC: NumberString,  // example: "0.00016848"  //BTC amount
         toBNB: NumberString,  // example: "0.01777302"  //BNB amount（Not deducted commission fee）
         toBNBOffExchange: NumberString,  // example: "0.01741756"  //BNB amount（Deducted commission fee）
         exchange: NumberString  // example: "0.00035546"  //Commission fee
       }[],
     totalTransferBtc: NumberString,  // example: "0.00016848"
     totalTransferBNB: NumberString,  // example: "0.01777302"
     dribbletPercentage: NumberString  // example: "0.02"  //Commission fee
    }>;
  
  
  getAssetsThatCanBeConvertedIntoBNB(...args : any) {
      return this._sendRequest("/sapi/v1/asset/dust-btc", "POST", "USER_DATA", false, args, ["accountType", "recvWindow", "timestamp"], "getAssetsThatCanBeConvertedIntoBNB");
  }
  
  
  /** Dust Transfer (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#dust-transfer-user_data}
   * 
   * Convert dust assets to BNB.
   * 
   * EndPoint: /sapi/v1/asset/dust
   * 
   * Weight(UID): 10
   * 
   * @param {string[]} asset  -  The asset being converted. For example: asset=BTC,USDT
   * @param {string} accountType  -  SPOTor MARGIN,default SPOT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dustTransfer_UserData(asset :readonly string[], accountType? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dustTransfer_UserData"]>;
  
  
  /** Dust Transfer (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#dust-transfer-user_data}
   * 
   * Convert dust assets to BNB.
   * 
   * EndPoint: /sapi/v1/asset/dust
   * 
   * Weight(UID): 10
   * 
   * @param {string[]} options.asset  -  The asset being converted. For example: asset=BTC,USDT
   * @param {string} options.accountType  -  SPOTor MARGIN,default SPOT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dustTransfer_UserData(options : { asset :readonly string[], accountType? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     totalServiceCharge: NumberString,  // example: "0.02102542"
     totalTransfered: NumberString,  // example: "1.05127099"
     transferResult: {
         amount: NumberString,  // example: "0.03000000"
         fromAsset: string,  // example: "ETH"
         operateTime: number,  // example: 1563368549307
         serviceChargeAmount: NumberString,  // example: "0.00500000"
         tranId: number,  // example: 2970932918
         transferedAmount: NumberString  // example: "0.25000000"
       }[]
    }>;
  
  
  dustTransfer_UserData(...args : any) {
      return this._sendRequest("/sapi/v1/asset/dust", "POST", "USER_DATA", false, args, ["asset", "accountType", "recvWindow", "timestamp"], "dustTransfer_UserData");
  }
  
  
  /** Asset Dividend Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#asset-dividend-record-user_data}
   * 
   * Query asset dividend record.
   * 
   * EndPoint: /sapi/v1/asset/assetDividend
   * 
   * Weight(IP): 10
   * 
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 20, max 500
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  assetDividendRecord(asset? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["assetDividendRecord"]>;
  
  
  /** Asset Dividend Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#asset-dividend-record-user_data}
   * 
   * Query asset dividend record.
   * 
   * EndPoint: /sapi/v1/asset/assetDividend
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 20, max 500
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  assetDividendRecord(options? : { asset? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         id: number,  // example: 1637366104
         amount: NumberString,  // example: "10.00000000"
         asset: string,  // example: "BHFT"
         divTime: number,  // example: 1563189166000
         enInfo: string,  // example: "BHFT distribution"
         tranId: number  // example: 2968885920
       }[],
     total: number  // example: 2
    }>;
  
  
  assetDividendRecord(...args : any) {
      return this._sendRequest("/sapi/v1/asset/assetDividend", "GET", "USER_DATA", false, args, ["asset", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "assetDividendRecord");
  }
  
  
  /** Asset Detail (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#asset-detail-user_data}
   * 
   * Fetch details of assets supported on Binance.
   * 
   * EndPoint: /sapi/v1/asset/assetDetail
   * 
   * Weight(IP): 1
   * 
   * @param {string} asset
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  assetDetail(asset? :string, recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["assetDetail"]>;
  
  
  /** Asset Detail (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#asset-detail-user_data}
   * 
   * Fetch details of assets supported on Binance.
   * 
   * EndPoint: /sapi/v1/asset/assetDetail
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.asset
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  assetDetail(options? : { asset? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     CTR: {
       minWithdrawAmount: NumberString,  // example: "70.00000000"  //min withdraw amount
       depositStatus: boolean,  // example: false  //deposit status (false if ALL of networks' are false)
       withdrawFee: number,  // example: 35  // withdraw fee
       withdrawStatus: boolean,  // example: true  //withdraw status (false if ALL of networks' are false)
       depositTip: string  // example: "Delisted, Deposit Suspended"  //reason
     },
     SKY: {
       minWithdrawAmount: NumberString,  // example: "0.02000000"
       depositStatus: boolean,  // example: true
       withdrawFee: number,  // example: 0.01
       withdrawStatus: boolean  // example: true
     }
    }>;
  
  
  assetDetail(...args : any) {
      return this._sendRequest("/sapi/v1/asset/assetDetail", "GET", "USER_DATA", false, args, ["asset", "recvWindow", "timestamp"], "assetDetail");
  }
  
  
  /** Trade Fee (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#trade-fee-user_data}
   * 
   * Fetch trade fee
   * 
   * EndPoint: /sapi/v1/asset/tradeFee
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  tradeFee(symbol? :string, recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["tradeFee"]>;
  
  
  /** Trade Fee (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#trade-fee-user_data}
   * 
   * Fetch trade fee
   * 
   * EndPoint: /sapi/v1/asset/tradeFee
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  tradeFee(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "ADABNB"
       makerCommission: NumberString,  // example: "0.001"
       takerCommission: NumberString  // example: "0.001"
     }[]>;
  
  
  tradeFee(...args : any) {
      return this._sendRequest("/sapi/v1/asset/tradeFee", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "tradeFee");
  }
  
  
  /** User Universal Transfer (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#user-universal-transfer-user_data}
   * 
   * EndPoint: /sapi/v1/asset/transfer
   * 
   * Weight(UID): 900
   * 
   * @param {OrderType} type
   * @param {string} asset
   * @param {DECIMAL} amount
   * @param {string} fromSymbol
   * @param {string} toSymbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  userUniversalTransfer(type :OrderType, asset :string, amount :DECIMAL, fromSymbol? :string, toSymbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["userUniversalTransfer"]>;
  
  
  /** User Universal Transfer (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#user-universal-transfer-user_data}
   * 
   * EndPoint: /sapi/v1/asset/transfer
   * 
   * Weight(UID): 900
   * 
   * @param {OrderType} options.type
   * @param {string} options.asset
   * @param {DECIMAL} options.amount
   * @param {string} options.fromSymbol
   * @param {string} options.toSymbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  userUniversalTransfer(options : { type :OrderType, asset :string, amount :DECIMAL, fromSymbol? :string, toSymbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     tranId: number  // example: 13526853623
    }>;
  
  
  userUniversalTransfer(...args : any) {
      return this._sendRequest("/sapi/v1/asset/transfer", "POST", "USER_DATA", false, args, ["type", "asset", "amount", "fromSymbol", "toSymbol", "recvWindow", "timestamp"], "userUniversalTransfer");
  }
  
  
  /** Query User Universal Transfer History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-user-universal-transfer-history-user_data}
   * 
   * EndPoint: /sapi/v1/asset/transfer
   * 
   * Weight(IP): 1
   * 
   * @param {OrderType} type
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} current  -  Default 1
   * @param {INT} size  -  Default 10, Max 100
   * @param {string} fromSymbol
   * @param {string} toSymbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryUserUniversalTransferHistory(type :OrderType, startTime? :LONG, endTime? :LONG, current? :INT, size? :INT, fromSymbol? :string, toSymbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryUserUniversalTransferHistory"]>;
  
  
  /** Query User Universal Transfer History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-user-universal-transfer-history-user_data}
   * 
   * EndPoint: /sapi/v1/asset/transfer
   * 
   * Weight(IP): 1
   * 
   * @param {OrderType} options.type
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.current  -  Default 1
   * @param {INT} options.size  -  Default 10, Max 100
   * @param {string} options.fromSymbol
   * @param {string} options.toSymbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryUserUniversalTransferHistory(options : { type :OrderType, startTime? :LONG, endTime? :LONG, current? :INT, size? :INT, fromSymbol? :string, toSymbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 2
     rows: {
         asset: string,  // example: "USDT"
         amount: NumberString,  // example: "1"
         type: string,  // example: "MAIN_UMFUTURE"
         status: string,  // example: "CONFIRMED"  // status: CONFIRMED / FAILED / PENDING
         tranId: number,  // example: 11415955596
         timestamp: number  // example: 1544433328000
       }[]
    }>;
  
  
  queryUserUniversalTransferHistory(...args : any) {
      return this._sendRequest("/sapi/v1/asset/transfer", "GET", "USER_DATA", false, args, ["type", "startTime", "endTime", "current", "size", "fromSymbol", "toSymbol", "recvWindow", "timestamp"], "queryUserUniversalTransferHistory");
  }
  
  
  /** Funding Wallet (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#funding-wallet-user_data}
   * 
   * EndPoint: /sapi/v1/asset/get-funding-asset
   * 
   * Weight(IP): 1
   * 
   * @param {string} asset
   * @param {string} needBtcValuation  -  true or false
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fundingWallet(asset? :string, needBtcValuation? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fundingWallet"]>;
  
  
  /** Funding Wallet (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#funding-wallet-user_data}
   * 
   * EndPoint: /sapi/v1/asset/get-funding-asset
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.asset
   * @param {string} options.needBtcValuation  -  true or false
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fundingWallet(options? : { asset? :string, needBtcValuation? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       asset: string,  // example: "USDT"
       free: NumberString,  // example: "1"  // avalible balance
       locked: NumberString,  // example: "0"  // locked asset
       freeze: NumberString,  // example: "0"  // freeze asset
       withdrawing: NumberString,  // example: "0"
       btcValuation: NumberString  // example: "0.00000091"
     }[]>;
  
  
  fundingWallet(...args : any) {
      return this._sendRequest("/sapi/v1/asset/get-funding-asset", "POST", "USER_DATA", false, args, ["asset", "needBtcValuation", "recvWindow", "timestamp"], "fundingWallet");
  }
  
  
  /** User Asset (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#user-asset-user_data}
   * 
   * Get user assets, just for positive data.
   * 
   * EndPoint: /sapi/v3/asset/getUserAsset
   * 
   * Weight(IP): 5
   * 
   * @param {string} asset  -  If asset is blank, then query all positive assets user have.
   * @param {boolean} needBtcValuation  -  Whether need btc valuation or not.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  userAsset(asset? :string, needBtcValuation? :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["userAsset"]>;
  
  
  /** User Asset (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#user-asset-user_data}
   * 
   * Get user assets, just for positive data.
   * 
   * EndPoint: /sapi/v3/asset/getUserAsset
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.asset  -  If asset is blank, then query all positive assets user have.
   * @param {boolean} options.needBtcValuation  -  Whether need btc valuation or not.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  userAsset(options? : { asset? :string, needBtcValuation? :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       asset: string,  // example: "AVAX"
       free: NumberString,  // example: "1"
       locked: NumberString,  // example: "0"
       freeze: NumberString,  // example: "0"
       withdrawing: NumberString,  // example: "0"
       ipoable: NumberString,  // example: "0"
       btcValuation: NumberString  // example: "0"
     }[]>;
  
  
  userAsset(...args : any) {
      return this._sendRequest("/sapi/v3/asset/getUserAsset", "POST", "USER_DATA", false, args, ["asset", "needBtcValuation", "recvWindow", "timestamp"], "userAsset");
  }
  
  
  /** BUSD Convert (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#busd-convert-trade}
   * 
   * Convert transfer, convert between BUSD and stablecoins.
   * 
   * EndPoint: /sapi/v1/asset/convert-transfer
   * 
   * Weight(UID): 5
   * 
   * @param {string} clientTranId  -  The unique user-defined transaction id, min length 20
   * @param {string} asset  -  The current asset
   * @param {BigDecimal} amount  -  The amount must be positive number
   * @param {string} targetAsset  -  Target asset you want to convert
   * @param {string} accountType  -  Only MAIN and CARD, default MAIN
   */
  buSDConvert(clientTranId :string, asset :string, amount :BigDecimal, targetAsset :string, accountType? :string)
  : ReturnType<MyBinanceClient["buSDConvert"]>;
  
  
  /** BUSD Convert (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#busd-convert-trade}
   * 
   * Convert transfer, convert between BUSD and stablecoins.
   * 
   * EndPoint: /sapi/v1/asset/convert-transfer
   * 
   * Weight(UID): 5
   * 
   * @param {string} options.clientTranId  -  The unique user-defined transaction id, min length 20
   * @param {string} options.asset  -  The current asset
   * @param {BigDecimal} options.amount  -  The amount must be positive number
   * @param {string} options.targetAsset  -  Target asset you want to convert
   * @param {string} options.accountType  -  Only MAIN and CARD, default MAIN
   */
  buSDConvert(options : { clientTranId :string, asset :string, amount :BigDecimal, targetAsset :string, accountType? :string })
  : Promise<{
     tranId: number,  // example: 118263407119
     status: string   // example: "S"
    }>;
  
  
  buSDConvert(...args : any) {
      return this._sendRequest("/sapi/v1/asset/convert-transfer", "POST", "TRADE", false, args, ["clientTranId", "asset", "amount", "targetAsset", "accountType"], "buSDConvert");
  }
  
  
  /** BUSD Convert History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#busd-convert-history-user_data}
   * 
   * EndPoint: /sapi/v1/asset/convert-transfer/queryByPage
   * 
   * Weight(UID): 5
   * 
   * @param {LONG} tranId  -  The transaction id
   * @param {string} clientTranId  -  The user-defined transaction id
   * @param {string} asset  -  If it is blank, we will match deducted asset and target asset.
   * @param {LONG} startTime  -  inclusive, unit: ms
   * @param {LONG} endTime  -  exclusive, unit: ms
   * @param {string} accountType  -  MAIN: main account. CARD: funding account. If it is blank, we will query spot and card wallet, otherwise, we just query the corresponding wallet
   * @param {INTEGER} current  -  current page, default 1, the min value is 1
   * @param {INTEGER} size  -  page size, default 10, the max value is 100
   */
  buSDConvertHistory(tranId :LONG|undefined, clientTranId :string|undefined, asset :string|undefined, startTime :LONG, endTime :LONG, accountType? :string, current? :INTEGER, size? :INTEGER)
  : ReturnType<MyBinanceClient["buSDConvertHistory"]>;
  
  
  /** BUSD Convert History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#busd-convert-history-user_data}
   * 
   * EndPoint: /sapi/v1/asset/convert-transfer/queryByPage
   * 
   * Weight(UID): 5
   * 
   * @param {LONG} options.tranId  -  The transaction id
   * @param {string} options.clientTranId  -  The user-defined transaction id
   * @param {string} options.asset  -  If it is blank, we will match deducted asset and target asset.
   * @param {LONG} options.startTime  -  inclusive, unit: ms
   * @param {LONG} options.endTime  -  exclusive, unit: ms
   * @param {string} options.accountType  -  MAIN: main account. CARD: funding account. If it is blank, we will query spot and card wallet, otherwise, we just query the corresponding wallet
   * @param {INTEGER} options.current  -  current page, default 1, the min value is 1
   * @param {INTEGER} options.size  -  page size, default 10, the max value is 100
   */
  buSDConvertHistory(options : { tranId? :LONG, clientTranId? :string, asset? :string, startTime :LONG, endTime :LONG, accountType? :string, current? :INTEGER, size? :INTEGER })
  : Promise<{
     total: number,  // example: 3
     rows: {
         tranId: number,  // example: 118263615991
         type: number,  // example: 244
         time: number,  // example: 1664442078000
         deductedAsset: string,  // example: "BUSD"
         deductedAmount: NumberString,  // example: "1"
         targetAsset: string,  // example: "USDC"
         targetAmount: NumberString,  // example: "1"
         status: string,  // example: "S"
         accountType: string  // example: "MAIN"
       }[]
    }>;
  
  
  buSDConvertHistory(...args : any) {
      return this._sendRequest("/sapi/v1/asset/convert-transfer/queryByPage", "GET", "USER_DATA", false, args, ["tranId", "clientTranId", "asset", "startTime", "endTime", "accountType", "current", "size"], "buSDConvertHistory");
  }
  
  
  /** Get Cloud-Mining payment and refund history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-cloud-mining-payment-and-refund-history-user_data}
   * 
   * The query of Cloud-Mining payment and refund history
   * 
   * EndPoint: /sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage
   * 
   * Weight(UID): 600
   * 
   * @param {LONG} tranId  -  The transaction id
   * @param {string} clientTranId  -  The unique flag
   * @param {string} asset  -  If it is blank, we will query all assets
   * @param {LONG} startTime  -  inclusive, unit: ms
   * @param {LONG} endTime  -  exclusive, unit: ms
   * @param {INTEGER} current  -  current page, default 1, the min value is 1
   * @param {INTEGER} size  -  page size, default 10, the max value is 100
   */
  getCloudMiningPaymentAndRefundHistory(tranId :LONG|undefined, clientTranId :string|undefined, asset :string|undefined, startTime :LONG, endTime :LONG, current? :INTEGER, size? :INTEGER)
  : ReturnType<MyBinanceClient["getCloudMiningPaymentAndRefundHistory"]>;
  
  
  /** Get Cloud-Mining payment and refund history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-cloud-mining-payment-and-refund-history-user_data}
   * 
   * The query of Cloud-Mining payment and refund history
   * 
   * EndPoint: /sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage
   * 
   * Weight(UID): 600
   * 
   * @param {LONG} options.tranId  -  The transaction id
   * @param {string} options.clientTranId  -  The unique flag
   * @param {string} options.asset  -  If it is blank, we will query all assets
   * @param {LONG} options.startTime  -  inclusive, unit: ms
   * @param {LONG} options.endTime  -  exclusive, unit: ms
   * @param {INTEGER} options.current  -  current page, default 1, the min value is 1
   * @param {INTEGER} options.size  -  page size, default 10, the max value is 100
   */
  getCloudMiningPaymentAndRefundHistory(options : { tranId? :LONG, clientTranId? :string, asset? :string, startTime :LONG, endTime :LONG, current? :INTEGER, size? :INTEGER })
  : Promise<{
     total: number,  // example: 5
     rows: {
         createTime: number,  // example: 1667880112000
         tranId: number,  // example: 121230610120
         type: number,  // example: 248
         asset: string,  // example: "USDT"
         amount: NumberString,  // example: "25.0068"
         status: string  // example: "S"
       }[]
    }>;
  
  
  getCloudMiningPaymentAndRefundHistory(...args : any) {
      return this._sendRequest("/sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage", "GET", "USER_DATA", false, args, ["tranId", "clientTranId", "asset", "startTime", "endTime", "current", "size"], "getCloudMiningPaymentAndRefundHistory");
  }
  
  
  /** Get API Key Permission (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-api-key-permission-user_data}
   * 
   * EndPoint: /sapi/v1/account/apiRestrictions
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getAPIKeyPermission(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["getAPIKeyPermission"]>;
  
  
  /** Get API Key Permission (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-api-key-permission-user_data}
   * 
   * EndPoint: /sapi/v1/account/apiRestrictions
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getAPIKeyPermission(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     ipRestrict: boolean,  // example: false
     createTime: number,  // example: 1698645219000
     enableInternalTransfer: boolean,  // example: false  // This option authorizes this key to transfer funds between your master account and your sub account instantly
     enableFutures: boolean,  // example: false  //  The Futures API cannot be used if the API key was created before the Futures account was opened, or if you have enabled portfolio margin.
     enablePortfolioMarginTrading: boolean,  // example: true  //  API Key created before your activate portfolio margin does not support portfolio margin API service
     enableVanillaOptions: boolean,  // example: false  //  Authorizes this key to Vanilla options trading
     permitsUniversalTransfer: boolean,  // example: false  // Authorizes this key to be used for a dedicated universal transfer API to transfer multiple supported currencies. Each business's own transfer API rights are not affected by this authorization
     enableReading: boolean,  // example: true
     enableSpotAndMarginTrading: boolean,  // example: false  // Spot and margin trading
     enableWithdrawals: boolean,  // example: false  // This option allows you to withdraw via API. You must apply the IP Access Restriction filter in order to enable withdrawals
     enableMargin: boolean  // example: false  //  This option can be adjusted after the Cross Margin account transfer is completed
    }>;
  
  
  getAPIKeyPermission(...args : any) {
      return this._sendRequest("/sapi/v1/account/apiRestrictions", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "getAPIKeyPermission");
  }
  
  
  /** Query auto-converting stable coins (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-auto-converting-stable-coins-user_data}
   * 
   * Get a user's auto-conversion settings in deposit/withdrawal
   * 
   * EndPoint: /sapi/v1/capital/contract/convertible-coins
   * 
   * Weight(UID): 600
   * 
   */
  queryAutoConvertingStableCoins() : Promise<{
     convertEnabled: boolean,  // example: true
     coins: string[]  // example: "USDC",
     exchangeRates: {
       USDC: NumberString,  // example: "1"
       TUSD: NumberString,  // example: "1"
       USDP: NumberString  // example: "1"
     }
    }> {
      return this._sendRequest("/sapi/v1/capital/contract/convertible-coins", "GET", "USER_DATA", false, [], [], "queryAutoConvertingStableCoins");
  }
  
  
  /** Switch on/off BUSD and stable coins conversion (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#switch-on-off-busd-and-stable-coins-conversion-user_data}
   * 
   * User can use it to turn on or turn off the BUSD auto-conversion from/to a specific stable coin.
   * 
   * EndPoint: /sapi/v1/capital/contract/convertible-coins
   * 
   * Weight(UID): 600
   * 
   * @param {string} coin  -  Must be USDC, USDP or TUSD
   * @param {boolean} enable  -  true: turn on the auto-conversion. false: turn off the auto-conversion
   */
  switchOnOffBUSDAndStableCoinsConversion(coin :string, enable :boolean)  : Promise<void>;
  
  
  /** Switch on/off BUSD and stable coins conversion (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#switch-on-off-busd-and-stable-coins-conversion-user_data}
   * 
   * User can use it to turn on or turn off the BUSD auto-conversion from/to a specific stable coin.
   * 
   * EndPoint: /sapi/v1/capital/contract/convertible-coins
   * 
   * Weight(UID): 600
   * 
   * @param {string} options.coin  -  Must be USDC, USDP or TUSD
   * @param {boolean} options.enable  -  true: turn on the auto-conversion. false: turn off the auto-conversion
   */
  switchOnOffBUSDAndStableCoinsConversion(options : { coin :string, enable :boolean })  : Promise<void>;
  
  
  switchOnOffBUSDAndStableCoinsConversion(...args : any) {
      return this._sendRequest("/sapi/v1/capital/contract/convertible-coins", "POST", "USER_DATA", false, args, ["coin", "enable"], "switchOnOffBUSDAndStableCoinsConversion");
  }
  
  
  /** One click arrival deposit apply (for expired address deposit) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#one-click-arrival-deposit-apply-for-expired-address-deposit-user_data}
   * 
   * Apply deposit credit for expired address (One click arrival)
   * 
   * EndPoint: /sapi/v1/capital/deposit/credit-apply
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} depositId  -  Deposit record Id, priority use
   * @param {string} txId  -  Deposit txId, used when depositId is not specified
   * @param {LONG} subAccountId  -  Sub-accountId of Cloud user
   * @param {LONG} subUserId  -  Sub-userId of parent user
   */
  oneClickArrivalDepositApplyForExpiredAddressDeposit(depositId? :LONG, txId? :string, subAccountId? :LONG, subUserId? :LONG)
  : ReturnType<MyBinanceClient["oneClickArrivalDepositApplyForExpiredAddressDeposit"]>;
  
  
  /** One click arrival deposit apply (for expired address deposit) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#one-click-arrival-deposit-apply-for-expired-address-deposit-user_data}
   * 
   * Apply deposit credit for expired address (One click arrival)
   * 
   * EndPoint: /sapi/v1/capital/deposit/credit-apply
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.depositId  -  Deposit record Id, priority use
   * @param {string} options.txId  -  Deposit txId, used when depositId is not specified
   * @param {LONG} options.subAccountId  -  Sub-accountId of Cloud user
   * @param {LONG} options.subUserId  -  Sub-userId of parent user
   */
  oneClickArrivalDepositApplyForExpiredAddressDeposit(options? : { depositId? :LONG, txId? :string, subAccountId? :LONG, subUserId? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: boolean,  // example: true
     success: boolean  // example: true
    }>;
  
  
  oneClickArrivalDepositApplyForExpiredAddressDeposit(...args : any) {
      return this._sendRequest("/sapi/v1/capital/deposit/credit-apply", "POST", "USER_DATA", false, args, ["depositId", "txId", "subAccountId", "subUserId"], "oneClickArrivalDepositApplyForExpiredAddressDeposit");
  }
  
  
  /** Fetch deposit address list with network(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fetch-deposit-address-list-with-network-user_data}
   * 
   * Fetch deposit address list with network.
   * 
   * EndPoint: /sapi/v1/capital/deposit/address/list
   * 
   * Weight(IP): 10
   * 
   * @param {string} coin  -  coin refers to the parent network address format that the address is using
   * @param {string} network
   * @param {LONG} timestamp
   */
  fetchDepositAddressListWithNetwork(coin :string, network? :string, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fetchDepositAddressListWithNetwork"]>;
  
  
  /** Fetch deposit address list with network(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fetch-deposit-address-list-with-network-user_data}
   * 
   * Fetch deposit address list with network.
   * 
   * EndPoint: /sapi/v1/capital/deposit/address/list
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.coin  -  coin refers to the parent network address format that the address is using
   * @param {string} options.network
   * @param {LONG} options.timestamp
   */
  fetchDepositAddressListWithNetwork(options : { coin :string, network? :string, timestamp? :LONG })
  : Promise<{
       coin: string,  // example: "ETH"
       address: NumberString,  // example: "0xD316E95Fd9E8E237Cb11f8200Babbc5D8D177BA4"
       tag: string,  // example: ""
       isDefault: number  // example: 0
     }[]>;
  
  
  fetchDepositAddressListWithNetwork(...args : any) {
      return this._sendRequest("/sapi/v1/capital/deposit/address/list", "GET", "USER_DATA", false, args, ["coin", "network", "timestamp"], "fetchDepositAddressListWithNetwork");
  }
  
  
  /** Query User Wallet Balance (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-user-wallet-balance-user_data}
   * 
   * Query User Wallet Balance
   * 
   * EndPoint: /sapi/v1/asset/wallet/balance
   * 
   * Weight(IP): 60
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryUserWalletBalance(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["queryUserWalletBalance"]>;
  
  
  /** Query User Wallet Balance (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-user-wallet-balance-user_data}
   * 
   * Query User Wallet Balance
   * 
   * EndPoint: /sapi/v1/asset/wallet/balance
   * 
   * Weight(IP): 60
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryUserWalletBalance(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       activate: boolean,  // example: true
       balance: NumberString,  // example: "0"
       walletName: string  // example: "Spot"
     }[]>;
  
  
  queryUserWalletBalance(...args : any) {
      return this._sendRequest("/sapi/v1/asset/wallet/balance", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryUserWalletBalance");
  }
  
  
  /** Query User Delegation History(For Master Account)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-user-delegation-history-for-master-account-user_data}
   * 
   * Query User Delegation History
   * 
   * EndPoint: /sapi/v1/asset/custody/transfer-history
   * 
   * Weight(IP): 60
   * 
   * @param {string} email
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {OrderType} type  -  Delegate/Undelegate
   * @param {string} asset
   * @param {INTEGER} current  -  default 1
   * @param {INTEGER} size  -  default 10, max 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryUserDelegationHistoryForMasterAccount(email :string, startTime :LONG, endTime :LONG, type? :OrderType, asset? :string, current? :INTEGER, size? :INTEGER, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryUserDelegationHistoryForMasterAccount"]>;
  
  
  /** Query User Delegation History(For Master Account)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-user-delegation-history-for-master-account-user_data}
   * 
   * Query User Delegation History
   * 
   * EndPoint: /sapi/v1/asset/custody/transfer-history
   * 
   * Weight(IP): 60
   * 
   * @param {string} options.email
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {OrderType} options.type  -  Delegate/Undelegate
   * @param {string} options.asset
   * @param {INTEGER} options.current  -  default 1
   * @param {INTEGER} options.size  -  default 10, max 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryUserDelegationHistoryForMasterAccount(options : { email :string, startTime :LONG, endTime :LONG, type? :OrderType, asset? :string, current? :INTEGER, size? :INTEGER, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 3316
     rows: {
         clientTranId: NumberString,  // example: "293915932290879488"
         transferType: string,  // example: "Undelegate"
         asset: string,  // example: "ETH"
         amount: NumberString,  // example: "1"
         time: number  // example: 1695205406000
       }[]
    }>;
  
  
  queryUserDelegationHistoryForMasterAccount(...args : any) {
      return this._sendRequest("/sapi/v1/asset/custody/transfer-history", "GET", "USER_DATA", false, args, ["email", "startTime", "endTime", "type", "asset", "current", "size", "recvWindow", "timestamp"], "queryUserDelegationHistoryForMasterAccount");
  }
  
  
  /** Get symbols delist schedule for spot (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-symbols-delist-schedule-for-spot-market_data}
   * 
   * Get symbols delist schedule for spot
   * 
   * EndPoint: /sapi/v1/spot/delist-schedule
   * 
   * Weight(IP): 100
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSymbolsDelistScheduleForSpot(recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getSymbolsDelistScheduleForSpot"]>;
  
  
  /** Get symbols delist schedule for spot (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-symbols-delist-schedule-for-spot-market_data}
   * 
   * Get symbols delist schedule for spot
   * 
   * EndPoint: /sapi/v1/spot/delist-schedule
   * 
   * Weight(IP): 100
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSymbolsDelistScheduleForSpot(options : { recvWindow? :LONG, timestamp :LONG })
  : Promise<{
       delistTime: number,  // example: 1686161202000
       symbols: string[]  // example: "ADAUSDT"
     }[]>;
  
  
  getSymbolsDelistScheduleForSpot(...args : any) {
      return this._sendRequest("/sapi/v1/spot/delist-schedule", "GET", "MARKET_DATA", false, args, ["recvWindow", "timestamp"], "getSymbolsDelistScheduleForSpot");
  }
  
  
  /** Fetch withdraw address list (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fetch-withdraw-address-list-user_data}
   * 
   * Fetch withdraw address list
   * 
   * EndPoint: /sapi/v1/capital/withdraw/address/list
   * 
   * Weight(IP): 10
   * 
   */
  fetchWithdrawAddressList() : Promise<{
       address: string,  // example: "string"
       addressTag: string,  // example: "string"
       coin: string,  // example: "string"
       name: string,  // example: "string"  //is a user-defined name
       network: string,  // example: "string"
       origin: string,  // example: "string"  //if originType=='others', the address source manually filled in by the user
       originType: string,  // example: "string"  //Address source type
       whiteStatus: boolean  // example: true  //Is it whitelisted
     }[]> {
      return this._sendRequest("/sapi/v1/capital/withdraw/address/list", "GET", "USER_DATA", false, [], [], "fetchWithdrawAddressList");
  }
  
  
  /** Account info (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-info-user_data}
   * 
   * Fetch account info detail.
   * 
   * EndPoint: /sapi/v1/account/info
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  accountInfo(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["accountInfo"]>;
  
  
  /** Account info (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-info-user_data}
   * 
   * Fetch account info detail.
   * 
   * EndPoint: /sapi/v1/account/info
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  accountInfo(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     vipLevel: number,  // example: 0
     isMarginEnabled: boolean,  // example: true  // true or false for margin
     isFutureEnabled: boolean  // example: true  // true or false for futures.
    }>;
  
  
  accountInfo(...args : any) {
      return this._sendRequest("/sapi/v1/account/info", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "accountInfo");
  }
  
  
  
  //***** Sub-Account Endpoints *****
  
  
  /** Create a Virtual Sub-account(For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#create-a-virtual-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/virtualSubAccount
   * 
   * Weight(IP): 1
   * 
   * @param {string} subAccountString  -  Please input a string. We will create a virtual email using that string for you to register
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  createAVirtualSubAccount(subAccountString :string, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["createAVirtualSubAccount"]>;
  
  
  /** Create a Virtual Sub-account(For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#create-a-virtual-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/virtualSubAccount
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.subAccountString  -  Please input a string. We will create a virtual email using that string for you to register
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  createAVirtualSubAccount(options : { subAccountString :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     email: string  // example: "addsdd_virtual@aasaixwqnoemail.com"
    }>;
  
  
  createAVirtualSubAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/virtualSubAccount", "POST", "", false, args, ["subAccountString", "recvWindow", "timestamp"], "createAVirtualSubAccount");
  }
  
  
  /** Query Sub-account List (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-list-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/list
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub-account email
   * @param {string} isFreeze  -  true or false
   * @param {INT} page  -  Default value: 1
   * @param {INT} limit  -  Default value: 1, Max value: 200
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  querySubAccountList(email :string|undefined, isFreeze :string|undefined, page :INT|undefined, limit :INT|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["querySubAccountList"]>;
  
  
  /** Query Sub-account List (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-list-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/list
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {string} options.isFreeze  -  true or false
   * @param {INT} options.page  -  Default value: 1
   * @param {INT} options.limit  -  Default value: 1, Max value: 200
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  querySubAccountList(options : { email? :string, isFreeze? :string, page? :INT, limit? :INT, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     subAccounts: {
         email: string,  // example: "testsub@gmail.com"
         isFreeze: boolean,  // example: false
         createTime: number,  // example: 1544433328000
         isManagedSubAccount: boolean,  // example: false
         isAssetManagementSubAccount: boolean  // example: false
       }[]
    }>;
  
  
  querySubAccountList(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/list", "GET", "", false, args, ["email", "isFreeze", "page", "limit", "recvWindow", "timestamp"], "querySubAccountList");
  }
  
  
  /** Query Sub-account Spot Asset Transfer History (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-spot-asset-transfer-history-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/sub/transfer/history
   * 
   * Weight(IP): 1
   * 
   * @param {string} fromEmail
   * @param {string} toEmail
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} page  -  Default value: 1
   * @param {INT} limit  -  Default value: 500
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  querySubAccountSpotAssetTransferHistory(fromEmail :string|undefined, toEmail :string|undefined, startTime :LONG|undefined, endTime :LONG|undefined, page :INT|undefined, limit :INT|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["querySubAccountSpotAssetTransferHistory"]>;
  
  
  /** Query Sub-account Spot Asset Transfer History (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-spot-asset-transfer-history-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/sub/transfer/history
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.fromEmail
   * @param {string} options.toEmail
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.page  -  Default value: 1
   * @param {INT} options.limit  -  Default value: 500
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  querySubAccountSpotAssetTransferHistory(options : { fromEmail? :string, toEmail? :string, startTime? :LONG, endTime? :LONG, page? :INT, limit? :INT, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
       from: string,  // example: "aaa@test.com"
       to: string,  // example: "bbb@test.com"
       asset: string,  // example: "BTC"
       qty: NumberString,  // example: "10"
       status: string,  // example: "SUCCESS"
       tranId: number,  // example: 6489943656
       time: number  // example: 1544433328000
     }[]>;
  
  
  querySubAccountSpotAssetTransferHistory(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/sub/transfer/history", "GET", "", false, args, ["fromEmail", "toEmail", "startTime", "endTime", "page", "limit", "recvWindow", "timestamp"], "querySubAccountSpotAssetTransferHistory");
  }
  
  
  /** Query Sub-account Futures Asset Transfer History (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-futures-asset-transfer-history-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/internalTransfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub-account email
   * @param {LONG} futuresType  -  1:USDT-margined Futures，2: Coin-margined Futures
   * @param {LONG} startTime  -  Default return the history with in 100 days
   * @param {LONG} endTime  -  Default return the history with in 100 days
   * @param {INT} page  -  Default value: 1
   * @param {INT} limit  -  Default value: 50, Max value: 500
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  querySubAccountFuturesAssetTransferHistory(email :string, futuresType :LONG, startTime :LONG|undefined, endTime :LONG|undefined, page :INT|undefined, limit :INT|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["querySubAccountFuturesAssetTransferHistory"]>;
  
  
  /** Query Sub-account Futures Asset Transfer History (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-futures-asset-transfer-history-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/internalTransfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {LONG} options.futuresType  -  1:USDT-margined Futures，2: Coin-margined Futures
   * @param {LONG} options.startTime  -  Default return the history with in 100 days
   * @param {LONG} options.endTime  -  Default return the history with in 100 days
   * @param {INT} options.page  -  Default value: 1
   * @param {INT} options.limit  -  Default value: 50, Max value: 500
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  querySubAccountFuturesAssetTransferHistory(options : { email :string, futuresType :LONG, startTime? :LONG, endTime? :LONG, page? :INT, limit? :INT, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     success: boolean,  // example: true
     futuresType: number,  // example: 2
     transfers: {
         from: string,  // example: "aaa@test.com"
         to: string,  // example: "bbb@test.com"
         asset: string,  // example: "BTC"
         qty: NumberString,  // example: "1"
         tranId: number,  // example: 11897001102
         time: number  // example: 1544433328000
       }[]
    }>;
  
  
  querySubAccountFuturesAssetTransferHistory(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/futures/internalTransfer", "GET", "", false, args, ["email", "futuresType", "startTime", "endTime", "page", "limit", "recvWindow", "timestamp"], "querySubAccountFuturesAssetTransferHistory");
  }
  
  
  /** Sub-account Futures Asset Transfer (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#sub-account-futures-asset-transfer-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/internalTransfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} fromEmail  -  Sender email
   * @param {string} toEmail  -  Recipient email
   * @param {LONG} futuresType  -  1:USDT-margined Futures，2: Coin-margined Futures
   * @param {string} asset
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  subAccountFuturesAssetTransfer(fromEmail :string, toEmail :string, futuresType :LONG, asset :string, amount :DECIMAL, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["subAccountFuturesAssetTransfer"]>;
  
  
  /** Sub-account Futures Asset Transfer (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#sub-account-futures-asset-transfer-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/internalTransfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.fromEmail  -  Sender email
   * @param {string} options.toEmail  -  Recipient email
   * @param {LONG} options.futuresType  -  1:USDT-margined Futures，2: Coin-margined Futures
   * @param {string} options.asset
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  subAccountFuturesAssetTransfer(options : { fromEmail :string, toEmail :string, futuresType :LONG, asset :string, amount :DECIMAL, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     success: boolean,  // example: true
     txnId: NumberString  // example: "2934662589"
    }>;
  
  
  subAccountFuturesAssetTransfer(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/futures/internalTransfer", "POST", "", false, args, ["fromEmail", "toEmail", "futuresType", "asset", "amount", "recvWindow", "timestamp"], "subAccountFuturesAssetTransfer");
  }
  
  
  /** Query Sub-account Assets (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-assets-for-master-account}
   * 
   * Fetch sub-account assets
   * 
   * EndPoint: /sapi/v3/sub-account/assets
   * 
   * Weight(UID): 60
   * 
   * @param {string} email  -  Sub account email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  querySubAccountAssets(email :string, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["querySubAccountAssets"]>;
  
  
  /** Query Sub-account Assets (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-assets-for-master-account}
   * 
   * Fetch sub-account assets
   * 
   * EndPoint: /sapi/v3/sub-account/assets
   * 
   * Weight(UID): 60
   * 
   * @param {string} options.email  -  Sub account email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  querySubAccountAssets(options : { email :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     balances: {
         asset: string,  // example: "ADA"
         free: number,   // example: 10000
         locked: number  // example: 0
       }[]
    }>;
  
  
  querySubAccountAssets(...args : any) {
      return this._sendRequest("/sapi/v3/sub-account/assets", "GET", "", false, args, ["email", "recvWindow", "timestamp"], "querySubAccountAssets");
  }
  
  
  /** Query Sub-account Spot Assets Summary (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-spot-assets-summary-for-master-account}
   * 
   * Get BTC valued asset summary of subaccounts.
   * 
   * EndPoint: /sapi/v1/sub-account/spotSummary
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub account email
   * @param {LONG} page  -  default 1
   * @param {LONG} size  -  default 10, max 20
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  querySubAccountSpotAssetsSummary(email :string|undefined, page :LONG|undefined, size :LONG|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["querySubAccountSpotAssetsSummary"]>;
  
  
  /** Query Sub-account Spot Assets Summary (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-spot-assets-summary-for-master-account}
   * 
   * Get BTC valued asset summary of subaccounts.
   * 
   * EndPoint: /sapi/v1/sub-account/spotSummary
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub account email
   * @param {LONG} options.page  -  default 1
   * @param {LONG} options.size  -  default 10, max 20
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  querySubAccountSpotAssetsSummary(options : { email? :string, page? :LONG, size? :LONG, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     totalCount: number,  // example: 2
     masterAccountTotalAsset: NumberString,  // example: "0.23231201"
     spotSubUserAssetBtcVoList: {
         email: string,  // example: "sub123@test.com"
         totalAsset: NumberString  // example: "9999.00000000"
       }[]
    }>;
  
  
  querySubAccountSpotAssetsSummary(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/spotSummary", "GET", "", false, args, ["email", "page", "size", "recvWindow", "timestamp"], "querySubAccountSpotAssetsSummary");
  }
  
  
  /** Get Sub-account Deposit Address (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-sub-account-deposit-address-for-master-account}
   * 
   * Fetch sub-account deposit address
   * 
   * EndPoint: /sapi/v1/capital/deposit/subAddress
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub account email
   * @param {string} coin
   * @param {string} network
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSubAccountDepositAddress(email :string, coin :string, network :string|undefined, amount :DECIMAL|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getSubAccountDepositAddress"]>;
  
  
  /** Get Sub-account Deposit Address (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-sub-account-deposit-address-for-master-account}
   * 
   * Fetch sub-account deposit address
   * 
   * EndPoint: /sapi/v1/capital/deposit/subAddress
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub account email
   * @param {string} options.coin
   * @param {string} options.network
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSubAccountDepositAddress(options : { email :string, coin :string, network? :string, amount? :DECIMAL, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     address: string,  // example: "TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV"
     coin: string,  // example: "USDT"
     tag: string,  // example: ""
     url: string  // example: "https://tronscan.org/#/address/TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV"
    }>;
  
  
  getSubAccountDepositAddress(...args : any) {
      return this._sendRequest("/sapi/v1/capital/deposit/subAddress", "GET", "", false, args, ["email", "coin", "network", "amount", "recvWindow", "timestamp"], "getSubAccountDepositAddress");
  }
  
  
  /** Get Sub-account Deposit History (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-sub-account-deposit-history-for-master-account}
   * 
   * Fetch sub-account deposit history
   * 
   * EndPoint: /sapi/v1/capital/deposit/subHisrec
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub account email
   * @param {string} coin
   * @param {INT} status  -  0(0:pending,6: credited but cannot withdraw,7:Wrong Deposit,8:Waiting User confirm,1:success)
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit
   * @param {INT} offset  -  default:0
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   * @param {string} txId
   */
  getSubAccountDepositHistory(email :string, coin :string|undefined, status :INT|undefined, startTime :LONG|undefined, endTime :LONG|undefined, limit :INT|undefined, offset :INT|undefined, recvWindow :LONG|undefined, timestamp :LONG, txId? :string)
  : ReturnType<MyBinanceClient["getSubAccountDepositHistory"]>;
  
  
  /** Get Sub-account Deposit History (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-sub-account-deposit-history-for-master-account}
   * 
   * Fetch sub-account deposit history
   * 
   * EndPoint: /sapi/v1/capital/deposit/subHisrec
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub account email
   * @param {string} options.coin
   * @param {INT} options.status  -  0(0:pending,6: credited but cannot withdraw,7:Wrong Deposit,8:Waiting User confirm,1:success)
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit
   * @param {INT} options.offset  -  default:0
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   * @param {string} options.txId
   */
  getSubAccountDepositHistory(options : { email :string, coin? :string, status? :INT, startTime? :LONG, endTime? :LONG, limit? :INT, offset? :INT, recvWindow? :LONG, timestamp :LONG, txId? :string })
  : Promise<(
     {
       id: NumberString,  // example: "769800519366885376"
       amount: NumberString,  // example: "0.001"
       coin: string,  // example: "BNB"
       network: string,  // example: "BNB"
       status: number,  // example: 0
       address: string,  // example: "bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23"
       addressTag: NumberString,  // example: "101764890"
       txId: string,  // example: "98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC"
       insertTime: number,  // example: 1661493146000
       transferType: number,  // example: 0
       confirmTimes: string,  // example: "1/1"
       unlockConfirm: number,  // example: 0
       walletType: number  // example: 0
     } |
     {
       id: NumberString,  // example: "769754833590042625"
       amount: NumberString,  // example: "0.50000000"
       coin: string,  // example: "IOTA"
       network: string,  // example: "IOTA"
       status: number,  // example: 1
       address: string,  // example: "SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW"
       addressTag: string,  // example: ""
       txId: string,  // example: "ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999"
       insertTime: number,  // example: 1599620082000
       transferType: number,  // example: 0
       confirmTimes: string,  // example: "1/1"
       unlockConfirm: number,  // example: 0
       walletType: number  // example: 0
     }
    )[]>;
  
  
  getSubAccountDepositHistory(...args : any) {
      return this._sendRequest("/sapi/v1/capital/deposit/subHisrec", "GET", "", false, args, ["email", "coin", "status", "startTime", "endTime", "limit", "offset", "recvWindow", "timestamp", "txId"], "getSubAccountDepositHistory");
  }
  
  
  /** Get Sub-account's Status on Margin/Futures (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-sub-account-39-s-status-on-margin-futures-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/status
   * 
   * Weight(IP): 10
   * 
   * @param {string} email  -  Sub-account email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSubAccountSStatusOnMarginFutures(email :string|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getSubAccountSStatusOnMarginFutures"]>;
  
  
  /** Get Sub-account's Status on Margin/Futures (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-sub-account-39-s-status-on-margin-futures-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/status
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSubAccountSStatusOnMarginFutures(options : { email? :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
       email: string,  // example: "123@test.com"  // user email
       isSubUserEnabled: boolean,  // example: true  // true or false
       isUserActive: boolean,  // example: true  // true or false
       insertTime: number,  // example: 1570791523523  // sub account create time
       isMarginEnabled: boolean,  // example: true  // true or false for margin
       isFutureEnabled: boolean,  // example: true  // true or false for futures.
       mobile: number  // example: 1570791523523  // user mobile number
     }[]>;
  
  
  getSubAccountSStatusOnMarginFutures(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/status", "GET", "", false, args, ["email", "recvWindow", "timestamp"], "getSubAccountSStatusOnMarginFutures");
  }
  
  
  /** Enable Margin for Sub-account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#enable-margin-for-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/margin/enable
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub-account email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  enableMarginForSubAccount(email :string, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["enableMarginForSubAccount"]>;
  
  
  /** Enable Margin for Sub-account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#enable-margin-for-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/margin/enable
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  enableMarginForSubAccount(options : { email :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     email: string,  // example: "123@test.com"
     isMarginEnabled: boolean  // example: true
    }>;
  
  
  enableMarginForSubAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/margin/enable", "POST", "", false, args, ["email", "recvWindow", "timestamp"], "enableMarginForSubAccount");
  }
  
  
  /** Get Detail on Sub-account's Margin Account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-detail-on-sub-account-39-s-margin-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/margin/account
   * 
   * Weight(IP): 10
   * 
   * @param {string} email  -  Sub-account email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getDetailOnSubAccountSMarginAccount(email :string, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getDetailOnSubAccountSMarginAccount"]>;
  
  
  /** Get Detail on Sub-account's Margin Account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-detail-on-sub-account-39-s-margin-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/margin/account
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getDetailOnSubAccountSMarginAccount(options : { email :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     email: string,  // example: "123@test.com"
     marginLevel: NumberString,  // example: "11.64405625"
     totalAssetOfBtc: NumberString,  // example: "6.82728457"
     totalLiabilityOfBtc: NumberString,  // example: "0.58633215"
     totalNetAssetOfBtc: NumberString,  // example: "6.24095242"
     marginTradeCoeffVo: {
       forceLiquidationBar: NumberString,  // example: "1.10000000"  // Liquidation margin ratio
       marginCallBar: NumberString,  // example: "1.50000000"  // Margin call margin ratio
       normalBar: NumberString  // example: "2.00000000"  // Initial margin ratio
     },
     marginUserAssetVoList: {
         asset: string,  // example: "BTC"
         borrowed: NumberString,  // example: "0.00000000"
         free: NumberString,  // example: "0.00499500"
         interest: NumberString,  // example: "0.00000000"
         locked: NumberString,  // example: "0.00000000"
         netAsset: NumberString  // example: "0.00499500"
       }[]
    }>;
  
  
  getDetailOnSubAccountSMarginAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/margin/account", "GET", "", false, args, ["email", "recvWindow", "timestamp"], "getDetailOnSubAccountSMarginAccount");
  }
  
  
  /** Get Summary of Sub-account's Margin Account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-summary-of-sub-account-39-s-margin-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/margin/accountSummary
   * 
   * Weight(IP): 10
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSummaryOfSubAccountSMarginAccount(recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getSummaryOfSubAccountSMarginAccount"]>;
  
  
  /** Get Summary of Sub-account's Margin Account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-summary-of-sub-account-39-s-margin-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/margin/accountSummary
   * 
   * Weight(IP): 10
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSummaryOfSubAccountSMarginAccount(options : { recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     totalAssetOfBtc: NumberString,  // example: "4.33333333"
     totalLiabilityOfBtc: NumberString,  // example: "2.11111112"
     totalNetAssetOfBtc: NumberString,  // example: "2.22222221"
     subAccountList: {
         email: string,  // example: "123@test.com"
         totalAssetOfBtc: NumberString,  // example: "2.11111111"
         totalLiabilityOfBtc: NumberString,  // example: "1.11111111"
         totalNetAssetOfBtc: NumberString  // example: "1.00000000"
       }[]
    }>;
  
  
  getSummaryOfSubAccountSMarginAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/margin/accountSummary", "GET", "", false, args, ["recvWindow", "timestamp"], "getSummaryOfSubAccountSMarginAccount");
  }
  
  
  /** Enable Futures for Sub-account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#enable-futures-for-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/enable
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub-account email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  enableFuturesForSubAccount(email :string, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["enableFuturesForSubAccount"]>;
  
  
  /** Enable Futures for Sub-account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#enable-futures-for-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/enable
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  enableFuturesForSubAccount(options : { email :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     email: string,  // example: "123@test.com"
     isFuturesEnabled: boolean  // example: true  // true or false
    }>;
  
  
  enableFuturesForSubAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/futures/enable", "POST", "", false, args, ["email", "recvWindow", "timestamp"], "enableFuturesForSubAccount");
  }
  
  
  /** Get Detail on Sub-account's Futures Account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-detail-on-sub-account-39-s-futures-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/account
   * 
   * Weight(IP): 10
   * 
   * @param {string} email  -  Sub-account email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getDetailOnSubAccountSFuturesAccount(email :string, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getDetailOnSubAccountSFuturesAccount"]>;
  
  
  /** Get Detail on Sub-account's Futures Account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-detail-on-sub-account-39-s-futures-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/account
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getDetailOnSubAccountSFuturesAccount(options : { email :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     email: string,  // example: "abc@test.com"
     asset: string,  // example: "USDT"
     assets: {
         asset: string,  // example: "USDT"
         initialMargin: NumberString,  // example: "0.00000000"
         maintenanceMargin: NumberString,  // example: "0.00000000"
         marginBalance: NumberString,  // example: "0.88308000"
         maxWithdrawAmount: NumberString,  // example: "0.88308000"
         openOrderInitialMargin: NumberString,  // example: "0.00000000"
         positionInitialMargin: NumberString,  // example: "0.00000000"
         unrealizedProfit: NumberString,  // example: "0.00000000"
         walletBalance: NumberString  // example: "0.88308000"
       }[],
     canDeposit: boolean,  // example: true
     canTrade: boolean,  // example: true
     canWithdraw: boolean,  // example: true
     feeTier: number,  // example: 2
     maxWithdrawAmount: NumberString,  // example: "0.88308000"
     totalInitialMargin: NumberString,  // example: "0.00000000"
     totalMaintenanceMargin: NumberString,  // example: "0.00000000"
     totalMarginBalance: NumberString,  // example: "0.88308000"
     totalOpenOrderInitialMargin: NumberString,  // example: "0.00000000"
     totalPositionInitialMargin: NumberString,  // example: "0.00000000"
     totalUnrealizedProfit: NumberString,  // example: "0.00000000"
     totalWalletBalance: NumberString,  // example: "0.88308000"
     updateTime: number  // example: 1576756674610
    }>;
  
  
  getDetailOnSubAccountSFuturesAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/futures/account", "GET", "", false, args, ["email", "recvWindow", "timestamp"], "getDetailOnSubAccountSFuturesAccount");
  }
  
  
  /** Get Summary of Sub-account's Futures Account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-summary-of-sub-account-39-s-futures-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/accountSummary
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSummaryOfSubAccountSFuturesAccount(recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getSummaryOfSubAccountSFuturesAccount"]>;
  
  
  /** Get Summary of Sub-account's Futures Account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-summary-of-sub-account-39-s-futures-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/accountSummary
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSummaryOfSubAccountSFuturesAccount(options : { recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     totalInitialMargin: NumberString,  // example: "9.83137400"
     totalMaintenanceMargin: NumberString,  // example: "0.41568700"
     totalMarginBalance: NumberString,  // example: "23.03235621"
     totalOpenOrderInitialMargin: NumberString,  // example: "9.00000000"
     totalPositionInitialMargin: NumberString,  // example: "0.83137400"
     totalUnrealizedProfit: NumberString,  // example: "0.03219710"
     totalWalletBalance: NumberString,  // example: "22.15879444"
     asset: string,  // example: "USD"
     subAccountList: {
         email: string,  // example: "123@test.com"
         totalInitialMargin: NumberString,  // example: "9.00000000"
         totalMaintenanceMargin: NumberString,  // example: "0.00000000"
         totalMarginBalance: NumberString,  // example: "22.12659734"
         totalOpenOrderInitialMargin: NumberString,  // example: "9.00000000"
         totalPositionInitialMargin: NumberString,  // example: "0.00000000"
         totalUnrealizedProfit: NumberString,  // example: "0.00000000"
         totalWalletBalance: NumberString,  // example: "22.12659734"
         asset: string  // example: "USD"
       }[]
    }>;
  
  
  getSummaryOfSubAccountSFuturesAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/futures/accountSummary", "GET", "", false, args, ["recvWindow", "timestamp"], "getSummaryOfSubAccountSFuturesAccount");
  }
  
  
  /** Get Futures Position-Risk of Sub-account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-futures-position-risk-of-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/positionRisk
   * 
   * Weight(IP): 10
   * 
   * @param {string} email  -  Sub-account email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFuturesPositionRiskOfSubAccount(email :string, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getFuturesPositionRiskOfSubAccount"]>;
  
  
  /** Get Futures Position-Risk of Sub-account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-futures-position-risk-of-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/positionRisk
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFuturesPositionRiskOfSubAccount(options : { email :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
       entryPrice: NumberString,  // example: "9975.12000"
       leverage: NumberString,  // example: "50"  // current initial leverage
       maxNotional: NumberString,  // example: "1000000"  // notional value limit of current initial leverage
       liquidationPrice: NumberString,  // example: "7963.54"
       markPrice: NumberString,  // example: "9973.50770517"
       positionAmount: NumberString,  // example: "0.010"
       symbol: string,  // example: "BTCUSDT"
       unrealizedProfit: NumberString  // example: "-0.01612295"
     }[]>;
  
  
  getFuturesPositionRiskOfSubAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/futures/positionRisk", "GET", "", false, args, ["email", "recvWindow", "timestamp"], "getFuturesPositionRiskOfSubAccount");
  }
  
  
  /** Futures Transfer for Sub-account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#futures-transfer-for-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/transfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub-account email
   * @param {string} asset  -  The asset being transferred, e.g., USDT
   * @param {DECIMAL} amount  -  The amount to be transferred
   * @param {INT} type  -  1: transfer from subaccount's spot account to its USDT-margined futures account 2: transfer from subaccount's USDT-margined futures account to its spot account 3: transfer from subaccount's spot account to its COIN-margined futures account 4:transfer from subaccount's COIN-margined futures account to its spot account
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  futuresTransferForSubAccount(email :string, asset :string, amount :DECIMAL, type :INT, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["futuresTransferForSubAccount"]>;
  
  
  /** Futures Transfer for Sub-account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#futures-transfer-for-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/futures/transfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {string} options.asset  -  The asset being transferred, e.g., USDT
   * @param {DECIMAL} options.amount  -  The amount to be transferred
   * @param {INT} options.type  -  1: transfer from subaccount's spot account to its USDT-margined futures account 2: transfer from subaccount's USDT-margined futures account to its spot account 3: transfer from subaccount's spot account to its COIN-margined futures account 4:transfer from subaccount's COIN-margined futures account to its spot account
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  futuresTransferForSubAccount(options : { email :string, asset :string, amount :DECIMAL, type :INT, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     txnId: NumberString  // example: "2966662589"
    }>;
  
  
  futuresTransferForSubAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/futures/transfer", "POST", "", false, args, ["email", "asset", "amount", "type", "recvWindow", "timestamp"], "futuresTransferForSubAccount");
  }
  
  
  /** Margin Transfer for Sub-account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-transfer-for-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/margin/transfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub-account email
   * @param {string} asset  -  The asset being transferred, e.g., BTC
   * @param {DECIMAL} amount  -  The amount to be transferred
   * @param {INT} type  -  1: transfer from subaccount's  spot account to margin account 2: transfer from subaccount's margin account to its spot account
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  marginTransferForSubAccount(email :string, asset :string, amount :DECIMAL, type :INT, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["marginTransferForSubAccount"]>;
  
  
  /** Margin Transfer for Sub-account (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-transfer-for-sub-account-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/margin/transfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {string} options.asset  -  The asset being transferred, e.g., BTC
   * @param {DECIMAL} options.amount  -  The amount to be transferred
   * @param {INT} options.type  -  1: transfer from subaccount's  spot account to margin account 2: transfer from subaccount's margin account to its spot account
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  marginTransferForSubAccount(options : { email :string, asset :string, amount :DECIMAL, type :INT, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     txnId: NumberString  // example: "2966662589"
    }>;
  
  
  marginTransferForSubAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/margin/transfer", "POST", "", false, args, ["email", "asset", "amount", "type", "recvWindow", "timestamp"], "marginTransferForSubAccount");
  }
  
  
  /** Transfer to Sub-account of Same Master (For Sub-account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#transfer-to-sub-account-of-same-master-for-sub-account}
   * 
   * EndPoint: /sapi/v1/sub-account/transfer/subToSub
   * 
   * Weight(IP): 1
   * 
   * @param {string} toEmail  -  Sub-account email
   * @param {string} asset
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  transferToSubAccountOfSameMaster(toEmail :string, asset :string, amount :DECIMAL, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["transferToSubAccountOfSameMaster"]>;
  
  
  /** Transfer to Sub-account of Same Master (For Sub-account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#transfer-to-sub-account-of-same-master-for-sub-account}
   * 
   * EndPoint: /sapi/v1/sub-account/transfer/subToSub
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.toEmail  -  Sub-account email
   * @param {string} options.asset
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  transferToSubAccountOfSameMaster(options : { toEmail :string, asset :string, amount :DECIMAL, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     txnId: NumberString  // example: "2966662589"
    }>;
  
  
  transferToSubAccountOfSameMaster(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/transfer/subToSub", "POST", "", false, args, ["toEmail", "asset", "amount", "recvWindow", "timestamp"], "transferToSubAccountOfSameMaster");
  }
  
  
  /** Transfer to Master (For Sub-account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#transfer-to-master-for-sub-account}
   * 
   * EndPoint: /sapi/v1/sub-account/transfer/subToMaster
   * 
   * Weight(IP): 1
   * 
   * @param {string} asset
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  transferToMaster(asset :string, amount :DECIMAL, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["transferToMaster"]>;
  
  
  /** Transfer to Master (For Sub-account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#transfer-to-master-for-sub-account}
   * 
   * EndPoint: /sapi/v1/sub-account/transfer/subToMaster
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.asset
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  transferToMaster(options : { asset :string, amount :DECIMAL, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     txnId: NumberString  // example: "2966662589"
    }>;
  
  
  transferToMaster(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/transfer/subToMaster", "POST", "", false, args, ["asset", "amount", "recvWindow", "timestamp"], "transferToMaster");
  }
  
  
  /** Sub-account Transfer History (For Sub-account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#sub-account-transfer-history-for-sub-account}
   * 
   * EndPoint: /sapi/v1/sub-account/transfer/subUserHistory
   * 
   * Weight(IP): 1
   * 
   * @param {string} asset  -  If not sent, result of all assets will be returned
   * @param {INT} type  -  1: transfer in, 2: transfer out
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500
   * @param {boolean} returnFailHistory  -  Default False, return PROCESS and SUCCESS status history; If True,return PROCESS and SUCCESS and FAILURE status history
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  subAccountTransferHistory(asset :string|undefined, type :INT|undefined, startTime :LONG|undefined, endTime :LONG|undefined, limit :INT|undefined, returnFailHistory :boolean|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["subAccountTransferHistory"]>;
  
  
  /** Sub-account Transfer History (For Sub-account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#sub-account-transfer-history-for-sub-account}
   * 
   * EndPoint: /sapi/v1/sub-account/transfer/subUserHistory
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.asset  -  If not sent, result of all assets will be returned
   * @param {INT} options.type  -  1: transfer in, 2: transfer out
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500
   * @param {boolean} options.returnFailHistory  -  Default False, return PROCESS and SUCCESS status history; If True,return PROCESS and SUCCESS and FAILURE status history
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  subAccountTransferHistory(options : { asset? :string, type? :INT, startTime? :LONG, endTime? :LONG, limit? :INT, returnFailHistory? :boolean, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
       counterParty: string,  // example: "master"
       email: string,  // example: "master@test.com"
       type: number,  // example: 1  // 1 for transfer in, 2 for transfer out
       asset: string,  // example: "BTC"
       qty: NumberString,  // example: "1"
       fromAccountType: string,  // example: "SPOT"
       toAccountType: string,  // example: "SPOT"
       status: string,  // example: "SUCCESS"  // status: PROCESS / SUCCESS / FAILURE
       tranId: number,  // example: 11798835829
       time: number  // example: 1544433325000
     }[]>;
  
  
  subAccountTransferHistory(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/transfer/subUserHistory", "GET", "", false, args, ["asset", "type", "startTime", "endTime", "limit", "returnFailHistory", "recvWindow", "timestamp"], "subAccountTransferHistory");
  }
  
  
  /** Universal Transfer (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#universal-transfer-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/universalTransfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} fromEmail
   * @param {string} toEmail
   * @param {string} fromAccountType  -  "SPOT","USDT_FUTURE","COIN_FUTURE","MARGIN"(Cross),"ISOLATED_MARGIN"
   * @param {string} toAccountType  -  "SPOT","USDT_FUTURE","COIN_FUTURE","MARGIN"(Cross),"ISOLATED_MARGIN"
   * @param {string} clientTranId  -  Must be unique
   * @param {string} symbol  -  Only supported under ISOLATED_MARGIN type
   * @param {string} asset
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  universalTransfer(fromEmail :string|undefined, toEmail :string|undefined, fromAccountType :string, toAccountType :string, clientTranId :string|undefined, symbol :string|undefined, asset :string, amount :DECIMAL, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["universalTransfer"]>;
  
  
  /** Universal Transfer (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#universal-transfer-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/universalTransfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.fromEmail
   * @param {string} options.toEmail
   * @param {string} options.fromAccountType  -  "SPOT","USDT_FUTURE","COIN_FUTURE","MARGIN"(Cross),"ISOLATED_MARGIN"
   * @param {string} options.toAccountType  -  "SPOT","USDT_FUTURE","COIN_FUTURE","MARGIN"(Cross),"ISOLATED_MARGIN"
   * @param {string} options.clientTranId  -  Must be unique
   * @param {string} options.symbol  -  Only supported under ISOLATED_MARGIN type
   * @param {string} options.asset
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  universalTransfer(options : { fromEmail? :string, toEmail? :string, fromAccountType :string, toAccountType :string, clientTranId? :string, symbol? :string, asset :string, amount :DECIMAL, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     tranId: number,  // example: 11945860693
     clientTranId: string  // example: "test"
    }>;
  
  
  universalTransfer(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/universalTransfer", "POST", "", false, args, ["fromEmail", "toEmail", "fromAccountType", "toAccountType", "clientTranId", "symbol", "asset", "amount", "recvWindow", "timestamp"], "universalTransfer");
  }
  
  
  /** Query Universal Transfer History (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-universal-transfer-history-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/universalTransfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} fromEmail
   * @param {string} toEmail
   * @param {string} clientTranId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} page  -  Default 1
   * @param {INT} limit  -  Default 500, Max 500
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryUniversalTransferHistory(fromEmail :string|undefined, toEmail :string|undefined, clientTranId :string|undefined, startTime :LONG|undefined, endTime :LONG|undefined, page :INT|undefined, limit :INT|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["queryUniversalTransferHistory"]>;
  
  
  /** Query Universal Transfer History (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-universal-transfer-history-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/universalTransfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.fromEmail
   * @param {string} options.toEmail
   * @param {string} options.clientTranId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.page  -  Default 1
   * @param {INT} options.limit  -  Default 500, Max 500
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryUniversalTransferHistory(options : { fromEmail? :string, toEmail? :string, clientTranId? :string, startTime? :LONG, endTime? :LONG, page? :INT, limit? :INT, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     result: {
         tranId: number,  // example: 92275823339
         fromEmail: string,  // example: "abctest@gmail.com"
         toEmail: string,  // example: "deftest@gmail.com"
         asset: string,  // example: "BNB"
         amount: NumberString,  // example: "0.01"
         createTimeStamp: number,  // example: 1640317374000
         fromAccountType: string,  // example: "USDT_FUTURE"
         toAccountType: string,  // example: "SPOT"
         status: string,  // example: "SUCCESS"
         clientTranId: string  // example: "test"
       }[],
     totalCount: number  // example: 1
    }>;
  
  
  queryUniversalTransferHistory(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/universalTransfer", "GET", "", false, args, ["fromEmail", "toEmail", "clientTranId", "startTime", "endTime", "page", "limit", "recvWindow", "timestamp"], "queryUniversalTransferHistory");
  }
  
  
  /** Get Detail on Sub-account's Futures Account V2 (For Master Account)  (USDT Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-detail-on-sub-account-39-s-futures-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/account
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub-account email
   * @param {1} futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getDetailOnSubAccountSFuturesAccountV2(email :string, futuresType :1, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getDetailOnSubAccountSFuturesAccountV2"]>;
  
  
  /** Get Detail on Sub-account's Futures Account V2 (For Master Account)  (USDT Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-detail-on-sub-account-39-s-futures-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/account
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {1} options.futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getDetailOnSubAccountSFuturesAccountV2(options : { email :string, futuresType :1, recvWindow? :LONG, timestamp :LONG })
  : Promise<{  // USDT Margined Futures：
     futureAccountResp: {
       email: string,  // example: "abc@test.com"
       assets: {
           asset: string,  // example: "USDT"
           initialMargin: NumberString,  // example: "0.00000000"
           maintenanceMargin: NumberString,  // example: "0.00000000"
           marginBalance: NumberString,  // example: "0.88308000"
           maxWithdrawAmount: NumberString,  // example: "0.88308000"
           openOrderInitialMargin: NumberString,  // example: "0.00000000"
           positionInitialMargin: NumberString,  // example: "0.00000000"
           unrealizedProfit: NumberString,  // example: "0.00000000"
           walletBalance: NumberString  // example: "0.88308000"
         }[],
       canDeposit: boolean,  // example: true
       canTrade: boolean,  // example: true
       canWithdraw: boolean,  // example: true
       feeTier: number,  // example: 2
       maxWithdrawAmount: NumberString,  // example: "0.88308000"
       totalInitialMargin: NumberString,  // example: "0.00000000"
       totalMaintenanceMargin: NumberString,  // example: "0.00000000"
       totalMarginBalance: NumberString,  // example: "0.88308000"
       totalOpenOrderInitialMargin: NumberString,  // example: "0.00000000"
       totalPositionInitialMargin: NumberString,  // example: "0.00000000"
       totalUnrealizedProfit: NumberString,  // example: "0.00000000"
       totalWalletBalance: NumberString,  // example: "0.88308000"
       updateTime: number  // example: 1576756674610
     }
    }>;
  
  
  /** Get Detail on Sub-account's Futures Account V2 (For Master Account)  (COIN Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-detail-on-sub-account-39-s-futures-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/account
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub-account email
   * @param {2} futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getDetailOnSubAccountSFuturesAccountV2(email :string, futuresType :2, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getDetailOnSubAccountSFuturesAccountV2"]>;
  
  
  /** Get Detail on Sub-account's Futures Account V2 (For Master Account)  (COIN Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-detail-on-sub-account-39-s-futures-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/account
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {2} options.futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getDetailOnSubAccountSFuturesAccountV2(options : { email :string, futuresType :2, recvWindow? :LONG, timestamp :LONG })
  : Promise<{  // COIN Margined Futures：
     deliveryAccountResp: {
       email: string,  // example: "abc@test.com"
       assets: {
           asset: string,  // example: "BTC"
           initialMargin: NumberString,  // example: "0.00000000"
           maintenanceMargin: NumberString,  // example: "0.00000000"
           marginBalance: NumberString,  // example: "0.88308000"
           maxWithdrawAmount: NumberString,  // example: "0.88308000"
           openOrderInitialMargin: NumberString,  // example: "0.00000000"
           positionInitialMargin: NumberString,  // example: "0.00000000"
           unrealizedProfit: NumberString,  // example: "0.00000000"
           walletBalance: NumberString  // example: "0.88308000"
         }[],
       canDeposit: boolean,  // example: true
       canTrade: boolean,  // example: true
       canWithdraw: boolean,  // example: true
       feeTier: number,  // example: 2
       updateTime: number  // example: 1598959682001
     }
    }>;
  
  
  getDetailOnSubAccountSFuturesAccountV2(...args : any) {
      return this._sendRequest("/sapi/v2/sub-account/futures/account", "GET", "", false, args, [{email:'string',futuresType:'number',recvWindow:null,timestamp:'number'}, {email:'string',futuresType:'number',recvWindow:null,timestamp:'number'}], "getDetailOnSubAccountSFuturesAccountV2");
  }
  
  
  /** Get Summary of Sub-account's Futures Account V2 (For Master Account)  (USDT Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-summary-of-sub-account-39-s-futures-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/accountSummary
   * 
   * Weight(IP): 10
   * 
   * @param {1} futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {INT} page  -  default:1
   * @param {INT} limit  -  default:10, max:20
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSummaryOfSubAccountSFuturesAccountV2(futuresType :1, page :INT|undefined, limit :INT|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getSummaryOfSubAccountSFuturesAccountV2"]>;
  
  
  /** Get Summary of Sub-account's Futures Account V2 (For Master Account)  (USDT Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-summary-of-sub-account-39-s-futures-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/accountSummary
   * 
   * Weight(IP): 10
   * 
   * @param {1} options.futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {INT} options.page  -  default:1
   * @param {INT} options.limit  -  default:10, max:20
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSummaryOfSubAccountSFuturesAccountV2(options : { futuresType :1, page? :INT, limit? :INT, recvWindow? :LONG, timestamp :LONG })
  : Promise<{  // USDT Margined Futures：
     futureAccountSummaryResp: {
       totalInitialMargin: NumberString,  // example: "9.83137400"
       totalMaintenanceMargin: NumberString,  // example: "0.41568700"
       totalMarginBalance: NumberString,  // example: "23.03235621"
       totalOpenOrderInitialMargin: NumberString,  // example: "9.00000000"
       totalPositionInitialMargin: NumberString,  // example: "0.83137400"
       totalUnrealizedProfit: NumberString,  // example: "0.03219710"
       totalWalletBalance: NumberString,  // example: "22.15879444"
       asset: string,  // example: "USD"
       subAccountList: {
           email: string,  // example: "123@test.com"
           totalInitialMargin: NumberString,  // example: "9.00000000"
           totalMaintenanceMargin: NumberString,  // example: "0.00000000"
           totalMarginBalance: NumberString,  // example: "22.12659734"
           totalOpenOrderInitialMargin: NumberString,  // example: "9.00000000"
           totalPositionInitialMargin: NumberString,  // example: "0.00000000"
           totalUnrealizedProfit: NumberString,  // example: "0.00000000"
           totalWalletBalance: NumberString,  // example: "22.12659734"
           asset: string  // example: "USD"
         }[]
     }
    }>;
  
  
  /** Get Summary of Sub-account's Futures Account V2 (For Master Account)  (COIN Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-summary-of-sub-account-39-s-futures-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/accountSummary
   * 
   * Weight(IP): 10
   * 
   * @param {2} futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {INT} page  -  default:1
   * @param {INT} limit  -  default:10, max:20
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSummaryOfSubAccountSFuturesAccountV2(futuresType :2, page :INT|undefined, limit :INT|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getSummaryOfSubAccountSFuturesAccountV2"]>;
  
  
  /** Get Summary of Sub-account's Futures Account V2 (For Master Account)  (COIN Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-summary-of-sub-account-39-s-futures-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/accountSummary
   * 
   * Weight(IP): 10
   * 
   * @param {2} options.futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {INT} options.page  -  default:1
   * @param {INT} options.limit  -  default:10, max:20
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSummaryOfSubAccountSFuturesAccountV2(options : { futuresType :2, page? :INT, limit? :INT, recvWindow? :LONG, timestamp :LONG })
  : Promise<{  // COIN Margined Futures：
     deliveryAccountSummaryResp: {
       totalMarginBalanceOfBTC: NumberString,  // example: "25.03221121"
       totalUnrealizedProfitOfBTC: NumberString,  // example: "0.12233410"
       totalWalletBalanceOfBTC: NumberString,  // example: "22.15879444"
       asset: string,  // example: "BTC"
       subAccountList: {
           email: string,  // example: "123@test.com"
           totalMarginBalance: NumberString,  // example: "22.12659734"
           totalUnrealizedProfit: NumberString,  // example: "0.00000000"
           totalWalletBalance: NumberString,  // example: "22.12659734"
           asset: string  // example: "BTC"
         }[]
     }
    }>;
  
  
  getSummaryOfSubAccountSFuturesAccountV2(...args : any) {
      return this._sendRequest("/sapi/v2/sub-account/futures/accountSummary", "GET", "", false, args, [{futuresType:'number',page:null,limit:null,recvWindow:null,timestamp:'number'}, {futuresType:'number',page:null,limit:null,recvWindow:null,timestamp:'number'}], "getSummaryOfSubAccountSFuturesAccountV2");
  }
  
  
  /** Get Futures Position-Risk of Sub-account V2 (For Master Account)  (USDT Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-futures-position-risk-of-sub-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/positionRisk
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub-account email
   * @param {1} futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFuturesPositionRiskOfSubAccountV2(email :string, futuresType :1, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getFuturesPositionRiskOfSubAccountV2"]>;
  
  
  /** Get Futures Position-Risk of Sub-account V2 (For Master Account)  (USDT Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-futures-position-risk-of-sub-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/positionRisk
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {1} options.futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFuturesPositionRiskOfSubAccountV2(options : { email :string, futuresType :1, recvWindow? :LONG, timestamp :LONG })
  : Promise<{  // USDT Margined Futures：
     futurePositionRiskVos: {
         entryPrice: NumberString,  // example: "9975.12000"
         leverage: NumberString,  // example: "50"  // current initial leverage
         maxNotional: NumberString,  // example: "1000000"  // notional value limit of current initial leverage
         liquidationPrice: NumberString,  // example: "7963.54"
         markPrice: NumberString,  // example: "9973.50770517"
         positionAmount: NumberString,  // example: "0.010"
         symbol: string,  // example: "BTCUSDT"
         unrealizedProfit: NumberString  // example: "-0.01612295"
       }[]
    }>;
  
  
  /** Get Futures Position-Risk of Sub-account V2 (For Master Account)  (COIN Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-futures-position-risk-of-sub-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/positionRisk
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub-account email
   * @param {2} futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFuturesPositionRiskOfSubAccountV2(email :string, futuresType :2, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getFuturesPositionRiskOfSubAccountV2"]>;
  
  
  /** Get Futures Position-Risk of Sub-account V2 (For Master Account)  (COIN Margined Futures：)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-futures-position-risk-of-sub-account-v2-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/futures/positionRisk
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {2} options.futuresType  -  1:USDT Margined Futures, 2:COIN Margined Futures
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFuturesPositionRiskOfSubAccountV2(options : { email :string, futuresType :2, recvWindow? :LONG, timestamp :LONG })
  : Promise<{  // COIN Margined Futures：
     deliveryPositionRiskVos: {
         entryPrice: NumberString,  // example: "9975.12000"
         markPrice: NumberString,  // example: "9973.50770517"
         leverage: NumberString,  // example: "20"
         isolated: string,  // example: "false"
         isolatedWallet: NumberString,  // example: "9973.50770517"
         isolatedMargin: NumberString,  // example: "0.00000000"
         isAutoAddMargin: string,  // example: "false"
         positionSide: PositionSide,  // example: "BOTH"
         positionAmount: NumberString,  // example: "1.230"
         symbol: string,  // example: "BTCUSD_201225"
         unrealizedProfit: NumberString  // example: "-0.01612295"
       }[]
    }>;
  
  
  getFuturesPositionRiskOfSubAccountV2(...args : any) {
      return this._sendRequest("/sapi/v2/sub-account/futures/positionRisk", "GET", "", false, args, [{email:'string',futuresType:'number',recvWindow:null,timestamp:'number'}, {email:'string',futuresType:'number',recvWindow:null,timestamp:'number'}], "getFuturesPositionRiskOfSubAccountV2");
  }
  
  
  /** Get IP Restriction for a Sub-account API Key (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-ip-restriction-for-a-sub-account-api-key-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/subAccountApi/ipRestriction
   * 
   * Weight(UID): 3000
   * 
   * @param {string} email  -  Sub-account email
   * @param {string} subAccountApiKey
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getIPRestrictionForASubAccountAPIKey(email :string, subAccountApiKey :string, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getIPRestrictionForASubAccountAPIKey"]>;
  
  
  /** Get IP Restriction for a Sub-account API Key (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-ip-restriction-for-a-sub-account-api-key-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/subAccountApi/ipRestriction
   * 
   * Weight(UID): 3000
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {string} options.subAccountApiKey
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getIPRestrictionForASubAccountAPIKey(options : { email :string, subAccountApiKey :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     ipRestrict: string,  // example: "true"
     ipList: string[]  // example: "69.210.67.14",
     updateTime: number,  // example: 1636371437000
     apiKey: string  // example: "k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"
    }>;
  
  
  getIPRestrictionForASubAccountAPIKey(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/subAccountApi/ipRestriction", "GET", "", false, args, ["email", "subAccountApiKey", "recvWindow", "timestamp"], "getIPRestrictionForASubAccountAPIKey");
  }
  
  
  /** Delete IP List For a Sub-account API Key (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#delete-ip-list-for-a-sub-account-api-key-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/subAccountApi/ipRestriction/ipList
   * 
   * Weight(UID): 3000
   * 
   * @param {string} email  -  Sub-account email
   * @param {string} subAccountApiKey
   * @param {string} ipAddress  -  Can be added in batches, separated by commas
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  deleteIPListForASubAccountAPIKey(email :string, subAccountApiKey :string, ipAddress :string|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["deleteIPListForASubAccountAPIKey"]>;
  
  
  /** Delete IP List For a Sub-account API Key (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#delete-ip-list-for-a-sub-account-api-key-for-master-account}
   * 
   * EndPoint: /sapi/v1/sub-account/subAccountApi/ipRestriction/ipList
   * 
   * Weight(UID): 3000
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {string} options.subAccountApiKey
   * @param {string} options.ipAddress  -  Can be added in batches, separated by commas
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  deleteIPListForASubAccountAPIKey(options : { email :string, subAccountApiKey :string, ipAddress? :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     ipRestrict: string,  // example: "true"
     ipList: string[]  // example: "69.210.67.14",
     updateTime: number,  // example: 1636371437000
     apiKey: string  // example: "k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"
    }>;
  
  
  deleteIPListForASubAccountAPIKey(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/subAccountApi/ipRestriction/ipList", "DELETE", "", false, args, ["email", "subAccountApiKey", "ipAddress", "recvWindow", "timestamp"], "deleteIPListForASubAccountAPIKey");
  }
  
  
  /** Add IP Restriction for Sub-Account API key (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#add-ip-restriction-for-sub-account-api-key-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/subAccountApi/ipRestriction
   * 
   * Weight(UID): 3000
   * 
   * @param {string} email  -  Sub-account email
   * @param {string} subAccountApiKey
   * @param {string} status  -  IP Restriction status. 1 = IP Unrestricted. 2 = Restrict access to trusted IPs only.
   * @param {string} ipAddress  -  Insert static IP in batch, separated by commas.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  addIPRestrictionForSubAccountAPIKey(email :string, subAccountApiKey :string, status :string, ipAddress :string|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["addIPRestrictionForSubAccountAPIKey"]>;
  
  
  /** Add IP Restriction for Sub-Account API key (For Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#add-ip-restriction-for-sub-account-api-key-for-master-account}
   * 
   * EndPoint: /sapi/v2/sub-account/subAccountApi/ipRestriction
   * 
   * Weight(UID): 3000
   * 
   * @param {string} options.email  -  Sub-account email
   * @param {string} options.subAccountApiKey
   * @param {string} options.status  -  IP Restriction status. 1 = IP Unrestricted. 2 = Restrict access to trusted IPs only.
   * @param {string} options.ipAddress  -  Insert static IP in batch, separated by commas.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  addIPRestrictionForSubAccountAPIKey(options : { email :string, subAccountApiKey :string, status :string, ipAddress? :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     status: NumberString,  // example: "2"
     ipList: string[]  // example: "69.210.67.14",
     updateTime: number,  // example: 1636371437000
     apiKey: string  // example: "k5V49ldtn4tszj6W3hystegdfvmGbqDzjmkCtpTvC0G74WhK7yd4rfCTo4lShf"
    }>;
  
  
  addIPRestrictionForSubAccountAPIKey(...args : any) {
      return this._sendRequest("/sapi/v2/sub-account/subAccountApi/ipRestriction", "POST", "", false, args, ["email", "subAccountApiKey", "status", "ipAddress", "recvWindow", "timestamp"], "addIPRestrictionForSubAccountAPIKey");
  }
  
  
  /** Deposit Assets Into The Managed Sub-account(For Investor Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#deposit-assets-into-the-managed-sub-account-for-investor-master-account}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/deposit
   * 
   * Weight(IP): 1
   * 
   * @param {string} toEmail
   * @param {string} asset
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  depositAssetsIntoTheManagedSubAccount(toEmail :string, asset :string, amount :DECIMAL, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["depositAssetsIntoTheManagedSubAccount"]>;
  
  
  /** Deposit Assets Into The Managed Sub-account(For Investor Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#deposit-assets-into-the-managed-sub-account-for-investor-master-account}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/deposit
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.toEmail
   * @param {string} options.asset
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  depositAssetsIntoTheManagedSubAccount(options : { toEmail :string, asset :string, amount :DECIMAL, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     tranId: number  // example: 66157362489
    }>;
  
  
  depositAssetsIntoTheManagedSubAccount(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/deposit", "POST", "", false, args, ["toEmail", "asset", "amount", "recvWindow", "timestamp"], "depositAssetsIntoTheManagedSubAccount");
  }
  
  
  /** Query Managed Sub-account Asset Details(For Investor Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-asset-details-for-investor-master-account}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/asset
   * 
   * Weight(IP): 1
   * 
   * @param {string} email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryManagedSubAccountAssetDetails(email :string, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["queryManagedSubAccountAssetDetails"]>;
  
  
  /** Query Managed Sub-account Asset Details(For Investor Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-asset-details-for-investor-master-account}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/asset
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryManagedSubAccountAssetDetails(options : { email :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
       coin: string,  // example: "INJ"
       name: string,  // example: "Injective Protocol"
       totalBalance: NumberString,  // example: "0"
       availableBalance: NumberString,  // example: "0"
       inOrder: NumberString,  // example: "0"
       btcValue: NumberString  // example: "0"
     }[]>;
  
  
  queryManagedSubAccountAssetDetails(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/asset", "GET", "", false, args, ["email", "recvWindow", "timestamp"], "queryManagedSubAccountAssetDetails");
  }
  
  
  /** Withdrawl Assets From The Managed Sub-account(For Investor Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#withdrawl-assets-from-the-managed-sub-account-for-investor-master-account}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/withdraw
   * 
   * Weight(IP): 1
   * 
   * @param {string} fromEmail
   * @param {string} asset
   * @param {DECIMAL} amount
   * @param {LONG} transferDate  -  Withdrawals is automatically occur on the transfer date(UTC0). If a date is not selected, the withdrawal occurs right now
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  withdrawlAssetsFromTheManagedSubAccount(fromEmail :string, asset :string, amount :DECIMAL, transferDate :LONG|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["withdrawlAssetsFromTheManagedSubAccount"]>;
  
  
  /** Withdrawl Assets From The Managed Sub-account(For Investor Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#withdrawl-assets-from-the-managed-sub-account-for-investor-master-account}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/withdraw
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.fromEmail
   * @param {string} options.asset
   * @param {DECIMAL} options.amount
   * @param {LONG} options.transferDate  -  Withdrawals is automatically occur on the transfer date(UTC0). If a date is not selected, the withdrawal occurs right now
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  withdrawlAssetsFromTheManagedSubAccount(options : { fromEmail :string, asset :string, amount :DECIMAL, transferDate? :LONG, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     tranId: number  // example: 66157362489
    }>;
  
  
  withdrawlAssetsFromTheManagedSubAccount(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/withdraw", "POST", "", false, args, ["fromEmail", "asset", "amount", "transferDate", "recvWindow", "timestamp"], "withdrawlAssetsFromTheManagedSubAccount");
  }
  
  
  /** Query Managed Sub-account Snapshot(For Investor Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-snapshot-for-investor-master-account}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/accountSnapshot
   * 
   * Weight(IP): 2400
   * 
   * @param {string} email
   * @param {string} type  -  "SPOT", "MARGIN"（cross）, "FUTURES"（UM）
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  min 7, max 30, default 7
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryManagedSubAccountSnapshot(email :string, type :string, startTime :LONG|undefined, endTime :LONG|undefined, limit :INT|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["queryManagedSubAccountSnapshot"]>;
  
  
  /** Query Managed Sub-account Snapshot(For Investor Master Account)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-snapshot-for-investor-master-account}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/accountSnapshot
   * 
   * Weight(IP): 2400
   * 
   * @param {string} options.email
   * @param {string} options.type  -  "SPOT", "MARGIN"（cross）, "FUTURES"（UM）
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  min 7, max 30, default 7
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryManagedSubAccountSnapshot(options : { email :string, type :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     code: number,  // example: 200  // 200 for success; others are error codes
     msg: string,  // example: ""  // error message
     snapshotVos: {
         data: {
           balances: {
               asset: string,  // example: "BTC"
               free: NumberString,  // example: "0.09905021"
               locked: NumberString  // example: "0.00000000"
             }[],
           totalAssetOfBtc: NumberString  // example: "0.09942700"
         },
         type: string,  // example: "spot"
         updateTime: number  // example: 1576281599000
       }[]
    } | {
     code: number,  // example: 200  // 200 for success; others are error codes
     msg: string,  // example: ""  // error message
     snapshotVos: {
         data: {
           marginLevel: NumberString,  // example: "2748.02909813"
           totalAssetOfBtc: NumberString,  // example: "0.00274803"
           totalLiabilityOfBtc: NumberString,  // example: "0.00000100"
           totalNetAssetOfBtc: NumberString,  // example: "0.00274750"
           userAssets: {
               asset: string,  // example: "XRP"
               borrowed: NumberString,  // example: "0.00000000"
               free: NumberString,  // example: "1.00000000"
               interest: NumberString,  // example: "0.00000000"
               locked: NumberString,  // example: "0.00000000"
               netAsset: NumberString  // example: "1.00000000"
             }[]
         },
         type: string,  // example: "margin"
         updateTime: number  // example: 1576281599000
       }[]
    } | {
     code: number,  // example: 200  // 200 for success; others are error codes
     msg: string,  // example: ""  // error message
     snapshotVos: {
         data: {
           assets: {
               asset: string,  // example: "USDT"
               marginBalance: NumberString,  // example: "118.99782335"
               walletBalance: NumberString  // example: "120.23811389"
             }[],
           position: {
               entryPrice: NumberString,  // example: "7130.41000000"
               markPrice: NumberString,  // example: "7257.66239673"
               positionAmt: NumberString,  // example: "0.01000000"
               symbol: string,  // example: "BTCUSDT"
               unRealizedProfit: NumberString  // example: "1.24029054"  // Only show the value at the time of opening the position
             }[]
         },
         type: string,  // example: "futures"
         updateTime: number  // example: 1576281599000
       }[]
    }>;
  
  
  queryManagedSubAccountSnapshot(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/accountSnapshot", "GET", "", false, args, ["email", "type", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "queryManagedSubAccountSnapshot");
  }
  
  
  /** Query Managed Sub Account Transfer Log (For Investor Master Account) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-transfer-log-for-investor-master-account-user_data}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/queryTransLogForInvestor
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Managed Sub Account Email
   * @param {LONG} startTime  -  Start Time
   * @param {LONG} endTime  -  End Time (The start time and end time interval cannot exceed half a year)
   * @param {INT} page  -  Page
   * @param {INT} limit  -  Limit (Max: 500)
   * @param {string} transfers  -  Transfer Direction (from/to)
   * @param {string} transferFunctionAccountType  -  Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
   */
  queryManagedSubAccountTransferLogForInvestorMasterAccount(email :string, startTime :LONG, endTime :LONG, page :INT, limit :INT, transfers? :string, transferFunctionAccountType? :string)
  : ReturnType<MyBinanceClient["queryManagedSubAccountTransferLogForInvestorMasterAccount"]>;
  
  
  /** Query Managed Sub Account Transfer Log (For Investor Master Account) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-transfer-log-for-investor-master-account-user_data}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/queryTransLogForInvestor
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Managed Sub Account Email
   * @param {LONG} options.startTime  -  Start Time
   * @param {LONG} options.endTime  -  End Time (The start time and end time interval cannot exceed half a year)
   * @param {INT} options.page  -  Page
   * @param {INT} options.limit  -  Limit (Max: 500)
   * @param {string} options.transfers  -  Transfer Direction (from/to)
   * @param {string} options.transferFunctionAccountType  -  Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
   */
  queryManagedSubAccountTransferLogForInvestorMasterAccount(options : { email :string, startTime :LONG, endTime :LONG, page :INT, limit :INT, transfers? :string, transferFunctionAccountType? :string })
  : Promise<{
     managerSubTransferHistoryVos: {
         fromEmail: string,  // example: "test_0_virtual@kq3kno9imanagedsub.com"
         fromAccountType: string,  // example: "SPOT"
         toEmail: string,  // example: "wdywl0lddakh@test.com"
         toAccountType: string,  // example: "SPOT"
         asset: string,  // example: "BNB"
         amount: NumberString,  // example: "0.01"
         scheduledData: number,  // example: 1679416673000
         createTime: number,  // example: 1679416673000
         status: string,  // example: "SUCCESS"
         tranId: number  // example: 91077779
       }[],
     count: number  // example: 2
    }>;
  
  
  queryManagedSubAccountTransferLogForInvestorMasterAccount(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/queryTransLogForInvestor", "GET", "USER_DATA", false, args, ["email", "startTime", "endTime", "page", "limit", "transfers", "transferFunctionAccountType"], "queryManagedSubAccountTransferLogForInvestorMasterAccount");
  }
  
  
  /** Query Managed Sub Account Transfer Log (For Trading Team Master Account) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-transfer-log-for-trading-team-master-account-user_data}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/queryTransLogForTradeParent
   * 
   * Weight(UID): 60
   * 
   * @param {string} email  -  Managed Sub Account Email
   * @param {LONG} startTime  -  Start Time
   * @param {LONG} endTime  -  End Time (The start time and end time interval cannot exceed half a year)
   * @param {INT} page  -  Page
   * @param {INT} limit  -  Limit (Max: 500)
   * @param {string} transfers  -  Transfer Direction (FROM/TO)
   * @param {string} transferFunctionAccountType  -  Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
   */
  queryManagedSubAccountTransferLogForTradingTeamMasterAccount(email :string, startTime :LONG, endTime :LONG, page :INT, limit :INT, transfers? :string, transferFunctionAccountType? :string)
  : ReturnType<MyBinanceClient["queryManagedSubAccountTransferLogForTradingTeamMasterAccount"]>;
  
  
  /** Query Managed Sub Account Transfer Log (For Trading Team Master Account) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-transfer-log-for-trading-team-master-account-user_data}
   * 
   * EndPoint: /sapi/v1/managed-subaccount/queryTransLogForTradeParent
   * 
   * Weight(UID): 60
   * 
   * @param {string} options.email  -  Managed Sub Account Email
   * @param {LONG} options.startTime  -  Start Time
   * @param {LONG} options.endTime  -  End Time (The start time and end time interval cannot exceed half a year)
   * @param {INT} options.page  -  Page
   * @param {INT} options.limit  -  Limit (Max: 500)
   * @param {string} options.transfers  -  Transfer Direction (FROM/TO)
   * @param {string} options.transferFunctionAccountType  -  Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
   */
  queryManagedSubAccountTransferLogForTradingTeamMasterAccount(options : { email :string, startTime :LONG, endTime :LONG, page :INT, limit :INT, transfers? :string, transferFunctionAccountType? :string })
  : Promise<{
     managerSubTransferHistoryVos: {
         fromEmail: string,  // example: "test_0_virtual@kq3kno9imanagedsub.com"
         fromAccountType: string,  // example: "SPOT"
         toEmail: string,  // example: "wdywl0lddakh@test.com"
         toAccountType: string,  // example: "SPOT"
         asset: string,  // example: "BNB"
         amount: NumberString,  // example: "0.01"
         scheduledData: number,  // example: 1679416673000
         createTime: number,  // example: 1679416673000
         status: string,  // example: "SUCCESS"
         tranId: number  // example: 91077779
       }[],
     count: number  // example: 2
    }>;
  
  
  queryManagedSubAccountTransferLogForTradingTeamMasterAccount(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/queryTransLogForTradeParent", "GET", "USER_DATA", false, args, ["email", "startTime", "endTime", "page", "limit", "transfers", "transferFunctionAccountType"], "queryManagedSubAccountTransferLogForTradingTeamMasterAccount");
  }
  
  
  /** Query Managed Sub-account Futures Asset Details(For Investor Master Account)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-futures-asset-details-for-investor-master-account-user_data}
   * 
   * Investor can use this api to query managed sub account futures asset details
   * 
   * EndPoint: /sapi/v1/managed-subaccount/fetch-future-asset
   * 
   * Weight(UID): 60
   * 
   * @param {string} email  -  Managed Sub Account Email
   */
  queryManagedSubAccountFuturesAssetDetailsForInvestorMasterAccount(email :string)
  : ReturnType<MyBinanceClient["queryManagedSubAccountFuturesAssetDetailsForInvestorMasterAccount"]>;
  
  
  /** Query Managed Sub-account Futures Asset Details(For Investor Master Account)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-futures-asset-details-for-investor-master-account-user_data}
   * 
   * Investor can use this api to query managed sub account futures asset details
   * 
   * EndPoint: /sapi/v1/managed-subaccount/fetch-future-asset
   * 
   * Weight(UID): 60
   * 
   * @param {string} options.email  -  Managed Sub Account Email
   */
  queryManagedSubAccountFuturesAssetDetailsForInvestorMasterAccount(options : { email :string })
  : Promise<{
     code: NumberString,  // example: "200"
     message: string,  // example: "OK"
     snapshotVos: {
         type: string,  // example: "FUTURES"
         updateTime: number,  // example: 1672893855394
         data: {
           assets: {
               asset: string,  // example: "USDT"
               marginBalance: number,  // example: 100
               walletBalance: number  // example: 120
             }[],
           position: {
               symbol: string,  // example: "BTCUSDT"
               entryPrice: number,  // example: 17000
               markPrice: number,  // example: 17000
               positionAmt: number  // example: 0.0001
             }[]
         }
       }[]
    }>;
  
  
  queryManagedSubAccountFuturesAssetDetailsForInvestorMasterAccount(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/fetch-future-asset", "GET", "USER_DATA", false, args, ["email"], "queryManagedSubAccountFuturesAssetDetailsForInvestorMasterAccount");
  }
  
  
  /** Query Managed Sub-account Margin Asset Details (For Investor Master Account) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-margin-asset-details-for-investor-master-account-user_data}
   * 
   * Investor can use this api to query managed sub account margin asset details
   * 
   * EndPoint: /sapi/v1/managed-subaccount/marginAsset
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Managed Sub Account Email
   */
  queryManagedSubAccountMarginAssetDetailsForInvestorMasterAccount(email :string)
  : ReturnType<MyBinanceClient["queryManagedSubAccountMarginAssetDetailsForInvestorMasterAccount"]>;
  
  
  /** Query Managed Sub-account Margin Asset Details (For Investor Master Account) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-margin-asset-details-for-investor-master-account-user_data}
   * 
   * Investor can use this api to query managed sub account margin asset details
   * 
   * EndPoint: /sapi/v1/managed-subaccount/marginAsset
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Managed Sub Account Email
   */
  queryManagedSubAccountMarginAssetDetailsForInvestorMasterAccount(options : { email :string })
  : Promise<{
     marginLevel: NumberString,  // example: "999"
     totalAssetOfBtc: NumberString,  // example: "0"
     totalLiabilityOfBtc: NumberString,  // example: "0"
     totalNetAssetOfBtc: NumberString,  // example: "0"
     userAssets: {
         asset: string,  // example: "MATIC"
         borrowed: NumberString,  // example: "0"
         free: NumberString,  // example: "0"
         interest: NumberString,  // example: "0"
         locked: NumberString,  // example: "0"
         netAsset: NumberString  // example: "0"
       }[]
    }>;
  
  
  queryManagedSubAccountMarginAssetDetailsForInvestorMasterAccount(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/marginAsset", "GET", "USER_DATA", false, args, ["email"], "queryManagedSubAccountMarginAssetDetailsForInvestorMasterAccount");
  }
  
  
  /** Query Sub-account Assets (For Master Account)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-assets-for-master-account-user_data}
   * 
   * Fetch sub-account assets
   * 
   * EndPoint: /sapi/v4/sub-account/assets
   * 
   * Weight(UID): 60
   * 
   * @param {string} email  -  Managed Sub Account Email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  querySubAccountAssetsForMasterAccount(email :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["querySubAccountAssetsForMasterAccount"]>;
  
  
  /** Query Sub-account Assets (For Master Account)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-assets-for-master-account-user_data}
   * 
   * Fetch sub-account assets
   * 
   * EndPoint: /sapi/v4/sub-account/assets
   * 
   * Weight(UID): 60
   * 
   * @param {string} options.email  -  Managed Sub Account Email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  querySubAccountAssetsForMasterAccount(options : { email :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     balances: {
         asset: string,  // example: "ADA"
         free: NumberString,  // example: "10000"
         locked: NumberString  // example: "0"
       }[]
    }>;
  
  
  querySubAccountAssetsForMasterAccount(...args : any) {
      return this._sendRequest("/sapi/v4/sub-account/assets", "GET", "USER_DATA", false, args, ["email", "recvWindow", "timestamp"], "querySubAccountAssetsForMasterAccount");
  }
  
  
  /** Query Managed Sub-account List (For Investor)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-list-for-investor-user_data}
   * 
   * Get investor's managed sub-account list.
   * 
   * EndPoint: /sapi/v1/managed-subaccount/info
   * 
   * Weight(UID): 60
   * 
   * @param {string} email  -  Managed sub-account email
   * @param {INT} page  -  Default value: 1
   * @param {INT} limit  -  Default value: 20, Max value: 20
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryManagedSubAccountListForInvestor(email? :string, page? :INT, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryManagedSubAccountListForInvestor"]>;
  
  
  /** Query Managed Sub-account List (For Investor)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-list-for-investor-user_data}
   * 
   * Get investor's managed sub-account list.
   * 
   * EndPoint: /sapi/v1/managed-subaccount/info
   * 
   * Weight(UID): 60
   * 
   * @param {string} options.email  -  Managed sub-account email
   * @param {INT} options.page  -  Default value: 1
   * @param {INT} options.limit  -  Default value: 20, Max value: 20
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryManagedSubAccountListForInvestor(options? : { email? :string, page? :INT, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 3
     managerSubUserInfoVoList: {
         rootUserId: number,  // example: 1000138475670
         managersubUserId: number,  // example: 1000137842513
         bindParentUserId: number,  // example: 1000138475669
         email: string,  // example: "test_0_virtual@kq3kno9imanagedsub.com"
         insertTimeStamp: number,  // example: 1678435149000
         bindParentEmail: string,  // example: "wdyw8xsh8pey@test.com"
         isSubUserEnabled: boolean,  // example: true
         isUserActive: boolean,  // example: true
         isMarginEnabled: boolean,  // example: false
         isFutureEnabled: boolean,  // example: false
         isSignedLVTRiskAgreement: boolean  // example: false
       }[]
    }>;
  
  
  queryManagedSubAccountListForInvestor(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/info", "GET", "USER_DATA", false, args, ["email", "page", "limit", "recvWindow", "timestamp"], "queryManagedSubAccountListForInvestor");
  }
  
  
  /** Query Sub-account Transaction Statistics (For Master Account) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-transaction-statistics-for-master-account-user_data}
   * 
   * Query Sub-account Transaction statistics (For Master Account).
   * 
   * EndPoint: /sapi/v1/sub-account/transaction-statistics
   * 
   * Weight(UID): 60
   * 
   * @param {string} email  -  Sub user email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  querySubAccountTransactionStatisticsForMasterAccount(email :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["querySubAccountTransactionStatisticsForMasterAccount"]>;
  
  
  /** Query Sub-account Transaction Statistics (For Master Account) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-account-transaction-statistics-for-master-account-user_data}
   * 
   * Query Sub-account Transaction statistics (For Master Account).
   * 
   * EndPoint: /sapi/v1/sub-account/transaction-statistics
   * 
   * Weight(UID): 60
   * 
   * @param {string} options.email  -  Sub user email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  querySubAccountTransactionStatisticsForMasterAccount(options : { email :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     recent30BtcTotal: NumberString,  // example: "0"
     recent30BtcFuturesTotal: NumberString,  // example: "0"
     recent30BtcMarginTotal: NumberString,  // example: "0"
     recent30BusdTotal: NumberString,  // example: "0"
     recent30BusdFuturesTotal: NumberString,  // example: "0"
     recent30BusdMarginTotal: NumberString,  // example: "0"
     tradeInfoVos: {
         userId: number,  // example: 1000138138384
         btc: number,  // example: 0
         btcFutures: number,  // example: 0
         btcMargin: number,  // example: 0
         busd: number,  // example: 0
         busdFutures: number,  // example: 0
         busdMargin: number,  // example: 0
         date: number  // example: 1676851200000
       }[]
    }>;
  
  
  querySubAccountTransactionStatisticsForMasterAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/transaction-statistics", "GET", "USER_DATA", false, args, ["email", "recvWindow", "timestamp"], "querySubAccountTransactionStatisticsForMasterAccount");
  }
  
  
  /** Get Managed Sub-account Deposit Address (For Investor Master Account) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-managed-sub-account-deposit-address-for-investor-master-account-user_data}
   * 
   * Get investor's managed sub-account deposit address.
   * 
   * EndPoint: /sapi/v1/managed-subaccount/deposit/address
   * 
   * Weight(UID): 1
   * 
   * @param {string} email  -  Sub user email
   * @param {string} coin
   * @param {string} network  -  networks can be found in GET /sapi/v1/capital/deposit/address
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getManagedSubAccountDepositAddressForInvestorMasterAccount(email :string, coin :string, network? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getManagedSubAccountDepositAddressForInvestorMasterAccount"]>;
  
  
  /** Get Managed Sub-account Deposit Address (For Investor Master Account) (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-managed-sub-account-deposit-address-for-investor-master-account-user_data}
   * 
   * Get investor's managed sub-account deposit address.
   * 
   * EndPoint: /sapi/v1/managed-subaccount/deposit/address
   * 
   * Weight(UID): 1
   * 
   * @param {string} options.email  -  Sub user email
   * @param {string} options.coin
   * @param {string} options.network  -  networks can be found in GET /sapi/v1/capital/deposit/address
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getManagedSubAccountDepositAddressForInvestorMasterAccount(options : { email :string, coin :string, network? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     coin: string,  // example: "USDT"
     address: NumberString,  // example: "0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d"
     tag: string,  // example: ""
     url: string  // example: "https://etherscan.io/address/0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d"
    }>;
  
  
  getManagedSubAccountDepositAddressForInvestorMasterAccount(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/deposit/address", "GET", "USER_DATA", false, args, ["email", "coin", "network", "recvWindow", "timestamp"], "getManagedSubAccountDepositAddressForInvestorMasterAccount");
  }
  
  
  /** Enable Options for Sub-account (For Master Account)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#enable-options-for-sub-account-for-master-account-user_data}
   * 
   * Enable Options for Sub-account (For Master Account).
   * 
   * EndPoint: /sapi/v1/sub-account/eoptions/enable
   * 
   * Weight(IP): 1
   * 
   * @param {string} email  -  Sub user email
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  enableOptionsForSubAccountForMasterAccount(email :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["enableOptionsForSubAccountForMasterAccount"]>;
  
  
  /** Enable Options for Sub-account (For Master Account)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#enable-options-for-sub-account-for-master-account-user_data}
   * 
   * Enable Options for Sub-account (For Master Account).
   * 
   * EndPoint: /sapi/v1/sub-account/eoptions/enable
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.email  -  Sub user email
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  enableOptionsForSubAccountForMasterAccount(options : { email :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     email: string,  // example: "123@test.com"
     isEOptionsEnabled: boolean  // example: true  // true or false
    }>;
  
  
  enableOptionsForSubAccountForMasterAccount(...args : any) {
      return this._sendRequest("/sapi/v1/sub-account/eoptions/enable", "POST", "USER_DATA", false, args, ["email", "recvWindow", "timestamp"], "enableOptionsForSubAccountForMasterAccount");
  }
  
  
  /** Query Managed Sub Account Transfer Log (For Trading Team Sub Account)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-transfer-log-for-trading-team-sub-account-user_data}
   * 
   * Query Managed Sub Account Transfer Log (For Trading Team Sub Account)
   * 
   * EndPoint: /sapi/v1/managed-subaccount/query-trans-log
   * 
   * Weight(UID): 60
   * 
   * @param {LONG} startTime  -  Start Time
   * @param {LONG} endTime  -  End Time (The start time and end time interval cannot exceed half a year)
   * @param {INT} page  -  Page
   * @param {INT} limit  -  Limit (Max: 500)
   * @param {string} transfers  -  Transfer Direction (FROM/TO)
   * @param {string} transferFunctionAccountType  -  Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryManagedSubAccountTransferLogForTradingTeamSubAccount(startTime :LONG, endTime :LONG, page :INT, limit :INT, transfers? :string, transferFunctionAccountType? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryManagedSubAccountTransferLogForTradingTeamSubAccount"]>;
  
  
  /** Query Managed Sub Account Transfer Log (For Trading Team Sub Account)(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-managed-sub-account-transfer-log-for-trading-team-sub-account-user_data}
   * 
   * Query Managed Sub Account Transfer Log (For Trading Team Sub Account)
   * 
   * EndPoint: /sapi/v1/managed-subaccount/query-trans-log
   * 
   * Weight(UID): 60
   * 
   * @param {LONG} options.startTime  -  Start Time
   * @param {LONG} options.endTime  -  End Time (The start time and end time interval cannot exceed half a year)
   * @param {INT} options.page  -  Page
   * @param {INT} options.limit  -  Limit (Max: 500)
   * @param {string} options.transfers  -  Transfer Direction (FROM/TO)
   * @param {string} options.transferFunctionAccountType  -  Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryManagedSubAccountTransferLogForTradingTeamSubAccount(options : { startTime :LONG, endTime :LONG, page :INT, limit :INT, transfers? :string, transferFunctionAccountType? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     managerSubTransferHistoryVos: {
         fromEmail: string,  // example: "test_0_virtual@kq3kno9imanagedsub.com"
         fromAccountType: string,  // example: "SPOT"
         toEmail: string,  // example: "wdywl0lddakh@test.com"
         toAccountType: string,  // example: "SPOT"
         asset: string,  // example: "BNB"
         amount: NumberString,  // example: "0.01"
         scheduledData: number,  // example: 1679416673000
         createTime: number,  // example: 1679416673000
         status: string,  // example: "SUCCESS"
         tranId: number  // example: 91077779
       }[],
     count: number  // example: 2
    }>;
  
  
  queryManagedSubAccountTransferLogForTradingTeamSubAccount(...args : any) {
      return this._sendRequest("/sapi/v1/managed-subaccount/query-trans-log", "GET", "USER_DATA", false, args, ["startTime", "endTime", "page", "limit", "transfers", "transferFunctionAccountType", "recvWindow", "timestamp"], "queryManagedSubAccountTransferLogForTradingTeamSubAccount");
  }
  
  
  
  //***** Market Data Endpoints *****
  
  
  /** Test Connectivity
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#test-connectivity}
   * 
   * Test connectivity to the Rest API.
   * 
   * EndPoint: /api/v3/ping
   * 
   * Weight(IP): 1
   * 
   */
  testConnectivity() : Promise<{
    }> {
      return this._sendRequest("/api/v3/ping", "GET", "MARKET_DATA", false, [], [], "testConnectivity");
  }
  
  
  /** Check Server Time
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#check-server-time}
   * 
   * Test connectivity to the Rest API and get the current server time.
   * 
   * EndPoint: /api/v3/time
   * 
   * Weight(IP): 1
   * 
   */
  checkServerTime() : Promise<{
     serverTime: number  // example: 1499827319559
    }> {
      return this._sendRequest("/api/v3/time", "GET", "MARKET_DATA", false, [], [], "checkServerTime");
  }
  
  
  /** Exchange Information
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#exchange-information}
   * 
   * Current exchange trading rules and symbol information
   * 
   * EndPoint: /api/v3/exchangeInfo
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol
   * @param {string[]} symbols
   * @param {Permission[]} permissions
   */
  exchangeInformation(symbol? :string, symbols? :readonly string[], permissions? :readonly Permission[])
  : ReturnType<MyBinanceClient["exchangeInformation"]>;
  
  
  /** Exchange Information
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#exchange-information}
   * 
   * Current exchange trading rules and symbol information
   * 
   * EndPoint: /api/v3/exchangeInfo
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol
   * @param {string[]} options.symbols
   * @param {Permission[]} options.permissions
   */
  exchangeInformation(options? : { symbol? :string, symbols? :readonly string[], permissions? :readonly Permission[] })
  : Promise<{
     timezone: string,  // example: "UTC"
     serverTime: number,  // example: 1565246363776
     rateLimits: {
       }[],
     exchangeFilters: unknown[],
     symbols: {
         symbol: string,  // example: "ETHBTC"
         status: string,  // example: "TRADING"
         baseAsset: string,  // example: "ETH"
         baseAssetPrecision: number,  // example: 8
         quoteAsset: string,  // example: "BTC"
         quotePrecision: number,  // example: 8
         quoteAssetPrecision: number,  // example: 8
         orderTypes: OrderType[]  // example: "LIMIT",
         icebergAllowed: boolean,  // example: true
         ocoAllowed: boolean,  // example: true
         quoteOrderQtyMarketAllowed: boolean,  // example: true
         allowTrailingStop: boolean,  // example: false
         cancelReplaceAllowed: boolean,  // example: false
         isSpotTradingAllowed: boolean,  // example: true
         isMarginTradingAllowed: boolean,  // example: true
         filters: unknown[],
         permissions: Permission[]  // example: undefined,
         permissionSets: string[]  // example: "SPOT"[],
         defaultSelfTradePreventionMode: string,  // example: "NONE"
         allowedSelfTradePreventionModes: string[]  // example: "NONE"
       }[]
    }>;
  
  
  exchangeInformation(...args : any) {
      return this._sendRequest("/api/v3/exchangeInfo", "GET", "MARKET_DATA", false, args, ["symbol", "symbols", "permissions"], "exchangeInformation");
  }
  
  
  /** Order Book
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#order-book}
   * 
   * Adjusted based on the limit:
   * 
   * EndPoint: /api/v3/depth
   * 
   * Weight(IP): Adjusted based on the limit:
   *   Limit     Weight
   *   1-100     5     
   *   101-500   25    
   *   501-1000  50    
   *   1001-5000 250   
   * 
   * @param {string} symbol
   * @param {INT} limit  -  Default 100; max 5000.  If limit > 5000, then the response will truncate to 5000.
   */
  orderBook(symbol :string, limit? :INT)  : ReturnType<MyBinanceClient["orderBook"]>;
  
  
  /** Order Book
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#order-book}
   * 
   * Adjusted based on the limit:
   * 
   * EndPoint: /api/v3/depth
   * 
   * Weight(IP): Adjusted based on the limit:
   *   Limit     Weight
   *   1-100     5     
   *   101-500   25    
   *   501-1000  50    
   *   1001-5000 250   
   * 
   * @param {string} options.symbol
   * @param {INT} options.limit  -  Default 100; max 5000.  If limit > 5000, then the response will truncate to 5000.
   */
  orderBook(options : { symbol :string, limit? :INT })
  : Promise<{
     lastUpdateId: number,  // example: 1027024
     bids: NumberString[]  // example: "4.00000000"  // PRICE[],
     asks: NumberString[]  // example: "4.00000200"[]
    }>;
  
  
  orderBook(...args : any) {
      return this._sendRequest("/api/v3/depth", "GET", "MARKET_DATA", false, args, ["symbol", "limit"], "orderBook");
  }
  
  
  /** Recent Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#recent-trades-list}
   * 
   * Get recent trades.
   * 
   * EndPoint: /api/v3/trades
   * 
   * Weight(IP): 25
   * 
   * @param {string} symbol
   * @param {INT} limit  -  Default 500; max 1000.
   */
  recentTradesList(symbol :string, limit? :INT)  : ReturnType<MyBinanceClient["recentTradesList"]>;
  
  
  /** Recent Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#recent-trades-list}
   * 
   * Get recent trades.
   * 
   * EndPoint: /api/v3/trades
   * 
   * Weight(IP): 25
   * 
   * @param {string} options.symbol
   * @param {INT} options.limit  -  Default 500; max 1000.
   */
  recentTradesList(options : { symbol :string, limit? :INT })
  : Promise<{
       id: number,  // example: 28457
       price: NumberString,  // example: "4.00000100"
       qty: NumberString,  // example: "12.00000000"
       quoteQty: NumberString,  // example: "48.000012"
       time: number,  // example: 1499865549590
       isBuyerMaker: boolean,  // example: true
       isBestMatch: boolean  // example: true
     }[]>;
  
  
  recentTradesList(...args : any) {
      return this._sendRequest("/api/v3/trades", "GET", "MARKET_DATA", false, args, ["symbol", "limit"], "recentTradesList");
  }
  
  
  /** Old Trade Lookup
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#old-trade-lookup}
   * 
   * Get older market trades.
   * 
   * EndPoint: /api/v3/historicalTrades
   * 
   * Weight(IP): 25
   * 
   * @param {string} symbol
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} fromId  -  Trade id to fetch from. Default gets most recent trades.
   */
  oldTradeLookup(symbol :string, limit? :INT, fromId? :LONG)  : ReturnType<MyBinanceClient["oldTradeLookup"]>;
  
  
  /** Old Trade Lookup
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#old-trade-lookup}
   * 
   * Get older market trades.
   * 
   * EndPoint: /api/v3/historicalTrades
   * 
   * Weight(IP): 25
   * 
   * @param {string} options.symbol
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.fromId  -  Trade id to fetch from. Default gets most recent trades.
   */
  oldTradeLookup(options : { symbol :string, limit? :INT, fromId? :LONG })
  : Promise<{
       id: number,  // example: 28457
       price: NumberString,  // example: "4.00000100"
       qty: NumberString,  // example: "12.00000000"
       quoteQty: NumberString,  // example: "48.000012"
       time: number,  // example: 1499865549590  // Trade executed timestamp, as same as `T` in the stream
       isBuyerMaker: boolean,  // example: true
       isBestMatch: boolean  // example: true
     }[]>;
  
  
  oldTradeLookup(...args : any) {
      return this._sendRequest("/api/v3/historicalTrades", "GET", "MARKET_DATA", false, args, ["symbol", "limit", "fromId"], "oldTradeLookup");
  }
  
  
  /** Compressed/Aggregate Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#compressed-aggregate-trades-list}
   * 
   * Get compressed, aggregate trades. Trades that fill at the time, from the same
   * order, with the same price will have the quantity aggregated.
   * 
   * EndPoint: /api/v3/aggTrades
   * 
   * Weight(IP): 2
   * 
   * @param {string} symbol
   * @param {LONG} fromId  -  id to get aggregate trades from INCLUSIVE.
   * @param {LONG} startTime  -  Timestamp in ms to get aggregate trades from INCLUSIVE.
   * @param {LONG} endTime  -  Timestamp in ms to get aggregate trades until INCLUSIVE.
   * @param {INT} limit  -  Default 500; max 1000.
   */
  compressedAggregateTradesList(symbol :string, fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["compressedAggregateTradesList"]>;
  
  
  /** Compressed/Aggregate Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#compressed-aggregate-trades-list}
   * 
   * Get compressed, aggregate trades. Trades that fill at the time, from the same
   * order, with the same price will have the quantity aggregated.
   * 
   * EndPoint: /api/v3/aggTrades
   * 
   * Weight(IP): 2
   * 
   * @param {string} options.symbol
   * @param {LONG} options.fromId  -  id to get aggregate trades from INCLUSIVE.
   * @param {LONG} options.startTime  -  Timestamp in ms to get aggregate trades from INCLUSIVE.
   * @param {LONG} options.endTime  -  Timestamp in ms to get aggregate trades until INCLUSIVE.
   * @param {INT} options.limit  -  Default 500; max 1000.
   */
  compressedAggregateTradesList(options : { symbol :string, fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<{
       a: number,  // example: 26129  // Aggregate tradeId
       p: NumberString,  // example: "0.01633102"  // Price
       q: NumberString,  // example: "4.70443515"  // Quantity
       f: number,  // example: 27781  // First tradeId
       l: number,  // example: 27781  // Last tradeId
       T: number,  // example: 1498793709153  // Timestamp
       m: boolean,  // example: true  // Was the buyer the maker?
       M: boolean  // example: true  // Was the trade the best price match?
     }[]>;
  
  
  compressedAggregateTradesList(...args : any) {
      return this._sendRequest("/api/v3/aggTrades", "GET", "MARKET_DATA", false, args, ["symbol", "fromId", "startTime", "endTime", "limit"], "compressedAggregateTradesList");
  }
  
  
  /** Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#kline-candlestick-data}
   * 
   * EndPoint: /api/v3/klines
   * 
   * Weight(IP): 2
   * 
   * @param {string} symbol
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {string} timeZone  -  Default: 0 (UTC)
   * @param {INT} limit  -  Default 500; max 1000.
   */
  klineCandlestickData(symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, timeZone? :string, limit? :INT)
  : ReturnType<MyBinanceClient["klineCandlestickData"]>;
  
  
  /** Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#kline-candlestick-data}
   * 
   * EndPoint: /api/v3/klines
   * 
   * Weight(IP): 2
   * 
   * @param {string} options.symbol
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {string} options.timeZone  -  Default: 0 (UTC)
   * @param {INT} options.limit  -  Default 500; max 1000.
   */
  klineCandlestickData(options : { symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, timeZone? :string, limit? :INT })
  : Promise<[
       number,        // example: 1499040000000  // Kline open time
       NumberString,  // example: "0.01634790"  // Open price
       NumberString,  // example: "0.80000000"  // High price
       NumberString,  // example: "0.01575800"  // Low price
       NumberString,  // example: "0.01577100"  // Close price
       NumberString,  // example: "148976.11427815"  // Volume
       number,        // example: 1499644799999  // Kline Close time
       NumberString,  // example: "2434.19055334"  // Quote asset volume
       number,        // example: 308  // Number of trades
       NumberString,  // example: "1756.87402397"  // Taker buy base asset volume
       NumberString,  // example: "28.46694368"  // Taker buy quote asset volume
       NumberString   // example: "0"  // Unused field, ignore.
     ][]>;
  
  
  klineCandlestickData(...args : any) {
      return this._sendRequest("/api/v3/klines", "GET", "MARKET_DATA", false, args, ["symbol", "interval", "startTime", "endTime", "timeZone", "limit"], "klineCandlestickData");
  }
  
  
  /** UIKlines
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#uiklines}
   * 
   * The request is similar to klines having the same parameters and response.
   * 
   * EndPoint: /api/v3/uiKlines
   * 
   * Weight(IP): 2
   * 
   * @param {string} symbol
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {string} timeZone  -  Default: 0 (UTC)
   * @param {INT} limit  -  Default 500; max 1000.
   */
  uiKlines(symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, timeZone? :string, limit? :INT)
  : ReturnType<MyBinanceClient["uiKlines"]>;
  
  
  /** UIKlines
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#uiklines}
   * 
   * The request is similar to klines having the same parameters and response.
   * 
   * EndPoint: /api/v3/uiKlines
   * 
   * Weight(IP): 2
   * 
   * @param {string} options.symbol
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {string} options.timeZone  -  Default: 0 (UTC)
   * @param {INT} options.limit  -  Default 500; max 1000.
   */
  uiKlines(options : { symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, timeZone? :string, limit? :INT })
  : Promise<[
       number,        // example: 1499040000000  // Kline open time
       NumberString,  // example: "0.01634790"  // Open price
       NumberString,  // example: "0.80000000"  // High price
       NumberString,  // example: "0.01575800"  // Low price
       NumberString,  // example: "0.01577100"  // Close price
       NumberString,  // example: "148976.11427815"  // Volume
       number,        // example: 1499644799999  // Kline close time
       NumberString,  // example: "2434.19055334"  // Quote asset volume
       number,        // example: 308  // Number of trades
       NumberString,  // example: "1756.87402397"  // Taker buy base asset volume
       NumberString,  // example: "28.46694368"  // Taker buy quote asset volume
       NumberString   // example: "0"  // Unused field. Ignore.
     ][]>;
  
  
  uiKlines(...args : any) {
      return this._sendRequest("/api/v3/uiKlines", "GET", "MARKET_DATA", false, args, ["symbol", "interval", "startTime", "endTime", "timeZone", "limit"], "uiKlines");
  }
  
  
  /** Current Average Price
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#current-average-price}
   * 
   * Current average price for a symbol.
   * 
   * EndPoint: /api/v3/avgPrice
   * 
   * Weight(IP): 2
   * 
   * @param {string} symbol
   */
  currentAveragePrice(symbol :string)  : ReturnType<MyBinanceClient["currentAveragePrice"]>;
  
  
  /** Current Average Price
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#current-average-price}
   * 
   * Current average price for a symbol.
   * 
   * EndPoint: /api/v3/avgPrice
   * 
   * Weight(IP): 2
   * 
   * @param {string} options.symbol
   */
  currentAveragePrice(options : { symbol :string })
  : Promise<{
     mins: number,  // example: 5  // Average price interval (in minutes)
     price: NumberString,  // example: "9.35751834"  // Average price
     closeTime: number  // example: 1694061154503  // Last trade time
    }>;
  
  
  currentAveragePrice(...args : any) {
      return this._sendRequest("/api/v3/avgPrice", "GET", "MARKET_DATA", false, args, ["symbol"], "currentAveragePrice");
  }
  
  
  /** 24hr Ticker Price Change Statistics (single symbol)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#24hr-ticker-price-change-statistics}
   * 
   * EndPoint: /api/v3/ticker/24hr
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided             Weight
   *   symbol    1                            2     
   *   symbol    symbol parameter is omitted  80    
   *   symbols   1-20                         2     
   *   symbols   21-100                       40    
   *   symbols   101 or more                  80    
   *   symbols   symbols parameter is omitted 80    
   * 
   * @param {string} symbol  -  Parameter symbol and symbols cannot be used in combination.  If neither parameter is sent, tickers for all symbols will be returned in an array. 
   *          
   * @param {"FULL"} type  -  Supported values: FULL or MINI. If none provided, the default is FULL
   */
  tickerPriceChangeStatistics24hr(symbol :string, type? :"FULL")
  : ReturnType<MyBinanceClient["tickerPriceChangeStatistics24hr"]>;
  
  
  /** 24hr Ticker Price Change Statistics (single symbol)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#24hr-ticker-price-change-statistics}
   * 
   * EndPoint: /api/v3/ticker/24hr
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided             Weight
   *   symbol    1                            2     
   *   symbol    symbol parameter is omitted  80    
   *   symbols   1-20                         2     
   *   symbols   21-100                       40    
   *   symbols   101 or more                  80    
   *   symbols   symbols parameter is omitted 80    
   * 
   * @param {string} options.symbol  -  Parameter symbol and symbols cannot be used in combination.  If neither parameter is sent, tickers for all symbols will be returned in an array. 
   *          
   * @param {"FULL"} options.type  -  Supported values: FULL or MINI. If none provided, the default is FULL
   */
  tickerPriceChangeStatistics24hr(options : { symbol :string, type? :"FULL" })
  : Promise<{  // - FULL
     symbol: string,  // example: "BNBBTC"
     priceChange: NumberString,  // example: "-94.99999800"
     priceChangePercent: NumberString,  // example: "-95.960"
     weightedAvgPrice: NumberString,  // example: "0.29628482"
     prevClosePrice: NumberString,  // example: "0.10002000"
     lastPrice: NumberString,  // example: "4.00000200"
     lastQty: NumberString,  // example: "200.00000000"
     bidPrice: NumberString,  // example: "4.00000000"
     bidQty: NumberString,  // example: "100.00000000"
     askPrice: NumberString,  // example: "4.00000200"
     askQty: NumberString,  // example: "100.00000000"
     openPrice: NumberString,  // example: "99.00000000"
     highPrice: NumberString,  // example: "100.00000000"
     lowPrice: NumberString,  // example: "0.10000000"
     volume: NumberString,  // example: "8913.30000000"
     quoteVolume: NumberString,  // example: "15.30000000"
     openTime: number,  // example: 1499783499040
     closeTime: number,  // example: 1499869899040
     firstId: number,  // example: 28385  // First tradeId
     lastId: number,  // example: 28460  // Last tradeId
     count: number  // example: 76  // Trade count
    }>;
  
  
  tickerPriceChangeStatistics24hr(symbol :string, type :"MINI")
  : ReturnType<MyBinanceClient["tickerPriceChangeStatistics24hr"]>;
  
  
  tickerPriceChangeStatistics24hr(options : { symbol :string, type :"MINI" })
  : Promise<{  // - MINI
     symbol: string,  // example: "BNBBTC"  // Symbol Name
     openPrice: NumberString,  // example: "99.00000000"  // Opening price of the Interval
     highPrice: NumberString,  // example: "100.00000000"  // Highest price in the interval
     lowPrice: NumberString,  // example: "0.10000000"  // Lowest  price in the interval
     lastPrice: NumberString,  // example: "4.00000200"  // Closing price of the interval
     volume: NumberString,  // example: "8913.30000000"  // Total trade volume (in base asset)
     quoteVolume: NumberString,  // example: "15.30000000"  // Total trade volume (in quote asset)
     openTime: number,  // example: 1499783499040  // Start of the ticker interval
     closeTime: number,  // example: 1499869899040  // End of the ticker interval
     firstId: number,  // example: 28385  // First tradeId considered
     lastId: number,  // example: 28460  // Last tradeId considered
     count: number  // example: 76  // Total trade count
    }>;
  
  
  /** 24hr Ticker Price Change Statistics (multi symbols)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#24hr-ticker-price-change-statistics}
   * 
   * EndPoint: /api/v3/ticker/24hr
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided             Weight
   *   symbol    1                            2     
   *   symbol    symbol parameter is omitted  80    
   *   symbols   1-20                         2     
   *   symbols   21-100                       40    
   *   symbols   101 or more                  80    
   *   symbols   symbols parameter is omitted 80    
   * 
   * @param {string[]} symbols  -  Examples of accepted format for the symbols parameter:
   *          ["BTCUSDT","BNBUSDT"] 
   *          or 
   *          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
   * @param {"FULL"} type  -  Supported values: FULL or MINI. If none provided, the default is FULL
   */
  tickerPriceChangeStatistics24hr(symbols? :readonly string[], type? :"FULL")
  : ReturnType<MyBinanceClient["tickerPriceChangeStatistics24hr"]>;
  
  
  /** 24hr Ticker Price Change Statistics (multi symbols)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#24hr-ticker-price-change-statistics}
   * 
   * EndPoint: /api/v3/ticker/24hr
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided             Weight
   *   symbol    1                            2     
   *   symbol    symbol parameter is omitted  80    
   *   symbols   1-20                         2     
   *   symbols   21-100                       40    
   *   symbols   101 or more                  80    
   *   symbols   symbols parameter is omitted 80    
   * 
   * @param {string[]} options.symbols  -  Examples of accepted format for the symbols parameter:
   *          ["BTCUSDT","BNBUSDT"] 
   *          or 
   *          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
   * @param {"FULL"} options.type  -  Supported values: FULL or MINI. If none provided, the default is FULL
   */
  tickerPriceChangeStatistics24hr(options? : { symbols? :readonly string[], type? :"FULL" })
  : Promise<{
       symbol: string,  // example: "BNBBTC"
       priceChange: NumberString,  // example: "-94.99999800"
       priceChangePercent: NumberString,  // example: "-95.960"
       weightedAvgPrice: NumberString,  // example: "0.29628482"
       prevClosePrice: NumberString,  // example: "0.10002000"
       lastPrice: NumberString,  // example: "4.00000200"
       lastQty: NumberString,  // example: "200.00000000"
       bidPrice: NumberString,  // example: "4.00000000"
       bidQty: NumberString,  // example: "100.00000000"
       askPrice: NumberString,  // example: "4.00000200"
       askQty: NumberString,  // example: "100.00000000"
       openPrice: NumberString,  // example: "99.00000000"
       highPrice: NumberString,  // example: "100.00000000"
       lowPrice: NumberString,  // example: "0.10000000"
       volume: NumberString,  // example: "8913.30000000"
       quoteVolume: NumberString,  // example: "15.30000000"
       openTime: number,  // example: 1499783499040
       closeTime: number,  // example: 1499869899040
       firstId: number,  // example: 28385  // First tradeId
       lastId: number,  // example: 28460  // Last tradeId
       count: number  // example: 76  // Trade count
     }[]>;
  
  
  tickerPriceChangeStatistics24hr(symbols :readonly string[]|undefined, type :"MINI")
  : ReturnType<MyBinanceClient["tickerPriceChangeStatistics24hr"]>;
  
  
  tickerPriceChangeStatistics24hr(options : { symbols? :readonly string[], type :"MINI" })
  : Promise<{
       symbol: string,  // example: "BNBBTC"
       openPrice: NumberString,  // example: "99.00000000"
       highPrice: NumberString,  // example: "100.00000000"
       lowPrice: NumberString,  // example: "0.10000000"
       lastPrice: NumberString,  // example: "4.00000200"
       volume: NumberString,  // example: "8913.30000000"
       quoteVolume: NumberString,  // example: "15.30000000"
       openTime: number,  // example: 1499783499040
       closeTime: number,  // example: 1499869899040
       firstId: number,  // example: 28385
       lastId: number,  // example: 28460
       count: number  // example: 76
     }[]>;
  
  
  tickerPriceChangeStatistics24hr(...args : any) {
      return this._sendRequest("/api/v3/ticker/24hr", "GET", "MARKET_DATA", false, args, [{symbol:'string',type:null}, {symbol:'string',type:'string'}, {symbols:null,type:null}, {symbols:null,type:'string'}], "tickerPriceChangeStatistics24hr");
  }
  
  
  /** Trading Day Ticker (single symbol)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#trading-day-ticker}
   * 
   * Price change statistics for a trading day.
   * 
   * EndPoint: /api/v3/ticker/tradingDay
   * 
   * Weight(IP): 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
   * 
   * @param {string} symbol  -  Either symbol or symbols must be provided.
   *     
   * @param {string} timeZone  -  Default: 0 (UTC)
   * @param {"FULL"} type  -  Supported values: FULL or MINI.
   *     If none provided, the default is FULL.
   */
  tradingDayTicker(symbol :string, timeZone? :string, type? :"FULL")  : ReturnType<MyBinanceClient["tradingDayTicker"]>;
  
  
  /** Trading Day Ticker (single symbol)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#trading-day-ticker}
   * 
   * Price change statistics for a trading day.
   * 
   * EndPoint: /api/v3/ticker/tradingDay
   * 
   * Weight(IP): 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
   * 
   * @param {string} options.symbol  -  Either symbol or symbols must be provided.
   *     
   * @param {string} options.timeZone  -  Default: 0 (UTC)
   * @param {"FULL"} options.type  -  Supported values: FULL or MINI.
   *     If none provided, the default is FULL.
   */
  tradingDayTicker(options : { symbol :string, timeZone? :string, type? :"FULL" })
  : Promise<{  // - FULL
     symbol: string,  // example: "BTCUSDT"
     priceChange: NumberString,  // example: "-83.13000000"  // Absolute price change
     priceChangePercent: NumberString,  // example: "-0.317"  // Relative price change in percent
     weightedAvgPrice: NumberString,  // example: "26234.58803036"  // quoteVolume / volume
     openPrice: NumberString,  // example: "26304.80000000"
     highPrice: NumberString,  // example: "26397.46000000"
     lowPrice: NumberString,  // example: "26088.34000000"
     lastPrice: NumberString,  // example: "26221.67000000"
     volume: NumberString,  // example: "18495.35066000"  // Volume in base asset
     quoteVolume: NumberString,  // example: "485217905.04210480"  // Volume in quote asset
     openTime: number,  // example: 1695686400000
     closeTime: number,  // example: 1695772799999
     firstId: number,  // example: 3220151555  // Trade ID of the first trade in the interval
     lastId: number,  // example: 3220849281  // Trade ID of the last trade in the interval
     count: number  // example: 697727  // Number of trades in the interval
    }>;
  
  
  tradingDayTicker(symbol :string, timeZone :string|undefined, type :"MINI")
  : ReturnType<MyBinanceClient["tradingDayTicker"]>;
  
  
  tradingDayTicker(options : { symbol :string, timeZone? :string, type :"MINI" })
  : Promise<{  // - MINI
     symbol: string,  // example: "BTCUSDT"
     openPrice: NumberString,  // example: "26304.80000000"
     highPrice: NumberString,  // example: "26397.46000000"
     lowPrice: NumberString,  // example: "26088.34000000"
     lastPrice: NumberString,  // example: "26221.67000000"
     volume: NumberString,  // example: "18495.35066000"  // Volume in base asset
     quoteVolume: NumberString,  // example: "485217905.04210480"  // Volume in quote asset
     openTime: number,  // example: 1695686400000
     closeTime: number,  // example: 1695772799999
     firstId: number,  // example: 3220151555  // Trade ID of the first trade in the interval
     lastId: number,  // example: 3220849281  // Trade ID of the last trade in the interval
     count: number  // example: 697727  // Number of trades in the interval
    }>;
  
  
  /** Trading Day Ticker (multi symbols)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#trading-day-ticker}
   * 
   * Price change statistics for a trading day.
   * 
   * EndPoint: /api/v3/ticker/tradingDay
   * 
   * Weight(IP): 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
   * 
   * @param {string[]} symbols  -  Examples of accepted format for the symbols parameter:  ["BTCUSDT","BNBUSDT"] 
   *     or
   *     %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
   *     The maximum number of symbols allowed in a request is 100.
   * @param {string} timeZone  -  Default: 0 (UTC)
   * @param {"FULL"} type  -  Supported values: FULL or MINI.
   *     If none provided, the default is FULL.
   */
  tradingDayTicker(symbols :readonly string[], timeZone? :string, type? :"FULL")
  : ReturnType<MyBinanceClient["tradingDayTicker"]>;
  
  
  /** Trading Day Ticker (multi symbols)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#trading-day-ticker}
   * 
   * Price change statistics for a trading day.
   * 
   * EndPoint: /api/v3/ticker/tradingDay
   * 
   * Weight(IP): 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
   * 
   * @param {string[]} options.symbols  -  Examples of accepted format for the symbols parameter:  ["BTCUSDT","BNBUSDT"] 
   *     or
   *     %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
   *     The maximum number of symbols allowed in a request is 100.
   * @param {string} options.timeZone  -  Default: 0 (UTC)
   * @param {"FULL"} options.type  -  Supported values: FULL or MINI.
   *     If none provided, the default is FULL.
   */
  tradingDayTicker(options : { symbols :readonly string[], timeZone? :string, type? :"FULL" })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       priceChange: NumberString,  // example: "-83.13000000"
       priceChangePercent: NumberString,  // example: "-0.317"
       weightedAvgPrice: NumberString,  // example: "26234.58803036"
       openPrice: NumberString,  // example: "26304.80000000"
       highPrice: NumberString,  // example: "26397.46000000"
       lowPrice: NumberString,  // example: "26088.34000000"
       lastPrice: NumberString,  // example: "26221.67000000"
       volume: NumberString,  // example: "18495.35066000"
       quoteVolume: NumberString,  // example: "485217905.04210480"
       openTime: number,  // example: 1695686400000
       closeTime: number,  // example: 1695772799999
       firstId: number,  // example: 3220151555
       lastId: number,  // example: 3220849281
       count: number  // example: 697727
     }[]>;
  
  
  tradingDayTicker(symbols :readonly string[], timeZone :string|undefined, type :"MINI")
  : ReturnType<MyBinanceClient["tradingDayTicker"]>;
  
  
  tradingDayTicker(options : { symbols :readonly string[], timeZone? :string, type :"MINI" })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       openPrice: NumberString,  // example: "26304.80000000"
       highPrice: NumberString,  // example: "26397.46000000"
       lowPrice: NumberString,  // example: "26088.34000000"
       lastPrice: NumberString,  // example: "26221.67000000"
       volume: NumberString,  // example: "18495.35066000"
       quoteVolume: NumberString,  // example: "485217905.04210480"
       openTime: number,  // example: 1695686400000
       closeTime: number,  // example: 1695772799999
       firstId: number,  // example: 3220151555
       lastId: number,  // example: 3220849281
       count: number  // example: 697727
     }[]>;
  
  
  tradingDayTicker(...args : any) {
      return this._sendRequest("/api/v3/ticker/tradingDay", "GET", "MARKET_DATA", false, args, [{symbol:'string',timeZone:null,type:null}, {symbol:'string',timeZone:null,type:'string'}, {symbols:'[]',timeZone:null,type:null}, {symbols:'[]',timeZone:null,type:'string'}], "tradingDayTicker");
  }
  
  
  /** Symbol Price Ticker (single symbol)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#symbol-price-ticker}
   * 
   * Latest price for a symbol or symbols.
   * 
   * EndPoint: /api/v3/ticker/price
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided            Weight
   *   symbol    1                           2     
   *   symbol    symbol parameter is omitted 4     
   * 
   * @param {string} symbol  -   Parameter symbol and symbols cannot be used in combination.  If neither parameter is sent, prices for all symbols will be returned in an array.   
   */
  symbolPriceTicker(symbol :string)  : ReturnType<MyBinanceClient["symbolPriceTicker"]>;
  
  
  /** Symbol Price Ticker (single symbol)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#symbol-price-ticker}
   * 
   * Latest price for a symbol or symbols.
   * 
   * EndPoint: /api/v3/ticker/price
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided            Weight
   *   symbol    1                           2     
   *   symbol    symbol parameter is omitted 4     
   * 
   * @param {string} options.symbol  -   Parameter symbol and symbols cannot be used in combination.  If neither parameter is sent, prices for all symbols will be returned in an array.   
   */
  symbolPriceTicker(options : { symbol :string })
  : Promise<{
     symbol: string,  // example: "LTCBTC"
     price: NumberString  // example: "4.00000200"
    }>;
  
  
  /** Symbol Price Ticker (multi symbols)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#symbol-price-ticker}
   * 
   * Latest price for a symbol or symbols.
   * 
   * EndPoint: /api/v3/ticker/price
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided            Weight
   *   symbols   Any                         4     
   * 
   * @param {string[]} symbols  -  Examples of accepted format for the symbols parameter:
   *          ["BTCUSDT","BNBUSDT"] 
   *          or 
   *          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
   */
  symbolPriceTicker(symbols? :readonly string[])  : ReturnType<MyBinanceClient["symbolPriceTicker"]>;
  
  
  /** Symbol Price Ticker (multi symbols)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#symbol-price-ticker}
   * 
   * Latest price for a symbol or symbols.
   * 
   * EndPoint: /api/v3/ticker/price
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided            Weight
   *   symbols   Any                         4     
   * 
   * @param {string[]} options.symbols  -  Examples of accepted format for the symbols parameter:
   *          ["BTCUSDT","BNBUSDT"] 
   *          or 
   *          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
   */
  symbolPriceTicker(options? : { symbols? :readonly string[] })
  : Promise<{
       symbol: string,  // example: "LTCBTC"
       price: NumberString  // example: "4.00000200"
     }[]>;
  
  
  symbolPriceTicker(...args : any) {
      return this._sendRequest("/api/v3/ticker/price", "GET", "MARKET_DATA", false, args, [{symbol:'string'}, {symbols:null}], "symbolPriceTicker");
  }
  
  
  /** Symbol Order Book Ticker (single symbol)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#symbol-order-book-ticker}
   * 
   * Best price/qty on the order book for a symbol or symbols.
   * 
   * EndPoint: /api/v3/ticker/bookTicker
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided            Weight
   *   symbol    1                           2     
   *   symbol    symbol parameter is omitted 4     
   * 
   * @param {string} symbol  -   Parameter symbol and symbols cannot be used in combination.  If neither parameter is sent, bookTickers for all symbols will be returned in an array.   
   */
  symbolOrderBookTicker(symbol :string)  : ReturnType<MyBinanceClient["symbolOrderBookTicker"]>;
  
  
  /** Symbol Order Book Ticker (single symbol)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#symbol-order-book-ticker}
   * 
   * Best price/qty on the order book for a symbol or symbols.
   * 
   * EndPoint: /api/v3/ticker/bookTicker
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided            Weight
   *   symbol    1                           2     
   *   symbol    symbol parameter is omitted 4     
   * 
   * @param {string} options.symbol  -   Parameter symbol and symbols cannot be used in combination.  If neither parameter is sent, bookTickers for all symbols will be returned in an array.   
   */
  symbolOrderBookTicker(options : { symbol :string })
  : Promise<{
     symbol: string,  // example: "LTCBTC"
     bidPrice: NumberString,  // example: "4.00000000"
     bidQty: NumberString,  // example: "431.00000000"
     askPrice: NumberString,  // example: "4.00000200"
     askQty: NumberString  // example: "9.00000000"
    }>;
  
  
  /** Symbol Order Book Ticker (multi symbols)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#symbol-order-book-ticker}
   * 
   * Best price/qty on the order book for a symbol or symbols.
   * 
   * EndPoint: /api/v3/ticker/bookTicker
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided            Weight
   *   symbols   Any                         4     
   * 
   * @param {string[]} symbols  -  Examples of accepted format for the symbols parameter:
   *          ["BTCUSDT","BNBUSDT"] 
   *          or 
   *          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
   */
  symbolOrderBookTicker(symbols? :readonly string[])  : ReturnType<MyBinanceClient["symbolOrderBookTicker"]>;
  
  
  /** Symbol Order Book Ticker (multi symbols)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#symbol-order-book-ticker}
   * 
   * Best price/qty on the order book for a symbol or symbols.
   * 
   * EndPoint: /api/v3/ticker/bookTicker
   * 
   * Weight(IP): Adjusted based on the number of symbols:
   *   Parameter Symbols Provided            Weight
   *   symbols   Any                         4     
   * 
   * @param {string[]} options.symbols  -  Examples of accepted format for the symbols parameter:
   *          ["BTCUSDT","BNBUSDT"] 
   *          or 
   *          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
   */
  symbolOrderBookTicker(options? : { symbols? :readonly string[] })
  : Promise<{
       symbol: string,  // example: "LTCBTC"
       bidPrice: NumberString,  // example: "4.00000000"
       bidQty: NumberString,  // example: "431.00000000"
       askPrice: NumberString,  // example: "4.00000200"
       askQty: NumberString  // example: "9.00000000"
     }[]>;
  
  
  symbolOrderBookTicker(...args : any) {
      return this._sendRequest("/api/v3/ticker/bookTicker", "GET", "MARKET_DATA", false, args, [{symbol:'string'}, {symbols:null}], "symbolOrderBookTicker");
  }
  
  
  /** Rolling window price change statistics (single symbol)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#rolling-window-price-change-statistics}
   * 
   * EndPoint: /api/v3/ticker
   * 
   * Weight(IP): 4 for each requested symbol regardless of windowSize  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
   * 
   * @param {string} symbol  -  Either symbol or symbols must be provided.
   *     
   * @param {ENUM} windowSize  -  Defaults to 1d if no parameter provided. Supported windowSize values:
   *     1m,2m....59m for minutes
   *     1h, 2h....23h - for hours 
   *     1d...7d - for days 
   *     Units cannot be combined (e.g. 1d2h is not allowed).
   * @param {"FULL"} type  -  Supported values: FULL or MINI.
   *     If none provided, the default is FULL.
   */
  rollingWindowPriceChangeStatistics(symbol :string, windowSize? :ENUM, type? :"FULL")
  : ReturnType<MyBinanceClient["rollingWindowPriceChangeStatistics"]>;
  
  
  /** Rolling window price change statistics (single symbol)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#rolling-window-price-change-statistics}
   * 
   * EndPoint: /api/v3/ticker
   * 
   * Weight(IP): 4 for each requested symbol regardless of windowSize  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
   * 
   * @param {string} options.symbol  -  Either symbol or symbols must be provided.
   *     
   * @param {ENUM} options.windowSize  -  Defaults to 1d if no parameter provided. Supported windowSize values:
   *     1m,2m....59m for minutes
   *     1h, 2h....23h - for hours 
   *     1d...7d - for days 
   *     Units cannot be combined (e.g. 1d2h is not allowed).
   * @param {"FULL"} options.type  -  Supported values: FULL or MINI.
   *     If none provided, the default is FULL.
   */
  rollingWindowPriceChangeStatistics(options : { symbol :string, windowSize? :ENUM, type? :"FULL" })
  : Promise<{  // - FULL
     symbol: string,  // example: "BNBBTC"
     priceChange: NumberString,  // example: "-8.00000000"  // Absolute price change
     priceChangePercent: NumberString,  // example: "-88.889"  // Relative price change in percent
     weightedAvgPrice: NumberString,  // example: "2.60427807"  // QuoteVolume / Volume
     openPrice: NumberString,  // example: "9.00000000"
     highPrice: NumberString,  // example: "9.00000000"
     lowPrice: NumberString,  // example: "1.00000000"
     lastPrice: NumberString,  // example: "1.00000000"
     volume: NumberString,  // example: "187.00000000"
     quoteVolume: NumberString,  // example: "487.00000000"  // Sum of (price * volume) for all trades
     openTime: number,  // example: 1641859200000  // Open time for ticker window
     closeTime: number,  // example: 1642031999999  // Current Time of the Request
     firstId: number,  // example: 0  // Trade IDs
     lastId: number,  // example: 60
     count: number  // example: 61  // Number of trades in the interval
    }>;
  
  
  rollingWindowPriceChangeStatistics(symbol :string, windowSize :ENUM|undefined, type :"MINI")
  : ReturnType<MyBinanceClient["rollingWindowPriceChangeStatistics"]>;
  
  
  rollingWindowPriceChangeStatistics(options : { symbol :string, windowSize? :ENUM, type :"MINI" })
  : Promise<{  // - MINI
     symbol: string,  // example: "LTCBTC"
     openPrice: NumberString,  // example: "0.10000000"
     highPrice: NumberString,  // example: "2.00000000"
     lowPrice: NumberString,  // example: "0.10000000"
     lastPrice: NumberString,  // example: "2.00000000"
     volume: NumberString,  // example: "39.00000000"
     quoteVolume: NumberString,  // example: "13.40000000"  // Sum of (price * volume) for all trades
     openTime: number,  // example: 1656986580000  // Open time for ticker window
     closeTime: number,  // example: 1657001016795  // Close time for ticker window
     firstId: number,  // example: 0  // Trade IDs
     lastId: number,  // example: 34
     count: number  // example: 35  // Number of trades in the interval
    }>;
  
  
  /** Rolling window price change statistics (multi symbols)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#rolling-window-price-change-statistics}
   * 
   * EndPoint: /api/v3/ticker
   * 
   * Weight(IP): 4 for each requested symbol regardless of windowSize  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
   * 
   * @param {string[]} symbols  -  Examples of accepted format for the symbols parameter:  ["BTCUSDT","BNBUSDT"] 
   *     or
   *     %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
   *     The maximum number of symbols allowed in a request is 100.
   * @param {ENUM} windowSize  -  Defaults to 1d if no parameter provided. Supported windowSize values:
   *     1m,2m....59m for minutes
   *     1h, 2h....23h - for hours 
   *     1d...7d - for days 
   *     Units cannot be combined (e.g. 1d2h is not allowed).
   * @param {"FULL"} type  -  Supported values: FULL or MINI.
   *     If none provided, the default is FULL.
   */
  rollingWindowPriceChangeStatistics(symbols :readonly string[], windowSize? :ENUM, type? :"FULL")
  : ReturnType<MyBinanceClient["rollingWindowPriceChangeStatistics"]>;
  
  
  /** Rolling window price change statistics (multi symbols)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#rolling-window-price-change-statistics}
   * 
   * EndPoint: /api/v3/ticker
   * 
   * Weight(IP): 4 for each requested symbol regardless of windowSize  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
   * 
   * @param {string[]} options.symbols  -  Examples of accepted format for the symbols parameter:  ["BTCUSDT","BNBUSDT"] 
   *     or
   *     %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
   *     The maximum number of symbols allowed in a request is 100.
   * @param {ENUM} options.windowSize  -  Defaults to 1d if no parameter provided. Supported windowSize values:
   *     1m,2m....59m for minutes
   *     1h, 2h....23h - for hours 
   *     1d...7d - for days 
   *     Units cannot be combined (e.g. 1d2h is not allowed).
   * @param {"FULL"} options.type  -  Supported values: FULL or MINI.
   *     If none provided, the default is FULL.
   */
  rollingWindowPriceChangeStatistics(options : { symbols :readonly string[], windowSize? :ENUM, type? :"FULL" })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       priceChange: NumberString,  // example: "-154.13000000"  // Absolute price change
       priceChangePercent: NumberString,  // example: "-0.740"  // Relative price change in percent
       weightedAvgPrice: NumberString,  // example: "20677.46305250"  // QuoteVolume / Volume
       openPrice: NumberString,  // example: "20825.27000000"
       highPrice: NumberString,  // example: "20972.46000000"
       lowPrice: NumberString,  // example: "20327.92000000"
       lastPrice: NumberString,  // example: "20671.14000000"
       volume: NumberString,  // example: "72.65112300"
       quoteVolume: NumberString,  // example: "1502240.91155513"  // Sum of (price * volume) for all trades
       openTime: number,  // example: 1655432400000  // Open time for ticker window
       closeTime: number,  // example: 1655446835460  // Close time for ticker window
       firstId: number,  // example: 11147809  // Trade IDs
       lastId: number,  // example: 11149775
       count: number  // example: 1967  // Number of trades in the interval
     }[]>;
  
  
  rollingWindowPriceChangeStatistics(symbols :readonly string[], windowSize :ENUM|undefined, type :"MINI")
  : ReturnType<MyBinanceClient["rollingWindowPriceChangeStatistics"]>;
  
  
  rollingWindowPriceChangeStatistics(options : { symbols :readonly string[], windowSize? :ENUM, type :"MINI" })
  : Promise<{
       symbol: string,  // example: "BNBBTC"
       openPrice: NumberString,  // example: "0.10000000"
       highPrice: NumberString,  // example: "2.00000000"
       lowPrice: NumberString,  // example: "0.10000000"
       lastPrice: NumberString,  // example: "2.00000000"
       volume: NumberString,  // example: "39.00000000"
       quoteVolume: NumberString,  // example: "13.40000000"  // Sum of (price * volume) for all trades
       openTime: number,  // example: 1656986880000  // Open time for ticker window
       closeTime: number,  // example: 1657001297799  // Close time for ticker window
       firstId: number,  // example: 0  // Trade IDs
       lastId: number,  // example: 34
       count: number  // example: 35  // Number of trades in the interval
     }[]>;
  
  
  rollingWindowPriceChangeStatistics(...args : any) {
      return this._sendRequest("/api/v3/ticker", "GET", "MARKET_DATA", false, args, [{symbol:'string',windowSize:null,type:null}, {symbol:'string',windowSize:null,type:'string'}, {symbols:'[]',windowSize:null,type:null}, {symbols:'[]',windowSize:null,type:'string'}], "rollingWindowPriceChangeStatistics");
  }
  
  
  
  //***** Spot Trading Endpoints *****
  
  
  /** Test New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#test-new-order-trade}
   * 
   * Test new order creation and signature/recvWindow long.
   * Creates and validates a new order but does not send it into the matching engine.
   * 
   * EndPoint: /api/v3/order/test
   * 
   * Weight(IP): 
   *   Condition                      Request Weight
   *   Without computeCommissionRates 1             
   *   With computeCommissionRates    20            
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {OrderType} type
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity
   * @param {DECIMAL} quoteOrderQty
   * @param {DECIMAL} price
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent.
   * @param {INT} strategyId
   * @param {INT} strategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} stopPrice  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {LONG} trailingDelta  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.  For more details on SPOT implementation on trailing stops, please refer to Trailing Stop FAQ
   * @param {DECIMAL} icebergQty  -  Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {OrderResponseType} newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {"EXPIRE_TAKER"|"EXPIRE_MAKER"|"EXPIRE_BOTH"|"NONE"} selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   * @param {boolean} computeCommissionRates  -  Default: false
   */
  testNewOrder(symbol :string, side :OrderSide, type :OrderType, timeInForce? :TimeInForce, quantity? :DECIMAL, quoteOrderQty? :DECIMAL, price? :DECIMAL, newClientOrderId? :string, strategyId? :INT, strategyType? :INT, stopPrice? :DECIMAL, trailingDelta? :LONG, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :"EXPIRE_TAKER"|"EXPIRE_MAKER"|"EXPIRE_BOTH"|"NONE", recvWindow? :LONG, timestamp? :LONG, computeCommissionRates? :boolean)
  : ReturnType<MyBinanceClient["testNewOrder"]>;
  
  
  /** Test New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#test-new-order-trade}
   * 
   * Test new order creation and signature/recvWindow long.
   * Creates and validates a new order but does not send it into the matching engine.
   * 
   * EndPoint: /api/v3/order/test
   * 
   * Weight(IP): 
   *   Condition                      Request Weight
   *   Without computeCommissionRates 1             
   *   With computeCommissionRates    20            
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {OrderType} options.type
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity
   * @param {DECIMAL} options.quoteOrderQty
   * @param {DECIMAL} options.price
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent.
   * @param {INT} options.strategyId
   * @param {INT} options.strategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} options.stopPrice  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {LONG} options.trailingDelta  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.  For more details on SPOT implementation on trailing stops, please refer to Trailing Stop FAQ
   * @param {DECIMAL} options.icebergQty  -  Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {OrderResponseType} options.newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {"EXPIRE_TAKER"|"EXPIRE_MAKER"|"EXPIRE_BOTH"|"NONE"} options.selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   * @param {boolean} options.computeCommissionRates  -  Default: false
   */
  testNewOrder(options : { symbol :string, side :OrderSide, type :OrderType, timeInForce? :TimeInForce, quantity? :DECIMAL, quoteOrderQty? :DECIMAL, price? :DECIMAL, newClientOrderId? :string, strategyId? :INT, strategyType? :INT, stopPrice? :DECIMAL, trailingDelta? :LONG, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :"EXPIRE_TAKER"|"EXPIRE_MAKER"|"EXPIRE_BOTH"|"NONE", recvWindow? :LONG, timestamp? :LONG, computeCommissionRates? :boolean })
  : Promise<{
    } | {
     standardCommissionForOrder: {
       maker: NumberString,  // example: "0.00000112"
       taker: NumberString  // example: "0.00000114"
     },
     taxCommissionForOrder: {
       maker: NumberString,  // example: "0.00000112"
       taker: NumberString  // example: "0.00000114"
     },
     discount: {
       enabledForAccount: boolean,  // example: true
       enabledForSymbol: boolean,  // example: true
       discountAsset: string,  // example: "BNB"
       discount: NumberString  // example: "0.25000000"  //Standard commission is reduced by this rate when paying commission in BNB.
     }
    }>;
  
  
  testNewOrder(...args : any) {
      return this._sendRequest("/api/v3/order/test", "POST", "TRADE", false, args, ["symbol", "side", "type", "timeInForce", "quantity", "quoteOrderQty", "price", "newClientOrderId", "strategyId", "strategyType", "stopPrice", "trailingDelta", "icebergQty", "newOrderRespType", "selfTradePreventionMode", "recvWindow", "timestamp", "computeCommissionRates"], "testNewOrder");
  }
  
  
  /** New Order  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-order-trade}
   * 
   * Send in a new order.
   * 
   * EndPoint: /api/v3/order
   * 
   * Weight(IP): 1
   * Weight(UID): 1
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {OrderType} type
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity
   * @param {DECIMAL} quoteOrderQty
   * @param {DECIMAL} price
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent.
   * @param {INT} strategyId
   * @param {INT} strategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} stopPrice  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {LONG} trailingDelta  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.  For more details on SPOT implementation on trailing stops, please refer to Trailing Stop FAQ
   * @param {DECIMAL} icebergQty  -  Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {OrderResponseType} newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {"EXPIRE_TAKER"|"EXPIRE_MAKER"|"EXPIRE_BOTH"|"NONE"} selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  newOrder(symbol :string, side :OrderSide, type :OrderType, timeInForce? :TimeInForce, quantity? :DECIMAL, quoteOrderQty? :DECIMAL, price? :DECIMAL, newClientOrderId? :string, strategyId? :INT, strategyType? :INT, stopPrice? :DECIMAL, trailingDelta? :LONG, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :"EXPIRE_TAKER"|"EXPIRE_MAKER"|"EXPIRE_BOTH"|"NONE", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["newOrder"]>;
  
  
  /** New Order  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-order-trade}
   * 
   * Send in a new order.
   * 
   * EndPoint: /api/v3/order
   * 
   * Weight(IP): 1
   * Weight(UID): 1
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {OrderType} options.type
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity
   * @param {DECIMAL} options.quoteOrderQty
   * @param {DECIMAL} options.price
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent.
   * @param {INT} options.strategyId
   * @param {INT} options.strategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} options.stopPrice  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {LONG} options.trailingDelta  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.  For more details on SPOT implementation on trailing stops, please refer to Trailing Stop FAQ
   * @param {DECIMAL} options.icebergQty  -  Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {OrderResponseType} options.newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {"EXPIRE_TAKER"|"EXPIRE_MAKER"|"EXPIRE_BOTH"|"NONE"} options.selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  newOrder(options : { symbol :string, side :OrderSide, type :OrderType, timeInForce? :TimeInForce, quantity? :DECIMAL, quoteOrderQty? :DECIMAL, price? :DECIMAL, newClientOrderId? :string, strategyId? :INT, strategyType? :INT, stopPrice? :DECIMAL, trailingDelta? :LONG, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :"EXPIRE_TAKER"|"EXPIRE_MAKER"|"EXPIRE_BOTH"|"NONE", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  // ACK:
     symbol: string,  // example: "BTCUSDT"
     orderId: number,  // example: 28
     orderListId: number,  // example: -1  //Unless an order list, value will be -1
     clientOrderId: string,  // example: "6gCrw2kRUAF9CvJDGP16IP"
     transactTime: number  // example: 1507725176595
    } | {  // RESULT:
     symbol: string,  // example: "BTCUSDT"
     orderId: number,  // example: 28
     orderListId: number,  // example: -1  //Unless an order list, value will be -1
     clientOrderId: string,  // example: "6gCrw2kRUAF9CvJDGP16IP"
     transactTime: number,  // example: 1507725176595
     price: NumberString,  // example: "0.00000000"
     origQty: NumberString,  // example: "10.00000000"
     executedQty: NumberString,  // example: "10.00000000"
     cummulativeQuoteQty: NumberString,  // example: "10.00000000"
     status: string,  // example: "FILLED"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "MARKET"
     side: OrderSide,  // example: "SELL"
     workingTime: number,  // example: 1507725176595
     selfTradePreventionMode: string  // example: "NONE"
    } | {  // FULL:
     symbol: string,  // example: "BTCUSDT"
     orderId: number,  // example: 28
     orderListId: number,  // example: -1  //Unless an order list, value will be -1
     clientOrderId: string,  // example: "6gCrw2kRUAF9CvJDGP16IP"
     transactTime: number,  // example: 1507725176595
     price: NumberString,  // example: "0.00000000"
     origQty: NumberString,  // example: "10.00000000"
     executedQty: NumberString,  // example: "10.00000000"
     cummulativeQuoteQty: NumberString,  // example: "10.00000000"
     status: string,  // example: "FILLED"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "MARKET"
     side: OrderSide,  // example: "SELL"
     workingTime: number,  // example: 1507725176595
     selfTradePreventionMode: string,  // example: "NONE"
     fills: {
         price: NumberString,  // example: "4000.00000000"
         qty: NumberString,  // example: "1.00000000"
         commission: NumberString,  // example: "4.00000000"
         commissionAsset: string,  // example: "USDT"
         tradeId: number  // example: 56
       }[]
    }>;
  
  
  newOrder(...args : any) {
      return this._sendRequest("/api/v3/order", "POST", "TRADE", false, args, ["symbol", "side", "type", "timeInForce", "quantity", "quoteOrderQty", "price", "newClientOrderId", "strategyId", "strategyType", "stopPrice", "trailingDelta", "icebergQty", "newOrderRespType", "selfTradePreventionMode", "recvWindow", "timestamp"], "newOrder");
  }
  
  
  /** Cancel Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-order-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /api/v3/order
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {string} newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default.
   * @param {ENUM} cancelRestrictions  -  Supported values: ONLY_NEW - Cancel will succeed if the order status is NEW. ONLY_PARTIALLY_FILLED - Cancel will succeed if order status is PARTIALLY_FILLED.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  cancelOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, newClientOrderId? :string, cancelRestrictions? :ENUM, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["cancelOrder"]>;
  
  
  /** Cancel Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-order-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /api/v3/order
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {string} options.newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default.
   * @param {ENUM} options.cancelRestrictions  -  Supported values: ONLY_NEW - Cancel will succeed if the order status is NEW. ONLY_PARTIALLY_FILLED - Cancel will succeed if order status is PARTIALLY_FILLED.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  cancelOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, newClientOrderId? :string, cancelRestrictions? :ENUM, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "LTCBTC"
     origClientOrderId: string,  // example: "myOrder1"
     orderId: number,  // example: 4
     orderListId: number,  // example: -1  //Unless part of an order list, the value will always be -1.
     clientOrderId: string,  // example: "cancelMyOrder1"
     transactTime: number,  // example: 1684804350068
     price: NumberString,  // example: "2.00000000"
     origQty: NumberString,  // example: "1.00000000"
     executedQty: NumberString,  // example: "0.00000000"
     cummulativeQuoteQty: NumberString,  // example: "0.00000000"
     status: string,  // example: "CANCELED"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     side: OrderSide,  // example: "BUY"
     selfTradePreventionMode: string  // example: "NONE"
    }>;
  
  
  cancelOrder(...args : any) {
      return this._sendRequest("/api/v3/order", "DELETE", "TRADE", false, args, ["symbol", "orderId", "origClientOrderId", "newClientOrderId", "cancelRestrictions", "recvWindow", "timestamp"], "cancelOrder");
  }
  
  
  /** Cancel all Open Orders on a Symbol (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-all-open-orders-on-a-symbol-trade}
   * 
   * EndPoint: /api/v3/openOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  cancelAllOpenOrdersOnASymbol(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["cancelAllOpenOrdersOnASymbol"]>;
  
  
  /** Cancel all Open Orders on a Symbol (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-all-open-orders-on-a-symbol-trade}
   * 
   * EndPoint: /api/v3/openOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  cancelAllOpenOrdersOnASymbol(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: "BTCUSDT"
       origClientOrderId: string,  // example: "E6APeyTJvkMvLMYMqu1KQ4"
       orderId: number,  // example: 11
       orderListId: number,  // example: -1
       clientOrderId: string,  // example: "pXLV6Hz6mprAcVYpVMTGgx"
       transactTime: number,  // example: 1684804350068
       price: NumberString,  // example: "0.089853"
       origQty: NumberString,  // example: "0.178622"
       executedQty: NumberString,  // example: "0.000000"
       cummulativeQuoteQty: NumberString,  // example: "0.000000"
       status: string,  // example: "CANCELED"
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       side: OrderSide,  // example: "BUY"
       selfTradePreventionMode: string  // example: "NONE"
     } |
     {
       orderListId: number,  // example: 1929
       contingencyType: string,  // example: "OCO"
       listStatusType: OCOStatus,  // example: "ALL_DONE"
       listOrderStatus: OCOOrderStatus,  // example: "ALL_DONE"
       listClientOrderId: string,  // example: "2inzWQdDvZLHbbAmAozX2N"
       transactionTime: number,  // example: 1585230948299
       symbol: string,  // example: "BTCUSDT"
       orders: {
           symbol: string,  // example: "BTCUSDT"
           orderId: number,  // example: 20
           clientOrderId: string  // example: "CwOOIPHSmYywx6jZX77TdL"
         }[],
       orderReports: (
         {
           symbol: string,  // example: "BTCUSDT"
           origClientOrderId: string,  // example: "CwOOIPHSmYywx6jZX77TdL"
           orderId: number,  // example: 20
           orderListId: number,  // example: 1929
           clientOrderId: string,  // example: "pXLV6Hz6mprAcVYpVMTGgx"
           transactTime: number,  // example: 1688005070874
           price: NumberString,  // example: "0.668611"
           origQty: NumberString,  // example: "0.690354"
           executedQty: NumberString,  // example: "0.000000"
           cummulativeQuoteQty: NumberString,  // example: "0.000000"
           status: string,  // example: "CANCELED"
           timeInForce: TimeInForce,  // example: "GTC"
           type: OrderType,  // example: "STOP_LOSS_LIMIT"
           side: OrderSide,  // example: "BUY"
           stopPrice: NumberString,  // example: "0.378131"
           icebergQty: NumberString,  // example: "0.017083"
           selfTradePreventionMode: string  // example: "NONE"
         } |
         {
           symbol: string,  // example: "BTCUSDT"
           origClientOrderId: string,  // example: "461cPg51vQjV3zIMOXNz39"
           orderId: number,  // example: 21
           orderListId: number,  // example: 1929
           clientOrderId: string,  // example: "pXLV6Hz6mprAcVYpVMTGgx"
           transactTime: number,  // example: 1688005070874
           price: NumberString,  // example: "0.008791"
           origQty: NumberString,  // example: "0.690354"
           executedQty: NumberString,  // example: "0.000000"
           cummulativeQuoteQty: NumberString,  // example: "0.000000"
           status: string,  // example: "CANCELED"
           timeInForce: TimeInForce,  // example: "GTC"
           type: OrderType,  // example: "LIMIT_MAKER"
           side: OrderSide,  // example: "BUY"
           icebergQty: NumberString,  // example: "0.639962"
           selfTradePreventionMode: string  // example: "NONE"
         }
       )[]
     }
    )[]>;
  
  
  cancelAllOpenOrdersOnASymbol(...args : any) {
      return this._sendRequest("/api/v3/openOrders", "DELETE", "TRADE", false, args, ["symbol", "recvWindow", "timestamp"], "cancelAllOpenOrdersOnASymbol");
  }
  
  
  /** Query Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-order-user_data}
   * 
   * Check an order's status.
   * 
   * EndPoint: /api/v3/order
   * 
   * Weight(IP): 4
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryOrder"]>;
  
  
  /** Query Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-order-user_data}
   * 
   * Check an order's status.
   * 
   * EndPoint: /api/v3/order
   * 
   * Weight(IP): 4
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "LTCBTC"
     orderId: number,  // example: 1
     orderListId: number,  // example: -1  //Unless an order list, value will be -1
     clientOrderId: string,  // example: "myOrder1"
     price: NumberString,  // example: "0.1"
     origQty: NumberString,  // example: "1.0"
     executedQty: NumberString,  // example: "0.0"
     cummulativeQuoteQty: NumberString,  // example: "0.0"
     status: string,  // example: "NEW"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     side: OrderSide,  // example: "BUY"
     stopPrice: NumberString,  // example: "0.0"
     icebergQty: NumberString,  // example: "0.0"
     time: number,  // example: 1499827319559
     updateTime: number,  // example: 1499827319559
     isWorking: boolean,  // example: true
     workingTime: number,  // example: 1499827319559
     origQuoteOrderQty: NumberString,  // example: "0.000000"
     selfTradePreventionMode: string  // example: "NONE"
    }>;
  
  
  queryOrder(...args : any) {
      return this._sendRequest("/api/v3/order", "GET", "USER_DATA", false, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "queryOrder");
  }
  
  
  /** Cancel an Existing Order and Send a New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-an-existing-order-and-send-a-new-order-trade}
   * 
   * Cancels an existing order and places a new order on the same symbol.
   * 
   * EndPoint: /api/v3/order/cancelReplace
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {OrderType} type
   * @param {ENUM} cancelReplaceMode  -  The allowed values are:  STOP_ON_FAILURE - If the cancel request fails, the new order placement will not be attempted.  ALLOW_FAILURE - new order placement will be attempted even if cancel request fails.
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity
   * @param {DECIMAL} quoteOrderQty
   * @param {DECIMAL} price
   * @param {string} cancelNewClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default.
   * @param {string} cancelOrigClientOrderId  -  Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
   * @param {LONG} cancelOrderId  -  Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
   * @param {string} newClientOrderId  -  Used to identify the new order.
   * @param {INT} strategyId
   * @param {INT} strategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} stopPrice
   * @param {LONG} trailingDelta
   * @param {DECIMAL} icebergQty
   * @param {OrderResponseType} newOrderRespType  -  Allowed values:  ACK, RESULT, FULL  MARKET and LIMIT orders types default to FULL; all other orders default to ACK
   * @param {ENUM} selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {ENUM} cancelRestrictions  -  Supported values: ONLY_NEW - Cancel will succeed if the order status is NEW. ONLY_PARTIALLY_FILLED - Cancel will succeed if order status is PARTIALLY_FILLED. For more information please refer to Regarding cancelRestrictions
   * @param {ENUM} orderRateLimitExceededMode  -  Supported values:  DO_NOTHING (default)- will only attempt to cancel the order if account has not exceeded the unfilled order rate limit CANCEL_ONLY - will always cancel the order
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  cancelAnExistingOrderAndSendANewOrder(symbol :string, side :OrderSide, type :OrderType, cancelReplaceMode :ENUM, timeInForce? :TimeInForce, quantity? :DECIMAL, quoteOrderQty? :DECIMAL, price? :DECIMAL, cancelNewClientOrderId? :string, cancelOrigClientOrderId? :string, cancelOrderId? :LONG, newClientOrderId? :string, strategyId? :INT, strategyType? :INT, stopPrice? :DECIMAL, trailingDelta? :LONG, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, cancelRestrictions? :ENUM, orderRateLimitExceededMode? :ENUM, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["cancelAnExistingOrderAndSendANewOrder"]>;
  
  
  /** Cancel an Existing Order and Send a New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-an-existing-order-and-send-a-new-order-trade}
   * 
   * Cancels an existing order and places a new order on the same symbol.
   * 
   * EndPoint: /api/v3/order/cancelReplace
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {OrderType} options.type
   * @param {ENUM} options.cancelReplaceMode  -  The allowed values are:  STOP_ON_FAILURE - If the cancel request fails, the new order placement will not be attempted.  ALLOW_FAILURE - new order placement will be attempted even if cancel request fails.
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity
   * @param {DECIMAL} options.quoteOrderQty
   * @param {DECIMAL} options.price
   * @param {string} options.cancelNewClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default.
   * @param {string} options.cancelOrigClientOrderId  -  Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
   * @param {LONG} options.cancelOrderId  -  Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
   * @param {string} options.newClientOrderId  -  Used to identify the new order.
   * @param {INT} options.strategyId
   * @param {INT} options.strategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} options.stopPrice
   * @param {LONG} options.trailingDelta
   * @param {DECIMAL} options.icebergQty
   * @param {OrderResponseType} options.newOrderRespType  -  Allowed values:  ACK, RESULT, FULL  MARKET and LIMIT orders types default to FULL; all other orders default to ACK
   * @param {ENUM} options.selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {ENUM} options.cancelRestrictions  -  Supported values: ONLY_NEW - Cancel will succeed if the order status is NEW. ONLY_PARTIALLY_FILLED - Cancel will succeed if order status is PARTIALLY_FILLED. For more information please refer to Regarding cancelRestrictions
   * @param {ENUM} options.orderRateLimitExceededMode  -  Supported values:  DO_NOTHING (default)- will only attempt to cancel the order if account has not exceeded the unfilled order rate limit CANCEL_ONLY - will always cancel the order
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  cancelAnExistingOrderAndSendANewOrder(options : { symbol :string, side :OrderSide, type :OrderType, cancelReplaceMode :ENUM, timeInForce? :TimeInForce, quantity? :DECIMAL, quoteOrderQty? :DECIMAL, price? :DECIMAL, cancelNewClientOrderId? :string, cancelOrigClientOrderId? :string, cancelOrderId? :LONG, newClientOrderId? :string, strategyId? :INT, strategyType? :INT, stopPrice? :DECIMAL, trailingDelta? :LONG, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, cancelRestrictions? :ENUM, orderRateLimitExceededMode? :ENUM, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  // SUCCESS and account has not exceeded the order rate limit:
     cancelResult: string,  // example: "SUCCESS"
     newOrderResult: string,  // example: "SUCCESS"
     cancelResponse: {
       symbol: string,  // example: "BTCUSDT"
       origClientOrderId: string,  // example: "DnLo3vTAQcjha43lAZhZ0y"
       orderId: number,  // example: 9
       orderListId: number,  // example: -1
       clientOrderId: string,  // example: "osxN3JXAtJvKvCqGeMWMVR"
       transactTime: number,  // example: 1684804350068
       price: NumberString,  // example: "0.01000000"
       origQty: NumberString,  // example: "0.000100"
       executedQty: NumberString,  // example: "0.00000000"
       cummulativeQuoteQty: NumberString,  // example: "0.00000000"
       status: string,  // example: "CANCELED"
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       side: OrderSide,  // example: "SELL"
       selfTradePreventionMode: string  // example: "NONE"
     },
     newOrderResponse: {
       symbol: string,  // example: "BTCUSDT"
       orderId: number,  // example: 10
       orderListId: number,  // example: -1
       clientOrderId: string,  // example: "wOceeeOzNORyLiQfw7jd8S"
       transactTime: number,  // example: 1652928801803
       price: NumberString,  // example: "0.02000000"
       origQty: NumberString,  // example: "0.040000"
       executedQty: NumberString,  // example: "0.00000000"
       cummulativeQuoteQty: NumberString,  // example: "0.00000000"
       status: string,  // example: "NEW"
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       side: OrderSide,  // example: "BUY"
       workingTime: number,  // example: 1669277163808
       fills: unknown[],
       selfTradePreventionMode: string  // example: "NONE"
     }
    } | {  // when Cancel Order Fails with STOP_ON_FAILURE:
     code: number,  // example: -2022
     msg: string,  // example: "Order cancel-replace failed."
     data: {
       cancelResult: string,  // example: "FAILURE"
       newOrderResult: string,  // example: "NOT_ATTEMPTED"
       cancelResponse: {
         code: number,  // example: -2011
         msg: string    // example: "Unknown order sent."
       },
       newOrderResponse: null  // example: null
     }
    } | {  // when Cancel Order Succeeds but New Order Placement Fails and account has not exceeded the order rate limit:
     code: number,  // example: -2021
     msg: string,  // example: "Order cancel-replace partially failed."
     data: {
       cancelResult: string,  // example: "SUCCESS"
       newOrderResult: string,  // example: "FAILURE"
       cancelResponse: {
         symbol: string,  // example: "BTCUSDT"
         origClientOrderId: string,  // example: "86M8erehfExV8z2RC8Zo8k"
         orderId: number,  // example: 3
         orderListId: number,  // example: -1
         clientOrderId: string,  // example: "G1kLo6aDv2KGNTFcjfTSFq"
         transactTime: number,  // example: 1684804350068
         price: NumberString,  // example: "0.006123"
         origQty: NumberString,  // example: "10000.000000"
         executedQty: NumberString,  // example: "0.000000"
         cummulativeQuoteQty: NumberString,  // example: "0.000000"
         status: string,  // example: "CANCELED"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "LIMIT_MAKER"
         side: OrderSide,  // example: "SELL"
         selfTradePreventionMode: string  // example: "NONE"
       },
       newOrderResponse: {
         code: number,  // example: -2010
         msg: string    // example: "Order would immediately match and take."
       }
     }
    } | {  // when Cancel Order fails with ALLOW_FAILURE and account has not exceeded the order rate limit:
     code: number,  // example: -2021
     msg: string,  // example: "Order cancel-replace partially failed."
     data: {
       cancelResult: string,  // example: "FAILURE"
       newOrderResult: string,  // example: "SUCCESS"
       cancelResponse: {
         code: number,  // example: -2011
         msg: string    // example: "Unknown order sent."
       },
       newOrderResponse: {
         symbol: string,  // example: "BTCUSDT"
         orderId: number,  // example: 11
         orderListId: number,  // example: -1
         clientOrderId: string,  // example: "pfojJMg6IMNDKuJqDxvoxN"
         transactTime: number  // example: 1648540168818
       }
     }
    } | {  // when both Cancel Order and New Order Placement fail using cancelReplaceMode=ALLOW_FAILURE and account has not exceeded the order rate limit:
     code: number,  // example: -2022
     msg: string,  // example: "Order cancel-replace failed."
     data: {
       cancelResult: string,  // example: "FAILURE"
       newOrderResult: string,  // example: "FAILURE"
       cancelResponse: {
         code: number,  // example: -2011
         msg: string    // example: "Unknown order sent."
       },
       newOrderResponse: {
         code: number,  // example: -2010
         msg: string    // example: "Order would immediately match and take."
       }
     }
    } | {  // when using orderRateLimitExceededMode=DO_NOTHING and account's order rate limit has been exceeded:
     code: number,  // example: -1015
     msg: string    // example: "Too many new orders; current limit is 1 orders per 10 SECOND."
    }>;
  
  
  cancelAnExistingOrderAndSendANewOrder(...args : any) {
      return this._sendRequest("/api/v3/order/cancelReplace", "POST", "TRADE", false, args, ["symbol", "side", "type", "cancelReplaceMode", "timeInForce", "quantity", "quoteOrderQty", "price", "cancelNewClientOrderId", "cancelOrigClientOrderId", "cancelOrderId", "newClientOrderId", "strategyId", "strategyType", "stopPrice", "trailingDelta", "icebergQty", "newOrderRespType", "selfTradePreventionMode", "cancelRestrictions", "orderRateLimitExceededMode", "recvWindow", "timestamp"], "cancelAnExistingOrderAndSendANewOrder");
  }
  
  
  /** Current Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#current-open-orders-user_data}
   * 
   * EndPoint: /api/v3/openOrders
   * 
   * Weight(IP): 
   *   6 for a single symbol;
   *   80 when the symbol parameter is omitted;
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  currentOpenOrders(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["currentOpenOrders"]>;
  
  
  /** Current Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#current-open-orders-user_data}
   * 
   * EndPoint: /api/v3/openOrders
   * 
   * Weight(IP): 
   *   6 for a single symbol;
   *   80 when the symbol parameter is omitted;
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  currentOpenOrders(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "LTCBTC"
       orderId: number,  // example: 1
       orderListId: number,  // example: -1  //Unless an order list, the value will always be -1
       clientOrderId: string,  // example: "myOrder1"
       price: NumberString,  // example: "0.1"
       origQty: NumberString,  // example: "1.0"
       executedQty: NumberString,  // example: "0.0"
       cummulativeQuoteQty: NumberString,  // example: "0.0"
       status: string,  // example: "NEW"
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       side: OrderSide,  // example: "BUY"
       stopPrice: NumberString,  // example: "0.0"
       icebergQty: NumberString,  // example: "0.0"
       time: number,  // example: 1499827319559
       updateTime: number,  // example: 1499827319559
       isWorking: boolean,  // example: true
       workingTime: number,  // example: 1499827319559
       origQuoteOrderQty: NumberString,  // example: "0.000000"
       selfTradePreventionMode: string  // example: "NONE"
     }[]>;
  
  
  currentOpenOrders(...args : any) {
      return this._sendRequest("/api/v3/openOrders", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "currentOpenOrders");
  }
  
  
  /** All Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#all-orders-user_data}
   * 
   * Get all account orders; active, canceled, or filled.
   * 
   * EndPoint: /api/v3/allOrders
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  allOrders(symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["allOrders"]>;
  
  
  /** All Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#all-orders-user_data}
   * 
   * Get all account orders; active, canceled, or filled.
   * 
   * EndPoint: /api/v3/allOrders
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  allOrders(options : { symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "LTCBTC"
       orderId: number,  // example: 1
       orderListId: number,  // example: -1  //Unless an order list, the value will always be -1
       clientOrderId: string,  // example: "myOrder1"
       price: NumberString,  // example: "0.1"
       origQty: NumberString,  // example: "1.0"
       executedQty: NumberString,  // example: "0.0"
       cummulativeQuoteQty: NumberString,  // example: "0.0"
       status: string,  // example: "NEW"
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       side: OrderSide,  // example: "BUY"
       stopPrice: NumberString,  // example: "0.0"
       icebergQty: NumberString,  // example: "0.0"
       time: number,  // example: 1499827319559
       updateTime: number,  // example: 1499827319559
       isWorking: boolean,  // example: true
       origQuoteOrderQty: NumberString,  // example: "0.000000"
       workingTime: number,  // example: 1499827319559
       selfTradePreventionMode: string  // example: "NONE"
     }[]>;
  
  
  allOrders(...args : any) {
      return this._sendRequest("/api/v3/allOrders", "GET", "USER_DATA", false, args, ["symbol", "orderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "allOrders");
  }
  
  
  /** New OCO - Deprecated (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-oco-deprecated-trade}
   * 
   * Send in a new OCO
   * 
   * EndPoint: /api/v3/order/oco
   * 
   * Weight(IP): 1
   * Weight(UID): 2
   * 
   * @param {string} symbol
   * @param {string} listClientOrderId  -  A unique Id for the entire orderList
   * @param {OrderSide} side
   * @param {DECIMAL} quantity
   * @param {string} limitClientOrderId  -  A unique Id for the limit order
   * @param {INT} limitStrategyId
   * @param {INT} limitStrategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} price
   * @param {DECIMAL} limitIcebergQty
   * @param {LONG} trailingDelta
   * @param {string} stopClientOrderId  -  A unique Id for the stop loss/stop loss limit leg
   * @param {DECIMAL} stopPrice
   * @param {INT} stopStrategyId
   * @param {INT} stopStrategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} stopLimitPrice  -  If provided, stopLimitTimeInForce is required.
   * @param {DECIMAL} stopIcebergQty
   * @param {ENUM} stopLimitTimeInForce  -  Valid values are GTC/FOK/IOC
   * @param {OrderResponseType} newOrderRespType  -  Set the response JSON.
   * @param {ENUM} selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  newOCODeprecated(symbol :string, listClientOrderId :string|undefined, side :OrderSide, quantity :DECIMAL, limitClientOrderId :string|undefined, limitStrategyId :INT|undefined, limitStrategyType :INT|undefined, price :DECIMAL, limitIcebergQty :DECIMAL|undefined, trailingDelta :LONG|undefined, stopClientOrderId :string|undefined, stopPrice :DECIMAL, stopStrategyId? :INT, stopStrategyType? :INT, stopLimitPrice? :DECIMAL, stopIcebergQty? :DECIMAL, stopLimitTimeInForce? :ENUM, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["newOCODeprecated"]>;
  
  
  /** New OCO - Deprecated (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-oco-deprecated-trade}
   * 
   * Send in a new OCO
   * 
   * EndPoint: /api/v3/order/oco
   * 
   * Weight(IP): 1
   * Weight(UID): 2
   * 
   * @param {string} options.symbol
   * @param {string} options.listClientOrderId  -  A unique Id for the entire orderList
   * @param {OrderSide} options.side
   * @param {DECIMAL} options.quantity
   * @param {string} options.limitClientOrderId  -  A unique Id for the limit order
   * @param {INT} options.limitStrategyId
   * @param {INT} options.limitStrategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} options.price
   * @param {DECIMAL} options.limitIcebergQty
   * @param {LONG} options.trailingDelta
   * @param {string} options.stopClientOrderId  -  A unique Id for the stop loss/stop loss limit leg
   * @param {DECIMAL} options.stopPrice
   * @param {INT} options.stopStrategyId
   * @param {INT} options.stopStrategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} options.stopLimitPrice  -  If provided, stopLimitTimeInForce is required.
   * @param {DECIMAL} options.stopIcebergQty
   * @param {ENUM} options.stopLimitTimeInForce  -  Valid values are GTC/FOK/IOC
   * @param {OrderResponseType} options.newOrderRespType  -  Set the response JSON.
   * @param {ENUM} options.selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  newOCODeprecated(options : { symbol :string, listClientOrderId? :string, side :OrderSide, quantity :DECIMAL, limitClientOrderId? :string, limitStrategyId? :INT, limitStrategyType? :INT, price :DECIMAL, limitIcebergQty? :DECIMAL, trailingDelta? :LONG, stopClientOrderId? :string, stopPrice :DECIMAL, stopStrategyId? :INT, stopStrategyType? :INT, stopLimitPrice? :DECIMAL, stopIcebergQty? :DECIMAL, stopLimitTimeInForce? :ENUM, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 0
     contingencyType: string,  // example: "OCO"
     listStatusType: OCOStatus,  // example: "EXEC_STARTED"
     listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
     listClientOrderId: string,  // example: "JYVpp3F0f5CAG15DhtrqLp"
     transactionTime: number,  // example: 1563417480525
     symbol: string,  // example: "LTCBTC"
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 2
         clientOrderId: string  // example: "Kk7sqHb9J6mJWTMDVW7Vos"
       }[],
     orderReports: (
       {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 2
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "Kk7sqHb9J6mJWTMDVW7Vos"
         transactTime: number,  // example: 1563417480525
         price: NumberString,  // example: "0.000000"
         origQty: NumberString,  // example: "0.624363"
         executedQty: NumberString,  // example: "0.000000"
         cummulativeQuoteQty: NumberString,  // example: "0.000000"
         status: string,  // example: "NEW"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "STOP_LOSS"
         side: OrderSide,  // example: "BUY"
         stopPrice: NumberString,  // example: "0.960664"
         workingTime: number,  // example: -1
         selfTradePreventionMode: string  // example: "NONE"
       } |
       {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 3
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "xTXKaGYd4bluPVp78IVRvl"
         transactTime: number,  // example: 1563417480525
         price: NumberString,  // example: "0.036435"
         origQty: NumberString,  // example: "0.624363"
         executedQty: NumberString,  // example: "0.000000"
         cummulativeQuoteQty: NumberString,  // example: "0.000000"
         status: string,  // example: "NEW"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "LIMIT_MAKER"
         side: OrderSide,  // example: "BUY"
         workingTime: number,  // example: 1563417480525
         selfTradePreventionMode: string  // example: "NONE"
       }
     )[]
    }>;
  
  
  newOCODeprecated(...args : any) {
      return this._sendRequest("/api/v3/order/oco", "POST", "TRADE", false, args, ["symbol", "listClientOrderId", "side", "quantity", "limitClientOrderId", "limitStrategyId", "limitStrategyType", "price", "limitIcebergQty", "trailingDelta", "stopClientOrderId", "stopPrice", "stopStrategyId", "stopStrategyType", "stopLimitPrice", "stopIcebergQty", "stopLimitTimeInForce", "newOrderRespType", "selfTradePreventionMode", "recvWindow", "timestamp"], "newOCODeprecated");
  }
  
  
  /** New Order List - OCO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-order-list-oco-trade}
   * 
   * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
   * 
   * EndPoint: /api/v3/orderList/oco
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {string} listClientOrderId  -  Arbitrary unique ID among open order lists. Automatically generated if not sent.  A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired.  listClientOrderId is distinct from the aboveClientOrderId and the belowCLientOrderId.
   * @param {OrderSide} side  -  BUY or SELL
   * @param {DECIMAL} quantity  -  Quantity for both legs of the order list.
   * @param {ENUM} aboveType  -  Supported values : STOP_LOSS_LIMIT, STOP_LOSS, LIMIT_MAKER
   * @param {string} aboveClientOrderId  -  Arbitrary unique ID among open orders for the above leg order. Automatically generated if not sent
   * @param {LONG} aboveIcebergQty  -  Note that this can only be used if aboveTimeInForce is GTC.
   * @param {DECIMAL} abovePrice
   * @param {DECIMAL} aboveStopPrice  -  Can be used if aboveType is STOP_LOSS or STOP_LOSS_LIMIT. Either aboveStopPrice or aboveTrailingDelta or both, must be specified.
   * @param {LONG} aboveTrailingDelta  -  See Trailing Stop order FAQ.
   * @param {DECIMAL} aboveTimeInForce  -  Required if the aboveType is STOP_LOSS_LIMIT.
   * @param {INT} aboveStrategyId  -  Arbitrary numeric value identifying the above leg order within an order strategy.
   * @param {INT} aboveStrategyType  -  Arbitrary numeric value identifying the above leg order strategy. Values smaller than 1000000 are reserved and cannot be used.
   * @param {ENUM} belowType  -  Supported values : STOP_LOSS_LIMIT, STOP_LOSS, LIMIT_MAKER
   * @param {string} belowClientOrderId  -  Arbitrary unique ID among open orders for the below leg order. Automatically generated if not sent
   * @param {LONG} belowIcebergQty  -  Note that this can only be used if belowTimeInForce is GTC.
   * @param {DECIMAL} belowPrice
   * @param {DECIMAL} belowStopPrice  -  Can be used if belowType is STOP_LOSS or STOP_LOSS_LIMIT. Either belowStopPrice or belowTrailingDelta or both, must be specified.
   * @param {LONG} belowTrailingDelta  -  See Trailing Stop order FAQ.
   * @param {ENUM} belowTimeInForce  -  Required if the belowType is STOP_LOSS_LIMIT.
   * @param {INT} belowStrategyId  -  Arbitrary numeric value identifying the below leg order within an order strategy.
   * @param {INT} belowStrategyType  -  Arbitrary numeric value identifying the below leg order strategy. Values smaller than 1000000 are reserved and cannot be used.
   * @param {OrderResponseType} newOrderRespType  -  Select response format: ACK, RESULT, FULL
   * @param {ENUM} selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000.
   * @param {LONG} timestamp
   */
  newOrderListOCO(symbol :string, listClientOrderId :string|undefined, side :OrderSide, quantity :DECIMAL, aboveType :ENUM, aboveClientOrderId :string|undefined, aboveIcebergQty :LONG|undefined, abovePrice :DECIMAL|undefined, aboveStopPrice :DECIMAL|undefined, aboveTrailingDelta :LONG|undefined, aboveTimeInForce :DECIMAL|undefined, aboveStrategyId :INT|undefined, aboveStrategyType :INT|undefined, belowType :ENUM, belowClientOrderId? :string, belowIcebergQty? :LONG, belowPrice? :DECIMAL, belowStopPrice? :DECIMAL, belowTrailingDelta? :LONG, belowTimeInForce? :ENUM, belowStrategyId? :INT, belowStrategyType? :INT, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["newOrderListOCO"]>;
  
  
  /** New Order List - OCO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-order-list-oco-trade}
   * 
   * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
   * 
   * EndPoint: /api/v3/orderList/oco
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {string} options.listClientOrderId  -  Arbitrary unique ID among open order lists. Automatically generated if not sent.  A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired.  listClientOrderId is distinct from the aboveClientOrderId and the belowCLientOrderId.
   * @param {OrderSide} options.side  -  BUY or SELL
   * @param {DECIMAL} options.quantity  -  Quantity for both legs of the order list.
   * @param {ENUM} options.aboveType  -  Supported values : STOP_LOSS_LIMIT, STOP_LOSS, LIMIT_MAKER
   * @param {string} options.aboveClientOrderId  -  Arbitrary unique ID among open orders for the above leg order. Automatically generated if not sent
   * @param {LONG} options.aboveIcebergQty  -  Note that this can only be used if aboveTimeInForce is GTC.
   * @param {DECIMAL} options.abovePrice
   * @param {DECIMAL} options.aboveStopPrice  -  Can be used if aboveType is STOP_LOSS or STOP_LOSS_LIMIT. Either aboveStopPrice or aboveTrailingDelta or both, must be specified.
   * @param {LONG} options.aboveTrailingDelta  -  See Trailing Stop order FAQ.
   * @param {DECIMAL} options.aboveTimeInForce  -  Required if the aboveType is STOP_LOSS_LIMIT.
   * @param {INT} options.aboveStrategyId  -  Arbitrary numeric value identifying the above leg order within an order strategy.
   * @param {INT} options.aboveStrategyType  -  Arbitrary numeric value identifying the above leg order strategy. Values smaller than 1000000 are reserved and cannot be used.
   * @param {ENUM} options.belowType  -  Supported values : STOP_LOSS_LIMIT, STOP_LOSS, LIMIT_MAKER
   * @param {string} options.belowClientOrderId  -  Arbitrary unique ID among open orders for the below leg order. Automatically generated if not sent
   * @param {LONG} options.belowIcebergQty  -  Note that this can only be used if belowTimeInForce is GTC.
   * @param {DECIMAL} options.belowPrice
   * @param {DECIMAL} options.belowStopPrice  -  Can be used if belowType is STOP_LOSS or STOP_LOSS_LIMIT. Either belowStopPrice or belowTrailingDelta or both, must be specified.
   * @param {LONG} options.belowTrailingDelta  -  See Trailing Stop order FAQ.
   * @param {ENUM} options.belowTimeInForce  -  Required if the belowType is STOP_LOSS_LIMIT.
   * @param {INT} options.belowStrategyId  -  Arbitrary numeric value identifying the below leg order within an order strategy.
   * @param {INT} options.belowStrategyType  -  Arbitrary numeric value identifying the below leg order strategy. Values smaller than 1000000 are reserved and cannot be used.
   * @param {OrderResponseType} options.newOrderRespType  -  Select response format: ACK, RESULT, FULL
   * @param {ENUM} options.selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000.
   * @param {LONG} options.timestamp
   */
  newOrderListOCO(options : { symbol :string, listClientOrderId? :string, side :OrderSide, quantity :DECIMAL, aboveType :ENUM, aboveClientOrderId? :string, aboveIcebergQty? :LONG, abovePrice? :DECIMAL, aboveStopPrice? :DECIMAL, aboveTrailingDelta? :LONG, aboveTimeInForce? :DECIMAL, aboveStrategyId? :INT, aboveStrategyType? :INT, belowType :ENUM, belowClientOrderId? :string, belowIcebergQty? :LONG, belowPrice? :DECIMAL, belowStopPrice? :DECIMAL, belowTrailingDelta? :LONG, belowTimeInForce? :ENUM, belowStrategyId? :INT, belowStrategyType? :INT, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 1
     contingencyType: string,  // example: "OCO"
     listStatusType: OCOStatus,  // example: "EXEC_STARTED"
     listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
     listClientOrderId: string,  // example: "lH1YDkuQKWiXVXHPSKYEIp"
     transactionTime: number,  // example: 1710485608839
     symbol: string,  // example: "LTCBTC"
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 10
         clientOrderId: string  // example: "44nZvqpemY7sVYgPYbvPih"
       }[],
     orderReports: (
       {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 10
         orderListId: number,  // example: 1
         clientOrderId: string,  // example: "44nZvqpemY7sVYgPYbvPih"
         transactTime: number,  // example: 1710485608839
         price: NumberString,  // example: "1.00000000"
         origQty: NumberString,  // example: "5.00000000"
         executedQty: NumberString,  // example: "0.00000000"
         cummulativeQuoteQty: NumberString,  // example: "0.00000000"
         status: string,  // example: "NEW"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "STOP_LOSS_LIMIT"
         side: OrderSide,  // example: "SELL"
         stopPrice: NumberString,  // example: "1.00000000"
         workingTime: number,  // example: -1
         icebergQty: NumberString,  // example: "1.00000000"
         selfTradePreventionMode: string  // example: "NONE"
       } |
       {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 11
         orderListId: number,  // example: 1
         clientOrderId: string,  // example: "NuMp0nVYnciDiFmVqfpBqK"
         transactTime: number,  // example: 1710485608839
         price: NumberString,  // example: "3.00000000"
         origQty: NumberString,  // example: "5.00000000"
         executedQty: NumberString,  // example: "0.00000000"
         cummulativeQuoteQty: NumberString,  // example: "0.00000000"
         status: string,  // example: "NEW"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "LIMIT_MAKER"
         side: OrderSide,  // example: "SELL"
         workingTime: number,  // example: 1710485608839
         selfTradePreventionMode: string  // example: "NONE"
       }
     )[]
    }>;
  
  
  newOrderListOCO(...args : any) {
      return this._sendRequest("/api/v3/orderList/oco", "POST", "TRADE", false, args, ["symbol", "listClientOrderId", "side", "quantity", "aboveType", "aboveClientOrderId", "aboveIcebergQty", "abovePrice", "aboveStopPrice", "aboveTrailingDelta", "aboveTimeInForce", "aboveStrategyId", "aboveStrategyType", "belowType", "belowClientOrderId", "belowIcebergQty", "belowPrice", "belowStopPrice", "belowTrailingDelta", "belowTimeInForce", "belowStrategyId", "belowStrategyType", "newOrderRespType", "selfTradePreventionMode", "recvWindow", "timestamp"], "newOrderListOCO");
  }
  
  
  /** New Order List - OTO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-order-list-oto-trade}
   * 
   * Matching Engine
   * 
   * EndPoint: /api/v3/orderList/oto
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {string} listClientOrderId  -  Arbitrary unique ID among open order lists. Automatically generated if not sent. A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired.  listClientOrderId is distinct from the workingClientOrderId and the pendingClientOrderId.
   * @param {OrderResponseType} newOrderRespType  -  Format of the JSON response. Supported values: ACK, FULL, RESULT
   * @param {ENUM} selfTradePreventionMode  -  The allowed values are dependent on what is configured on the symbol.
   * @param {WorkingType} workingType  -  Supported values: LIMIT,LIMIT_MAKER
   * @param {ENUM} workingSide  -  Supported values: BUY, SELL
   * @param {string} workingClientOrderId  -  Arbitrary unique ID among open orders for the working order. Automatically generated if not sent.
   * @param {DECIMAL} workingPrice
   * @param {DECIMAL} workingQuantity  -  Sets the quantity for the working order.
   * @param {DECIMAL} workingIcebergQty  -  This can only be used if workingTimeInForce is GTC or if workingType is LIMIT_MAKER.
   * @param {ENUM} workingTimeInForce  -  Supported values: FOK, IOC, GTC
   * @param {INT} workingStrategyId  -  Arbitrary numeric value identifying the working order within an order strategy.
   * @param {INT} workingStrategyType  -  Arbitrary numeric value identifying the working order strategy.  Values smaller than 1000000 are reserved and cannot be used.
   * @param {ENUM} pendingType  -  Note that MARKET orders using quoteOrderQty are not supported.
   * @param {ENUM} pendingSide  -  Supported values: BUY, SELL
   * @param {string} pendingClientOrderId  -  Arbitrary unique ID among open orders for the pending order. Automatically generated if not sent.
   * @param {DECIMAL} pendingPrice
   * @param {DECIMAL} pendingStopPrice
   * @param {DECIMAL} pendingTrailingDelta
   * @param {DECIMAL} pendingQuantity  -  Sets the quantity for the pending order.
   * @param {DECIMAL} pendingIcebergQty  -  This can only be used if pendingTimeInForce is GTC or if pendingType is LIMIT_MAKER.
   * @param {ENUM} pendingTimeInForce  -  Supported values: GTC, FOK, IOC
   * @param {INT} pendingStrategyId  -  Arbitrary numeric value identifying the pending order within an order strategy.
   * @param {INT} pendingStrategyType  -  Arbitrary numeric value identifying the pending order strategy.  Values smaller than 1000000 are reserved and cannot be used.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000.
   * @param {LONG} timestamp
   */
  newOrderListOTO(symbol :string, listClientOrderId :string|undefined, newOrderRespType :OrderResponseType|undefined, selfTradePreventionMode :ENUM|undefined, workingType :WorkingType, workingSide :ENUM, workingClientOrderId :string|undefined, workingPrice :DECIMAL, workingQuantity :DECIMAL, workingIcebergQty :DECIMAL, workingTimeInForce :ENUM|undefined, workingStrategyId :INT|undefined, workingStrategyType :INT|undefined, pendingType :ENUM, pendingSide :ENUM, pendingClientOrderId :string|undefined, pendingPrice :DECIMAL|undefined, pendingStopPrice :DECIMAL|undefined, pendingTrailingDelta :DECIMAL|undefined, pendingQuantity :DECIMAL, pendingIcebergQty? :DECIMAL, pendingTimeInForce? :ENUM, pendingStrategyId? :INT, pendingStrategyType? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["newOrderListOTO"]>;
  
  
  /** New Order List - OTO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-order-list-oto-trade}
   * 
   * Matching Engine
   * 
   * EndPoint: /api/v3/orderList/oto
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {string} options.listClientOrderId  -  Arbitrary unique ID among open order lists. Automatically generated if not sent. A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired.  listClientOrderId is distinct from the workingClientOrderId and the pendingClientOrderId.
   * @param {OrderResponseType} options.newOrderRespType  -  Format of the JSON response. Supported values: ACK, FULL, RESULT
   * @param {ENUM} options.selfTradePreventionMode  -  The allowed values are dependent on what is configured on the symbol.
   * @param {WorkingType} options.workingType  -  Supported values: LIMIT,LIMIT_MAKER
   * @param {ENUM} options.workingSide  -  Supported values: BUY, SELL
   * @param {string} options.workingClientOrderId  -  Arbitrary unique ID among open orders for the working order. Automatically generated if not sent.
   * @param {DECIMAL} options.workingPrice
   * @param {DECIMAL} options.workingQuantity  -  Sets the quantity for the working order.
   * @param {DECIMAL} options.workingIcebergQty  -  This can only be used if workingTimeInForce is GTC or if workingType is LIMIT_MAKER.
   * @param {ENUM} options.workingTimeInForce  -  Supported values: FOK, IOC, GTC
   * @param {INT} options.workingStrategyId  -  Arbitrary numeric value identifying the working order within an order strategy.
   * @param {INT} options.workingStrategyType  -  Arbitrary numeric value identifying the working order strategy.  Values smaller than 1000000 are reserved and cannot be used.
   * @param {ENUM} options.pendingType  -  Note that MARKET orders using quoteOrderQty are not supported.
   * @param {ENUM} options.pendingSide  -  Supported values: BUY, SELL
   * @param {string} options.pendingClientOrderId  -  Arbitrary unique ID among open orders for the pending order. Automatically generated if not sent.
   * @param {DECIMAL} options.pendingPrice
   * @param {DECIMAL} options.pendingStopPrice
   * @param {DECIMAL} options.pendingTrailingDelta
   * @param {DECIMAL} options.pendingQuantity  -  Sets the quantity for the pending order.
   * @param {DECIMAL} options.pendingIcebergQty  -  This can only be used if pendingTimeInForce is GTC or if pendingType is LIMIT_MAKER.
   * @param {ENUM} options.pendingTimeInForce  -  Supported values: GTC, FOK, IOC
   * @param {INT} options.pendingStrategyId  -  Arbitrary numeric value identifying the pending order within an order strategy.
   * @param {INT} options.pendingStrategyType  -  Arbitrary numeric value identifying the pending order strategy.  Values smaller than 1000000 are reserved and cannot be used.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000.
   * @param {LONG} options.timestamp
   */
  newOrderListOTO(options : { symbol :string, listClientOrderId? :string, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, workingType :WorkingType, workingSide :ENUM, workingClientOrderId? :string, workingPrice :DECIMAL, workingQuantity :DECIMAL, workingIcebergQty :DECIMAL, workingTimeInForce? :ENUM, workingStrategyId? :INT, workingStrategyType? :INT, pendingType :ENUM, pendingSide :ENUM, pendingClientOrderId? :string, pendingPrice? :DECIMAL, pendingStopPrice? :DECIMAL, pendingTrailingDelta? :DECIMAL, pendingQuantity :DECIMAL, pendingIcebergQty? :DECIMAL, pendingTimeInForce? :ENUM, pendingStrategyId? :INT, pendingStrategyType? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 0
     contingencyType: string,  // example: "OTO"
     listStatusType: OCOStatus,  // example: "EXEC_STARTED"
     listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
     listClientOrderId: string,  // example: "yl2ERtcar1o25zcWtqVBTC"
     transactionTime: number,  // example: 1712289389158
     symbol: string,  // example: "ABCDEF"
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 4
         clientOrderId: string  // example: "Bq17mn9fP6vyCn75Jw1xya"
       }[],
     orderReports: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 4
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "Bq17mn9fP6vyCn75Jw1xya"
         transactTime: number,  // example: 1712289389158
         price: NumberString,  // example: "1.00000000"
         origQty: NumberString,  // example: "1.00000000"
         executedQty: NumberString,  // example: "0.00000000"
         cummulativeQuoteQty: NumberString,  // example: "0.00000000"
         status: string,  // example: "NEW"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "LIMIT"
         side: OrderSide,  // example: "SELL"
         workingTime: number,  // example: 1712289389158
         selfTradePreventionMode: string  // example: "NONE"
       }[]
    }>;
  
  
  newOrderListOTO(...args : any) {
      return this._sendRequest("/api/v3/orderList/oto", "POST", "TRADE", false, args, ["symbol", "listClientOrderId", "newOrderRespType", "selfTradePreventionMode", "workingType", "workingSide", "workingClientOrderId", "workingPrice", "workingQuantity", "workingIcebergQty", "workingTimeInForce", "workingStrategyId", "workingStrategyType", "pendingType", "pendingSide", "pendingClientOrderId", "pendingPrice", "pendingStopPrice", "pendingTrailingDelta", "pendingQuantity", "pendingIcebergQty", "pendingTimeInForce", "pendingStrategyId", "pendingStrategyType", "recvWindow", "timestamp"], "newOrderListOTO");
  }
  
  
  /** New Order List - OTOCO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-order-list-otoco-trade}
   * 
   * Place an OTOCO.
   * 
   * EndPoint: /api/v3/orderList/otoco
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {string} listClientOrderId  -  Arbitrary unique ID among open order lists. Automatically generated if not sent. A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired.  listClientOrderId is distinct from the workingClientOrderId, pendingAboveClientOrderId, and the pendingBelowClientOrderId.
   * @param {OrderResponseType} newOrderRespType  -  Format the JSON response. Supported values: ACK, FULL, RESPONSE
   * @param {ENUM} selfTradePreventionMode  -  The allowed values are dependent on what is configured on the symbol.
   * @param {WorkingType} workingType  -  Supported values: LIMIT, LIMIT_MAKER
   * @param {ENUM} workingSide  -  Supported values: BUY, SELL
   * @param {string} workingClientOrderId  -  Arbitrary unique ID among open orders for the working order. Automatically generated if not sent.
   * @param {DECIMAL} workingPrice
   * @param {DECIMAL} workingQuantity
   * @param {DECIMAL} workingIcebergQty  -  This can only be used if workingTimeInForce is GTC or if workingType is LIMIT_MAKER.
   * @param {ENUM} workingTimeInForce  -  Supported values: GTC, IOC, FOK
   * @param {INT} workingStrategyId  -  Arbitrary numeric value identifying the working order within an order strategy.
   * @param {INT} workingStrategyType  -  Arbitrary numeric value identifying the working order strategy.  Values smaller than 1000000 are reserved and cannot be used.
   * @param {ENUM} pendingSide  -  Supported values: BUY, SELL
   * @param {DECIMAL} pendingQuantity
   * @param {ENUM} pendingAboveType  -  Supported values: LIMIT_MAKER, STOP_LOSS, and STOP_LOSS_LIMIT
   * @param {string} pendingAboveClientOrderId  -  Arbitrary unique ID among open orders for the pending above order. Automatically generated if not sent.
   * @param {DECIMAL} pendingAbovePrice
   * @param {DECIMAL} pendingAboveStopPrice
   * @param {DECIMAL} pendingAboveTrailingDelta
   * @param {DECIMAL} pendingAboveIcebergQty  -  This can only be used if pendingAboveTimeInForce is GTC or if pendingAboveType is LIMIT_MAKER.
   * @param {ENUM} pendingAboveTimeInForce
   * @param {INT} pendingAboveStrategyId  -  Arbitrary numeric value identifying the pending above order within an order strategy.
   * @param {INT} pendingAboveStrategyType  -  Arbitrary numeric value identifying the pending above order strategy.  Values smaller than 1000000 are reserved and cannot be used.
   * @param {ENUM} pendingBelowType  -  Supported values: LIMIT_MAKER, STOP_LOSS, and STOP_LOSS_LIMIT
   * @param {string} pendingBelowClientOrderId  -  Arbitrary unique ID among open orders for the pending below order. Automatically generated if not sent.
   * @param {DECIMAL} pendingBelowPrice
   * @param {DECIMAL} pendingBelowStopPrice
   * @param {DECIMAL} pendingBelowTrailingDelta
   * @param {DECIMAL} pendingBelowIcebergQty  -  This can only be used if pendingBelowTimeInForce is GTC or if pendingBelowType is LIMIT_MAKER.
   * @param {ENUM} pendingBelowTimeInForce
   * @param {INT} pendingBelowStrategyId  -  Arbitrary numeric value identifying the pending below order within an order strategy.
   * @param {INT} pendingBelowStrategyType  -  Arbitrary numeric value identifying the pending below order strategy.  Values smaller than 1000000 are reserved and cannot be used.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000.
   * @param {LONG} timestamp
   */
  newOrderListOTOCO(symbol :string, listClientOrderId :string|undefined, newOrderRespType :OrderResponseType|undefined, selfTradePreventionMode :ENUM|undefined, workingType :WorkingType, workingSide :ENUM, workingClientOrderId :string|undefined, workingPrice :DECIMAL, workingQuantity :DECIMAL, workingIcebergQty :DECIMAL|undefined, workingTimeInForce :ENUM|undefined, workingStrategyId :INT|undefined, workingStrategyType :INT|undefined, pendingSide :ENUM, pendingQuantity :DECIMAL, pendingAboveType :ENUM, pendingAboveClientOrderId? :string, pendingAbovePrice? :DECIMAL, pendingAboveStopPrice? :DECIMAL, pendingAboveTrailingDelta? :DECIMAL, pendingAboveIcebergQty? :DECIMAL, pendingAboveTimeInForce? :ENUM, pendingAboveStrategyId? :INT, pendingAboveStrategyType? :INT, pendingBelowType? :ENUM, pendingBelowClientOrderId? :string, pendingBelowPrice? :DECIMAL, pendingBelowStopPrice? :DECIMAL, pendingBelowTrailingDelta? :DECIMAL, pendingBelowIcebergQty? :DECIMAL, pendingBelowTimeInForce? :ENUM, pendingBelowStrategyId? :INT, pendingBelowStrategyType? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["newOrderListOTOCO"]>;
  
  
  /** New Order List - OTOCO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-order-list-otoco-trade}
   * 
   * Place an OTOCO.
   * 
   * EndPoint: /api/v3/orderList/otoco
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {string} options.listClientOrderId  -  Arbitrary unique ID among open order lists. Automatically generated if not sent. A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired.  listClientOrderId is distinct from the workingClientOrderId, pendingAboveClientOrderId, and the pendingBelowClientOrderId.
   * @param {OrderResponseType} options.newOrderRespType  -  Format the JSON response. Supported values: ACK, FULL, RESPONSE
   * @param {ENUM} options.selfTradePreventionMode  -  The allowed values are dependent on what is configured on the symbol.
   * @param {WorkingType} options.workingType  -  Supported values: LIMIT, LIMIT_MAKER
   * @param {ENUM} options.workingSide  -  Supported values: BUY, SELL
   * @param {string} options.workingClientOrderId  -  Arbitrary unique ID among open orders for the working order. Automatically generated if not sent.
   * @param {DECIMAL} options.workingPrice
   * @param {DECIMAL} options.workingQuantity
   * @param {DECIMAL} options.workingIcebergQty  -  This can only be used if workingTimeInForce is GTC or if workingType is LIMIT_MAKER.
   * @param {ENUM} options.workingTimeInForce  -  Supported values: GTC, IOC, FOK
   * @param {INT} options.workingStrategyId  -  Arbitrary numeric value identifying the working order within an order strategy.
   * @param {INT} options.workingStrategyType  -  Arbitrary numeric value identifying the working order strategy.  Values smaller than 1000000 are reserved and cannot be used.
   * @param {ENUM} options.pendingSide  -  Supported values: BUY, SELL
   * @param {DECIMAL} options.pendingQuantity
   * @param {ENUM} options.pendingAboveType  -  Supported values: LIMIT_MAKER, STOP_LOSS, and STOP_LOSS_LIMIT
   * @param {string} options.pendingAboveClientOrderId  -  Arbitrary unique ID among open orders for the pending above order. Automatically generated if not sent.
   * @param {DECIMAL} options.pendingAbovePrice
   * @param {DECIMAL} options.pendingAboveStopPrice
   * @param {DECIMAL} options.pendingAboveTrailingDelta
   * @param {DECIMAL} options.pendingAboveIcebergQty  -  This can only be used if pendingAboveTimeInForce is GTC or if pendingAboveType is LIMIT_MAKER.
   * @param {ENUM} options.pendingAboveTimeInForce
   * @param {INT} options.pendingAboveStrategyId  -  Arbitrary numeric value identifying the pending above order within an order strategy.
   * @param {INT} options.pendingAboveStrategyType  -  Arbitrary numeric value identifying the pending above order strategy.  Values smaller than 1000000 are reserved and cannot be used.
   * @param {ENUM} options.pendingBelowType  -  Supported values: LIMIT_MAKER, STOP_LOSS, and STOP_LOSS_LIMIT
   * @param {string} options.pendingBelowClientOrderId  -  Arbitrary unique ID among open orders for the pending below order. Automatically generated if not sent.
   * @param {DECIMAL} options.pendingBelowPrice
   * @param {DECIMAL} options.pendingBelowStopPrice
   * @param {DECIMAL} options.pendingBelowTrailingDelta
   * @param {DECIMAL} options.pendingBelowIcebergQty  -  This can only be used if pendingBelowTimeInForce is GTC or if pendingBelowType is LIMIT_MAKER.
   * @param {ENUM} options.pendingBelowTimeInForce
   * @param {INT} options.pendingBelowStrategyId  -  Arbitrary numeric value identifying the pending below order within an order strategy.
   * @param {INT} options.pendingBelowStrategyType  -  Arbitrary numeric value identifying the pending below order strategy.  Values smaller than 1000000 are reserved and cannot be used.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000.
   * @param {LONG} options.timestamp
   */
  newOrderListOTOCO(options : { symbol :string, listClientOrderId? :string, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, workingType :WorkingType, workingSide :ENUM, workingClientOrderId? :string, workingPrice :DECIMAL, workingQuantity :DECIMAL, workingIcebergQty? :DECIMAL, workingTimeInForce? :ENUM, workingStrategyId? :INT, workingStrategyType? :INT, pendingSide :ENUM, pendingQuantity :DECIMAL, pendingAboveType :ENUM, pendingAboveClientOrderId? :string, pendingAbovePrice? :DECIMAL, pendingAboveStopPrice? :DECIMAL, pendingAboveTrailingDelta? :DECIMAL, pendingAboveIcebergQty? :DECIMAL, pendingAboveTimeInForce? :ENUM, pendingAboveStrategyId? :INT, pendingAboveStrategyType? :INT, pendingBelowType? :ENUM, pendingBelowClientOrderId? :string, pendingBelowPrice? :DECIMAL, pendingBelowStopPrice? :DECIMAL, pendingBelowTrailingDelta? :DECIMAL, pendingBelowIcebergQty? :DECIMAL, pendingBelowTimeInForce? :ENUM, pendingBelowStrategyId? :INT, pendingBelowStrategyType? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 1
     contingencyType: string,  // example: "OTO"
     listStatusType: OCOStatus,  // example: "EXEC_STARTED"
     listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
     listClientOrderId: string,  // example: "RumwQpBaDctlUu5jyG5rs0"
     transactionTime: number,  // example: 1712291372842
     symbol: string,  // example: "ABCDEF"
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 6
         clientOrderId: string  // example: "fM9Y4m23IFJVCQmIrlUmMK"
       }[],
     orderReports: (
       {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 6
         orderListId: number,  // example: 1
         clientOrderId: string,  // example: "fM9Y4m23IFJVCQmIrlUmMK"
         transactTime: number,  // example: 1712291372842
         price: NumberString,  // example: "1.00000000"
         origQty: NumberString,  // example: "1.00000000"
         executedQty: NumberString,  // example: "0.00000000"
         cummulativeQuoteQty: NumberString,  // example: "0.00000000"
         status: string,  // example: "NEW"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "LIMIT"
         side: OrderSide,  // example: "SELL"
         workingTime: number,  // example: 1712291372842
         selfTradePreventionMode: string  // example: "NONE"
       } |
       {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 7
         orderListId: number,  // example: 1
         clientOrderId: string,  // example: "6pcQbFIzTXGZQ1e2MkGDq4"
         transactTime: number,  // example: 1712291372842
         price: NumberString,  // example: "1.00000000"
         origQty: NumberString,  // example: "5.00000000"
         executedQty: NumberString,  // example: "0.00000000"
         cummulativeQuoteQty: NumberString,  // example: "0.00000000"
         status: string,  // example: "PENDING_NEW"
         timeInForce: TimeInForce,  // example: "IOC"
         type: OrderType,  // example: "STOP_LOSS_LIMIT"
         side: OrderSide,  // example: "BUY"
         stopPrice: NumberString,  // example: "6.00000000"
         workingTime: number,  // example: -1
         selfTradePreventionMode: string  // example: "NONE"
       }
     )[]
    }>;
  
  
  newOrderListOTOCO(...args : any) {
      return this._sendRequest("/api/v3/orderList/otoco", "POST", "TRADE", false, args, ["symbol", "listClientOrderId", "newOrderRespType", "selfTradePreventionMode", "workingType", "workingSide", "workingClientOrderId", "workingPrice", "workingQuantity", "workingIcebergQty", "workingTimeInForce", "workingStrategyId", "workingStrategyType", "pendingSide", "pendingQuantity", "pendingAboveType", "pendingAboveClientOrderId", "pendingAbovePrice", "pendingAboveStopPrice", "pendingAboveTrailingDelta", "pendingAboveIcebergQty", "pendingAboveTimeInForce", "pendingAboveStrategyId", "pendingAboveStrategyType", "pendingBelowType", "pendingBelowClientOrderId", "pendingBelowPrice", "pendingBelowStopPrice", "pendingBelowTrailingDelta", "pendingBelowIcebergQty", "pendingBelowTimeInForce", "pendingBelowStrategyId", "pendingBelowStrategyType", "recvWindow", "timestamp"], "newOrderListOTOCO");
  }
  
  
  /** Cancel Order lists (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-order-lists-trade}
   * 
   * Cancel an entire Order List.
   * 
   * EndPoint: /api/v3/orderList
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} orderListId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} listClientOrderId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  cancelOrderLists(symbol :string, orderListId? :LONG, listClientOrderId? :string, newClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["cancelOrderLists"]>;
  
  
  /** Cancel Order lists (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-order-lists-trade}
   * 
   * Cancel an entire Order List.
   * 
   * EndPoint: /api/v3/orderList
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderListId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} options.listClientOrderId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} options.newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  cancelOrderLists(options : { symbol :string, orderListId? :LONG, listClientOrderId? :string, newClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 0
     contingencyType: string,  // example: "OCO"
     listStatusType: OCOStatus,  // example: "ALL_DONE"
     listOrderStatus: OCOOrderStatus,  // example: "ALL_DONE"
     listClientOrderId: string,  // example: "C3wyj4WVEktd7u9aVBRXcN"
     transactionTime: number,  // example: 1574040868128
     symbol: string,  // example: "LTCBTC"
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 2
         clientOrderId: string  // example: "pO9ufTiFGg3nw2fOdgeOXa"
       }[],
     orderReports: (
       {
         symbol: string,  // example: "LTCBTC"
         origClientOrderId: string,  // example: "pO9ufTiFGg3nw2fOdgeOXa"
         orderId: number,  // example: 2
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "unfWT8ig8i0uj6lPuYLez6"
         transactTime: number,  // example: 1688005070874
         price: NumberString,  // example: "1.00000000"
         origQty: NumberString,  // example: "10.00000000"
         executedQty: NumberString,  // example: "0.00000000"
         cummulativeQuoteQty: NumberString,  // example: "0.00000000"
         status: string,  // example: "CANCELED"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "STOP_LOSS_LIMIT"
         side: OrderSide,  // example: "SELL"
         stopPrice: NumberString,  // example: "1.00000000"
         selfTradePreventionMode: string  // example: "NONE"
       } |
       {
         symbol: string,  // example: "LTCBTC"
         origClientOrderId: string,  // example: "TXOvglzXuaubXAaENpaRCB"
         orderId: number,  // example: 3
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "unfWT8ig8i0uj6lPuYLez6"
         transactTime: number,  // example: 1688005070874
         price: NumberString,  // example: "3.00000000"
         origQty: NumberString,  // example: "10.00000000"
         executedQty: NumberString,  // example: "0.00000000"
         cummulativeQuoteQty: NumberString,  // example: "0.00000000"
         status: string,  // example: "CANCELED"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "LIMIT_MAKER"
         side: OrderSide,  // example: "SELL"
         selfTradePreventionMode: string  // example: "NONE"
       }
     )[]
    }>;
  
  
  cancelOrderLists(...args : any) {
      return this._sendRequest("/api/v3/orderList", "DELETE", "TRADE", false, args, ["symbol", "orderListId", "listClientOrderId", "newClientOrderId", "recvWindow", "timestamp"], "cancelOrderLists");
  }
  
  
  /** Query Order lists (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-order-lists-user_data}
   * 
   * Retrieves a specific Order list based on provided optional parameters
   * 
   * EndPoint: /api/v3/orderList
   * 
   * Weight(IP): 4
   * 
   * @param {LONG} orderListId  -  Either orderListId or origClientOrderId must be provided
   * @param {string} origClientOrderId  -  Either orderListId or origClientOrderId must be provided
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryOrderLists(orderListId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryOrderLists"]>;
  
  
  /** Query Order lists (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-order-lists-user_data}
   * 
   * Retrieves a specific Order list based on provided optional parameters
   * 
   * EndPoint: /api/v3/orderList
   * 
   * Weight(IP): 4
   * 
   * @param {LONG} options.orderListId  -  Either orderListId or origClientOrderId must be provided
   * @param {string} options.origClientOrderId  -  Either orderListId or origClientOrderId must be provided
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryOrderLists(options? : { orderListId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 27
     contingencyType: string,  // example: "OCO"
     listStatusType: OCOStatus,  // example: "EXEC_STARTED"
     listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
     listClientOrderId: string,  // example: "h2USkA5YQpaXHPIrkd96xE"
     transactionTime: number,  // example: 1565245656253
     symbol: string,  // example: "LTCBTC"
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 4
         clientOrderId: string  // example: "qD1gy3kc3Gx0rihm9Y3xwS"
       }[]
    }>;
  
  
  queryOrderLists(...args : any) {
      return this._sendRequest("/api/v3/orderList", "GET", "USER_DATA", false, args, ["orderListId", "origClientOrderId", "recvWindow", "timestamp"], "queryOrderLists");
  }
  
  
  /** Query all Order lists (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-all-order-lists-user_data}
   * 
   * Retrieves all Order lists based on provided optional parameters
   * 
   * EndPoint: /api/v3/allOrderList
   * 
   * Weight(IP): 20
   * 
   * @param {LONG} fromId  -  If supplied, neither startTime or endTime can be provided
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default Value: 500; Max Value: 1000
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryAllOrderLists(fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryAllOrderLists"]>;
  
  
  /** Query all Order lists (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-all-order-lists-user_data}
   * 
   * Retrieves all Order lists based on provided optional parameters
   * 
   * EndPoint: /api/v3/allOrderList
   * 
   * Weight(IP): 20
   * 
   * @param {LONG} options.fromId  -  If supplied, neither startTime or endTime can be provided
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default Value: 500; Max Value: 1000
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryAllOrderLists(options? : { fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderListId: number,  // example: 29
       contingencyType: string,  // example: "OCO"
       listStatusType: OCOStatus,  // example: "EXEC_STARTED"
       listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
       listClientOrderId: string,  // example: "amEEAXryFzFwYF1FeRpUoZ"
       transactionTime: number,  // example: 1565245913483
       symbol: string,  // example: "LTCBTC"
       orders: {
           symbol: string,  // example: "LTCBTC"
           orderId: number,  // example: 4
           clientOrderId: string  // example: "oD7aesZqjEGlZrbtRpy5zB"
         }[]
     }[]>;
  
  
  queryAllOrderLists(...args : any) {
      return this._sendRequest("/api/v3/allOrderList", "GET", "USER_DATA", false, args, ["fromId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "queryAllOrderLists");
  }
  
  
  /** Query Open Order lists (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-open-order-lists-user_data}
   * 
   * EndPoint: /api/v3/openOrderList
   * 
   * Weight(IP): 6
   * 
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryOpenOrderLists(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["queryOpenOrderLists"]>;
  
  
  /** Query Open Order lists (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-open-order-lists-user_data}
   * 
   * EndPoint: /api/v3/openOrderList
   * 
   * Weight(IP): 6
   * 
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryOpenOrderLists(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderListId: number,  // example: 31
       contingencyType: string,  // example: "OCO"
       listStatusType: OCOStatus,  // example: "EXEC_STARTED"
       listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
       listClientOrderId: string,  // example: "wuB13fmulKj3YjdqWEcsnp"
       transactionTime: number,  // example: 1565246080644
       symbol: string,  // example: "LTCBTC"
       orders: {
           symbol: string,  // example: "LTCBTC"
           orderId: number,  // example: 4
           clientOrderId: string  // example: "r3EH2N76dHfLoSZWIUw1bT"
         }[]
     }[]>;
  
  
  queryOpenOrderLists(...args : any) {
      return this._sendRequest("/api/v3/openOrderList", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryOpenOrderLists");
  }
  
  
  /** New order using SOR (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-order-using-sor-trade}
   * 
   * Places an order using smart order routing (SOR).
   * 
   * EndPoint: /api/v3/sor/order
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {OrderType} type
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity
   * @param {DECIMAL} price
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Orders with the same newClientOrderID can be accepted only when the previous one is filled, otherwise the order will be rejected.
   * @param {INT} strategyId
   * @param {INT} strategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} icebergQty  -  Used with LIMIT to create an iceberg order.
   * @param {OrderResponseType} newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL. Default to FULL
   * @param {ENUM} selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  newOrderUsingSOR(symbol :string, side :OrderSide, type :OrderType, timeInForce :TimeInForce|undefined, quantity :DECIMAL, price? :DECIMAL, newClientOrderId? :string, strategyId? :INT, strategyType? :INT, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["newOrderUsingSOR"]>;
  
  
  /** New order using SOR (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-order-using-sor-trade}
   * 
   * Places an order using smart order routing (SOR).
   * 
   * EndPoint: /api/v3/sor/order
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {OrderType} options.type
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity
   * @param {DECIMAL} options.price
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Orders with the same newClientOrderID can be accepted only when the previous one is filled, otherwise the order will be rejected.
   * @param {INT} options.strategyId
   * @param {INT} options.strategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} options.icebergQty  -  Used with LIMIT to create an iceberg order.
   * @param {OrderResponseType} options.newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL. Default to FULL
   * @param {ENUM} options.selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  newOrderUsingSOR(options : { symbol :string, side :OrderSide, type :OrderType, timeInForce? :TimeInForce, quantity :DECIMAL, price? :DECIMAL, newClientOrderId? :string, strategyId? :INT, strategyType? :INT, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     orderId: number,  // example: 2
     orderListId: number,  // example: -1
     clientOrderId: string,  // example: "sBI1KM6nNtOfj5tccZSKly"
     transactTime: number,  // example: 1689149087774
     price: NumberString,  // example: "31000.00000000"
     origQty: NumberString,  // example: "0.50000000"
     executedQty: NumberString,  // example: "0.50000000"
     cummulativeQuoteQty: NumberString,  // example: "14000.00000000"
     status: string,  // example: "FILLED"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     side: OrderSide,  // example: "BUY"
     workingTime: number,  // example: 1689149087774
     fills: {
         matchType: string,  // example: "ONE_PARTY_TRADE_REPORT"
         price: NumberString,  // example: "28000.00000000"
         qty: NumberString,  // example: "0.50000000"
         commission: NumberString,  // example: "0.00000000"
         commissionAsset: string,  // example: "BTC"
         tradeId: number,  // example: -1
         allocId: number  // example: 0
       }[],
     workingFloor: WorkingFloor,  // example: "SOR"
     selfTradePreventionMode: string,  // example: "NONE"
     usedSor: boolean  // example: true
    }>;
  
  
  newOrderUsingSOR(...args : any) {
      return this._sendRequest("/api/v3/sor/order", "POST", "TRADE", false, args, ["symbol", "side", "type", "timeInForce", "quantity", "price", "newClientOrderId", "strategyId", "strategyType", "icebergQty", "newOrderRespType", "selfTradePreventionMode", "recvWindow", "timestamp"], "newOrderUsingSOR");
  }
  
  
  /** Test new order using SOR (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#test-new-order-using-sor-trade}
   * 
   * Test new order creation and signature/recvWindow using smart order routing (SOR).
   * Creates and validates a new order but does not send it into the matching engine.
   * 
   * EndPoint: /api/v3/sor/order/test
   * 
   * Weight(IP): 
   *   Condition                      Request Weight
   *   Without computeCommissionRates 1             
   *   With computeCommissionRates    20            
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {OrderType} type
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity
   * @param {DECIMAL} price
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Orders with the same newClientOrderID can be accepted only when the previous one is filled, otherwise the order will be rejected.
   * @param {INT} strategyId
   * @param {INT} strategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} icebergQty  -  Used with LIMIT to create an iceberg order.
   * @param {OrderResponseType} newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL. Default to FULL
   * @param {ENUM} selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   * @param {boolean} computeCommissionRates  -  Default: false
   */
  testNewOrderUsingSOR(symbol :string, side :OrderSide, type :OrderType, timeInForce :TimeInForce|undefined, quantity :DECIMAL, price? :DECIMAL, newClientOrderId? :string, strategyId? :INT, strategyType? :INT, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, recvWindow? :LONG, timestamp? :LONG, computeCommissionRates? :boolean)
  : ReturnType<MyBinanceClient["testNewOrderUsingSOR"]>;
  
  
  /** Test new order using SOR (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#test-new-order-using-sor-trade}
   * 
   * Test new order creation and signature/recvWindow using smart order routing (SOR).
   * Creates and validates a new order but does not send it into the matching engine.
   * 
   * EndPoint: /api/v3/sor/order/test
   * 
   * Weight(IP): 
   *   Condition                      Request Weight
   *   Without computeCommissionRates 1             
   *   With computeCommissionRates    20            
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {OrderType} options.type
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity
   * @param {DECIMAL} options.price
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Orders with the same newClientOrderID can be accepted only when the previous one is filled, otherwise the order will be rejected.
   * @param {INT} options.strategyId
   * @param {INT} options.strategyType  -  The value cannot be less than 1000000.
   * @param {DECIMAL} options.icebergQty  -  Used with LIMIT to create an iceberg order.
   * @param {OrderResponseType} options.newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL. Default to FULL
   * @param {ENUM} options.selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   * @param {boolean} options.computeCommissionRates  -  Default: false
   */
  testNewOrderUsingSOR(options : { symbol :string, side :OrderSide, type :OrderType, timeInForce? :TimeInForce, quantity :DECIMAL, price? :DECIMAL, newClientOrderId? :string, strategyId? :INT, strategyType? :INT, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, selfTradePreventionMode? :ENUM, recvWindow? :LONG, timestamp? :LONG, computeCommissionRates? :boolean })
  : Promise<{
    } | {
     standardCommissionForOrder: {
       maker: NumberString,  // example: "0.00000112"
       taker: NumberString  // example: "0.00000114"
     },
     taxCommissionForOrder: {
       maker: NumberString,  // example: "0.00000112"
       taker: NumberString  // example: "0.00000114"
     },
     discount: {
       enabledForAccount: boolean,  // example: true
       enabledForSymbol: boolean,  // example: true
       discountAsset: string,  // example: "BNB"
       discount: NumberString  // example: "0.25000000"  //Standard commission is reduced by this rate when paying commission in BNB.
     }
    }>;
  
  
  testNewOrderUsingSOR(...args : any) {
      return this._sendRequest("/api/v3/sor/order/test", "POST", "TRADE", false, args, ["symbol", "side", "type", "timeInForce", "quantity", "price", "newClientOrderId", "strategyId", "strategyType", "icebergQty", "newOrderRespType", "selfTradePreventionMode", "recvWindow", "timestamp", "computeCommissionRates"], "testNewOrderUsingSOR");
  }
  
  
  
  //***** Spot Account Endpoints *****
  
  
  /** Account Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-information-user_data}
   * 
   * Get current account information.
   * 
   * EndPoint: /api/v3/account
   * 
   * Weight(IP): 20
   * 
   * @param {boolean} omitZeroBalances  -  When set to true, emits only the non-zero balances of an account. Default value: false
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  accountInformation(omitZeroBalances? :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["accountInformation"]>;
  
  
  /** Account Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-information-user_data}
   * 
   * Get current account information.
   * 
   * EndPoint: /api/v3/account
   * 
   * Weight(IP): 20
   * 
   * @param {boolean} options.omitZeroBalances  -  When set to true, emits only the non-zero balances of an account. Default value: false
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  accountInformation(options? : { omitZeroBalances? :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     makerCommission: number,  // example: 15
     takerCommission: number,  // example: 15
     buyerCommission: number,  // example: 0
     sellerCommission: number,  // example: 0
     commissionRates: {
       maker: NumberString,  // example: "0.00150000"
       taker: NumberString,  // example: "0.00150000"
       buyer: NumberString,  // example: "0.00000000"
       seller: NumberString  // example: "0.00000000"
     },
     canTrade: boolean,  // example: true
     canWithdraw: boolean,  // example: true
     canDeposit: boolean,  // example: true
     brokered: boolean,  // example: false
     requireSelfTradePrevention: boolean,  // example: false
     preventSor: boolean,  // example: false
     updateTime: number,  // example: 123456789
     accountType: string,  // example: "SPOT"
     balances: {
         asset: string,  // example: "BTC"
         free: NumberString,  // example: "4723846.89208129"
         locked: NumberString  // example: "0.00000000"
       }[],
     permissions: Permission[]  // example: "SPOT",
     uid: number  // example: 354937868
    }>;
  
  
  accountInformation(...args : any) {
      return this._sendRequest("/api/v3/account", "GET", "USER_DATA", false, args, ["omitZeroBalances", "recvWindow", "timestamp"], "accountInformation");
  }
  
  
  /** Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-trade-list-user_data}
   * 
   * Get trades for a specific account and symbol.
   * 
   * EndPoint: /api/v3/myTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol
   * @param {LONG} orderId  -  This can only be used in combination with symbol.
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} fromId  -  TradeId to fetch from. Default gets most recent trades.
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  accountTradeList(symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["accountTradeList"]>;
  
  
  /** Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-trade-list-user_data}
   * 
   * Get trades for a specific account and symbol.
   * 
   * EndPoint: /api/v3/myTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId  -  This can only be used in combination with symbol.
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.fromId  -  TradeId to fetch from. Default gets most recent trades.
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  accountTradeList(options : { symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BNBBTC"
       id: number,  // example: 28457
       orderId: number,  // example: 100234
       orderListId: number,  // example: -1  //Unless an order list, the value will always be -1
       price: NumberString,  // example: "4.00000100"
       qty: NumberString,  // example: "12.00000000"
       quoteQty: NumberString,  // example: "48.000012"
       commission: NumberString,  // example: "10.10000000"
       commissionAsset: string,  // example: "BNB"
       time: number,  // example: 1499865549590
       isBuyer: boolean,  // example: true
       isMaker: boolean,  // example: false
       isBestMatch: boolean  // example: true
     }[]>;
  
  
  accountTradeList(...args : any) {
      return this._sendRequest("/api/v3/myTrades", "GET", "USER_DATA", false, args, ["symbol", "orderId", "startTime", "endTime", "fromId", "limit", "recvWindow", "timestamp"], "accountTradeList");
  }
  
  
  /** Query Unfilled Order Count (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-unfilled-order-count-user_data}
   * 
   * Displays the user's unfilled order count for all intervals.
   * 
   * EndPoint: /api/v3/rateLimit/order
   * 
   * Weight(IP): 40
   * 
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryUnfilledOrderCount(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["queryUnfilledOrderCount"]>;
  
  
  /** Query Unfilled Order Count (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-unfilled-order-count-user_data}
   * 
   * Displays the user's unfilled order count for all intervals.
   * 
   * EndPoint: /api/v3/rateLimit/order
   * 
   * Weight(IP): 40
   * 
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryUnfilledOrderCount(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       rateLimitType: RateLimitType,  // example: "ORDERS"
       interval: RateLimitInterval,  // example: "SECOND"
       intervalNum: number,  // example: 10
       limit: number,  // example: 10000
       count: number  // example: 0
     }[]>;
  
  
  queryUnfilledOrderCount(...args : any) {
      return this._sendRequest("/api/v3/rateLimit/order", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryUnfilledOrderCount");
  }
  
  
  /** Query Prevented Matches (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-prevented-matches-user_data}
   * 
   * Displays the list of orders that were expired because of STP.
   * 
   * EndPoint: /api/v3/myPreventedMatches
   * 
   * Weight(IP): By parameters:
   *   Case                         Weight
   *   If symbol is invalid         2     
   *   Querying by preventedMatchId 2     
   *   Querying by orderId          20    
   * 
   * @param {string} symbol
   * @param {LONG} preventedMatchId
   * @param {LONG} orderId
   * @param {LONG} fromPreventedMatchId
   * @param {INT} limit  -  Default: 500; Max: 1000
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryPreventedMatches(symbol :string, preventedMatchId? :LONG, orderId? :LONG, fromPreventedMatchId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryPreventedMatches"]>;
  
  
  /** Query Prevented Matches (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-prevented-matches-user_data}
   * 
   * Displays the list of orders that were expired because of STP.
   * 
   * EndPoint: /api/v3/myPreventedMatches
   * 
   * Weight(IP): By parameters:
   *   Case                         Weight
   *   If symbol is invalid         2     
   *   Querying by preventedMatchId 2     
   *   Querying by orderId          20    
   * 
   * @param {string} options.symbol
   * @param {LONG} options.preventedMatchId
   * @param {LONG} options.orderId
   * @param {LONG} options.fromPreventedMatchId
   * @param {INT} options.limit  -  Default: 500; Max: 1000
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryPreventedMatches(options : { symbol :string, preventedMatchId? :LONG, orderId? :LONG, fromPreventedMatchId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       preventedMatchId: number,  // example: 1
       takerOrderId: number,  // example: 5
       makerOrderId: number,  // example: 3
       tradeGroupId: number,  // example: 1
       selfTradePreventionMode: string,  // example: "EXPIRE_MAKER"
       price: NumberString,  // example: "1.100000"
       makerPreventedQuantity: NumberString,  // example: "1.300000"
       transactTime: number  // example: 1669101687094
     }[]>;
  
  
  queryPreventedMatches(...args : any) {
      return this._sendRequest("/api/v3/myPreventedMatches", "GET", "USER_DATA", false, args, ["symbol", "preventedMatchId", "orderId", "fromPreventedMatchId", "limit", "recvWindow", "timestamp"], "queryPreventedMatches");
  }
  
  
  /** Query Allocations (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-allocations-user_data}
   * 
   * Retrieves allocations resulting from SOR order placement.
   * 
   * EndPoint: /api/v3/myAllocations
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} fromAllocationId
   * @param {INT} limit  -  Default 500;Max 1000
   * @param {LONG} orderId
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000.
   * @param {LONG} timestamp
   */
  queryAllocations(symbol :string, startTime? :LONG, endTime? :LONG, fromAllocationId? :INT, limit? :INT, orderId? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryAllocations"]>;
  
  
  /** Query Allocations (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-allocations-user_data}
   * 
   * Retrieves allocations resulting from SOR order placement.
   * 
   * EndPoint: /api/v3/myAllocations
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.fromAllocationId
   * @param {INT} options.limit  -  Default 500;Max 1000
   * @param {LONG} options.orderId
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000.
   * @param {LONG} options.timestamp
   */
  queryAllocations(options : { symbol :string, startTime? :LONG, endTime? :LONG, fromAllocationId? :INT, limit? :INT, orderId? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       allocationId: number,  // example: 0
       allocationType: string,  // example: "SOR"
       orderId: number,  // example: 1
       orderListId: number,  // example: -1
       price: NumberString,  // example: "1.00000000"
       qty: NumberString,  // example: "5.00000000"
       quoteQty: NumberString,  // example: "5.00000000"
       commission: NumberString,  // example: "0.00000000"
       commissionAsset: string,  // example: "BTC"
       time: number,  // example: 1687506878118
       isBuyer: boolean,  // example: true
       isMaker: boolean,  // example: false
       isAllocator: boolean  // example: false
     }[]>;
  
  
  queryAllocations(...args : any) {
      return this._sendRequest("/api/v3/myAllocations", "GET", "USER_DATA", false, args, ["symbol", "startTime", "endTime", "fromAllocationId", "limit", "orderId", "recvWindow", "timestamp"], "queryAllocations");
  }
  
  
  /** Query Commission Rates (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-commission-rates-user_data}
   * 
   * Get current account commission rates.
   * 
   * EndPoint: /api/v3/account/commission
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol
   */
  queryCommissionRates(symbol :string)  : ReturnType<MyBinanceClient["queryCommissionRates"]>;
  
  
  /** Query Commission Rates (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-commission-rates-user_data}
   * 
   * Get current account commission rates.
   * 
   * EndPoint: /api/v3/account/commission
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol
   */
  queryCommissionRates(options : { symbol :string })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     standardCommission: {
       maker: NumberString,  // example: "0.00000010"
       taker: NumberString,  // example: "0.00000020"
       buyer: NumberString,  // example: "0.00000030"
       seller: NumberString  // example: "0.00000040"
     },
     taxCommission: {
       maker: NumberString,  // example: "0.00000112"
       taker: NumberString,  // example: "0.00000114"
       buyer: NumberString,  // example: "0.00000118"
       seller: NumberString  // example: "0.00000116"
     },
     discount: {
       enabledForAccount: boolean,  // example: true
       enabledForSymbol: boolean,  // example: true
       discountAsset: string,  // example: "BNB"
       discount: NumberString  // example: "0.75000000"  //Standard commission is reduced by this rate when paying commission in BNB.
     }
    }>;
  
  
  queryCommissionRates(...args : any) {
      return this._sendRequest("/api/v3/account/commission", "GET", "USER_DATA", false, args, ["symbol"], "queryCommissionRates");
  }
  
  
  
  //***** Margin Account/Trade *****
  
  
  /** Margin account borrow/repay(MARGIN)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-borrow-repay-margin}
   * 
   * Margin account borrow/repay(MARGIN)
   * 
   * EndPoint: /sapi/v1/margin/borrow-repay
   * 
   * Weight(UID): 1500
   * 
   * @param {string} asset
   * @param {string} isIsolated  -  TRUE for Isolated Margin, FALSE for Cross Margin, Default FALSE
   * @param {string} symbol  -  Only for Isolated margin
   * @param {string} amount
   * @param {string} type  -  BORROW or REPAY
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  marginAccountBorrowRepay(asset :string, isIsolated :string, symbol :string, amount :string, type :string, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["marginAccountBorrowRepay"]>;
  
  
  /** Margin account borrow/repay(MARGIN)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-borrow-repay-margin}
   * 
   * Margin account borrow/repay(MARGIN)
   * 
   * EndPoint: /sapi/v1/margin/borrow-repay
   * 
   * Weight(UID): 1500
   * 
   * @param {string} options.asset
   * @param {string} options.isIsolated  -  TRUE for Isolated Margin, FALSE for Cross Margin, Default FALSE
   * @param {string} options.symbol  -  Only for Isolated margin
   * @param {string} options.amount
   * @param {string} options.type  -  BORROW or REPAY
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  marginAccountBorrowRepay(options : { asset :string, isIsolated :string, symbol :string, amount :string, type :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     tranId: number  // example: 100000001
    }>;
  
  
  marginAccountBorrowRepay(...args : any) {
      return this._sendRequest("/sapi/v1/margin/borrow-repay", "POST", "MARGIN", false, args, ["asset", "isIsolated", "symbol", "amount", "type", "recvWindow", "timestamp"], "marginAccountBorrowRepay");
  }
  
  
  /** Query borrow/repay records in Margin account(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-borrow-repay-records-in-margin-account-user_data}
   * 
   * Query borrow/repay records in Margin account
   * 
   * EndPoint: /sapi/v1/margin/borrow-repay
   * 
   * Weight(IP): 10
   * 
   * @param {string} asset
   * @param {string} isolatedSymbol  -  Symbol in Isolated Margin
   * @param {LONG} txId  -  tranId in POST /sapi/v1/margin/loan
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Current querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10 Max:100
   * @param {string} type  -  BORROW or REPAY
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryBorrowRepayRecordsInMarginAccount(asset :string|undefined, isolatedSymbol :string|undefined, txId :LONG|undefined, startTime :LONG|undefined, endTime :LONG|undefined, current :LONG|undefined, size :LONG|undefined, type :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryBorrowRepayRecordsInMarginAccount"]>;
  
  
  /** Query borrow/repay records in Margin account(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-borrow-repay-records-in-margin-account-user_data}
   * 
   * Query borrow/repay records in Margin account
   * 
   * EndPoint: /sapi/v1/margin/borrow-repay
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.asset
   * @param {string} options.isolatedSymbol  -  Symbol in Isolated Margin
   * @param {LONG} options.txId  -  tranId in POST /sapi/v1/margin/loan
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Current querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {string} options.type  -  BORROW or REPAY
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryBorrowRepayRecordsInMarginAccount(options : { asset? :string, isolatedSymbol? :string, txId? :LONG, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, type :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         isolatedSymbol: string,  // example: "BNBUSDT"  // isolated symbol, will not be returned for crossed margin
         amount: NumberString,  // example: "14.00000000"  // Total amount borrowed/repaid
         asset: string,  // example: "BNB"
         interest: NumberString,  // example: "0.01866667"  // Interest repaid
         principal: NumberString,  // example: "13.98133333"  // Principal repaid
         status: string,  // example: "CONFIRMED"  //one of PENDING (pending execution), CONFIRMED (successfully execution), FAILED (execution failed, nothing happened to your account);
         timestamp: number,  // example: 1563438204000
         txId: number  // example: 2970933056
       }[],
     total: number  // example: 1
    }>;
  
  
  queryBorrowRepayRecordsInMarginAccount(...args : any) {
      return this._sendRequest("/sapi/v1/margin/borrow-repay", "GET", "USER_DATA", false, args, ["asset", "isolatedSymbol", "txId", "startTime", "endTime", "current", "size", "type", "recvWindow", "timestamp"], "queryBorrowRepayRecordsInMarginAccount");
  }
  
  
  /** Get All Margin Assets (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-all-margin-assets-market_data}
   * 
   * EndPoint: /sapi/v1/margin/allAssets
   * 
   * Weight(IP): 1
   * 
   * @param {string} asset
   */
  getAllMarginAssets(asset? :string)  : ReturnType<MyBinanceClient["getAllMarginAssets"]>;
  
  
  /** Get All Margin Assets (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-all-margin-assets-market_data}
   * 
   * EndPoint: /sapi/v1/margin/allAssets
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.asset
   */
  getAllMarginAssets(options? : { asset? :string })
  : Promise<{
       assetFullName: string,  // example: "USD coin"
       assetName: string,  // example: "USDC"
       isBorrowable: boolean,  // example: true
       isMortgageable: boolean,  // example: true
       userMinBorrow: NumberString,  // example: "0.00000000"
       userMinRepay: NumberString,  // example: "0.00000000"
       delistTime: number  // example: 1704973040
     }[]>;
  
  
  getAllMarginAssets(...args : any) {
      return this._sendRequest("/sapi/v1/margin/allAssets", "GET", "MARKET_DATA", false, args, ["asset"], "getAllMarginAssets");
  }
  
  
  /** Get All Cross Margin Pairs (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-all-cross-margin-pairs-market_data}
   * 
   * EndPoint: /sapi/v1/margin/allPairs
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   */
  getAllCrossMarginPairs(symbol? :string)  : ReturnType<MyBinanceClient["getAllCrossMarginPairs"]>;
  
  
  /** Get All Cross Margin Pairs (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-all-cross-margin-pairs-market_data}
   * 
   * EndPoint: /sapi/v1/margin/allPairs
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   */
  getAllCrossMarginPairs(options? : { symbol? :string })
  : Promise<(
     {
       base: string,  // example: "BNB"
       id: number,  // example: 351637150141315840
       isBuyAllowed: boolean,  // example: true
       isMarginTrade: boolean,  // example: true
       isSellAllowed: boolean,  // example: true
       quote: string,  // example: "BTC"
       symbol: string  // example: "BNBBTC"
     } |
     {
       base: string,  // example: "TRX"
       id: number,  // example: 351637923235429100
       isBuyAllowed: boolean,  // example: true
       isMarginTrade: boolean,  // example: true
       isSellAllowed: boolean,  // example: true
       quote: string,  // example: "BTC"
       symbol: string,  // example: "TRXBTC"
       delistTime: number  // example: 1704973040
     }
    )[]>;
  
  
  getAllCrossMarginPairs(...args : any) {
      return this._sendRequest("/sapi/v1/margin/allPairs", "GET", "MARKET_DATA", false, args, ["symbol"], "getAllCrossMarginPairs");
  }
  
  
  /** Query Margin PriceIndex (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-priceindex-market_data}
   * 
   * EndPoint: /sapi/v1/margin/priceIndex
   * 
   * Weight(IP): 10
   * 
   * @param {string} symbol
   */
  queryMarginPriceIndex(symbol :string)  : ReturnType<MyBinanceClient["queryMarginPriceIndex"]>;
  
  
  /** Query Margin PriceIndex (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-priceindex-market_data}
   * 
   * EndPoint: /sapi/v1/margin/priceIndex
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.symbol
   */
  queryMarginPriceIndex(options : { symbol :string })
  : Promise<{
     calcTime: number,  // example: 1562046418000
     price: NumberString,  // example: "0.00333930"
     symbol: string  // example: "BNBBTC"
    }>;
  
  
  queryMarginPriceIndex(...args : any) {
      return this._sendRequest("/sapi/v1/margin/priceIndex", "GET", "MARKET_DATA", false, args, ["symbol"], "queryMarginPriceIndex");
  }
  
  
  /** Margin Account New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-new-order-trade}
   * 
   * Post a new order for margin account.
   * 
   * EndPoint: /sapi/v1/margin/order
   * 
   * Weight(UID): 6
   * 
   * @param {string} symbol
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {OrderSide} side  -  BUYSELL
   * @param {OrderType} type
   * @param {DECIMAL} quantity
   * @param {DECIMAL} quoteOrderQty
   * @param {DECIMAL} price
   * @param {DECIMAL} stopPrice  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent.
   * @param {DECIMAL} icebergQty  -  Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {OrderResponseType} newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY"} sideEffectType  -  NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in FAQ
   * @param {"GTC"|"IOC"|"FOK"} timeInForce  -  GTC,IOC,FOK
   * @param {ENUM} selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
   * @param {boolean} autoRepayAtCancel  -  Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  marginAccountNewOrder(symbol :string, isIsolated :string|undefined, side :OrderSide, type :OrderType, quantity? :DECIMAL, quoteOrderQty? :DECIMAL, price? :DECIMAL, stopPrice? :DECIMAL, newClientOrderId? :string, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, sideEffectType? :"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY", timeInForce? :"GTC"|"IOC"|"FOK", selfTradePreventionMode? :ENUM, autoRepayAtCancel? :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["marginAccountNewOrder"]>;
  
  
  /** Margin Account New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-new-order-trade}
   * 
   * Post a new order for margin account.
   * 
   * EndPoint: /sapi/v1/margin/order
   * 
   * Weight(UID): 6
   * 
   * @param {string} options.symbol
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {OrderSide} options.side  -  BUYSELL
   * @param {OrderType} options.type
   * @param {DECIMAL} options.quantity
   * @param {DECIMAL} options.quoteOrderQty
   * @param {DECIMAL} options.price
   * @param {DECIMAL} options.stopPrice  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent.
   * @param {DECIMAL} options.icebergQty  -  Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
   * @param {OrderResponseType} options.newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY"} options.sideEffectType  -  NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in FAQ
   * @param {"GTC"|"IOC"|"FOK"} options.timeInForce  -  GTC,IOC,FOK
   * @param {ENUM} options.selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
   * @param {boolean} options.autoRepayAtCancel  -  Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  marginAccountNewOrder(options : { symbol :string, isIsolated? :string, side :OrderSide, type :OrderType, quantity? :DECIMAL, quoteOrderQty? :DECIMAL, price? :DECIMAL, stopPrice? :DECIMAL, newClientOrderId? :string, icebergQty? :DECIMAL, newOrderRespType? :OrderResponseType, sideEffectType? :"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY", timeInForce? :"GTC"|"IOC"|"FOK", selfTradePreventionMode? :ENUM, autoRepayAtCancel? :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  // ACK:
     symbol: string,  // example: "BTCUSDT"
     orderId: number,  // example: 28
     clientOrderId: string,  // example: "6gCrw2kRUAF9CvJDGP16IP"
     isIsolated: boolean,  // example: true  // if isolated margin
     transactTime: number  // example: 1507725176595
    } | {  // RESULT:
     symbol: string,  // example: "BTCUSDT"
     orderId: number,  // example: 28
     clientOrderId: string,  // example: "6gCrw2kRUAF9CvJDGP16IP"
     transactTime: number,  // example: 1507725176595
     price: NumberString,  // example: "1.00000000"
     origQty: NumberString,  // example: "10.00000000"
     executedQty: NumberString,  // example: "10.00000000"
     cummulativeQuoteQty: NumberString,  // example: "30000"
     status: string,  // example: "FILLED"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "MARKET"
     isIsolated: boolean,  // example: true  // if isolated margin
     side: OrderSide,  // example: "SELL"
     selfTradePreventionMode: string  // example: "NONE"
    } | {  // FULL:
     symbol: string,  // example: "BTCUSDT"
     orderId: number,  // example: 28
     clientOrderId: string,  // example: "6gCrw2kRUAF9CvJDGP16IP"
     transactTime: number,  // example: 1507725176595
     price: NumberString,  // example: "1.00000000"
     origQty: NumberString,  // example: "10.00000000"
     executedQty: NumberString,  // example: "10.00000000"
     cummulativeQuoteQty: NumberString,  // example: "39983.00000000"
     status: string,  // example: "FILLED"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "MARKET"
     side: OrderSide,  // example: "SELL"
     marginBuyBorrowAmount: number,  // example: 5  // will not return if no margin trade happens
     marginBuyBorrowAsset: string,  // example: "BTC"  // will not return if no margin trade happens
     isIsolated: boolean,  // example: true  // if isolated margin
     selfTradePreventionMode: string,  // example: "NONE"
     fills: {
         price: NumberString,  // example: "4000.00000000"
         qty: NumberString,  // example: "1.00000000"
         commission: NumberString,  // example: "4.00000000"
         commissionAsset: string  // example: "USDT"
       }[]
    }>;
  
  
  marginAccountNewOrder(...args : any) {
      return this._sendRequest("/sapi/v1/margin/order", "POST", "TRADE", false, args, ["symbol", "isIsolated", "side", "type", "quantity", "quoteOrderQty", "price", "stopPrice", "newClientOrderId", "icebergQty", "newOrderRespType", "sideEffectType", "timeInForce", "selfTradePreventionMode", "autoRepayAtCancel", "recvWindow", "timestamp"], "marginAccountNewOrder");
  }
  
  
  /** Margin Account Cancel Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-cancel-order-trade}
   * 
   * Cancel an active order for margin account.
   * 
   * EndPoint: /sapi/v1/margin/order
   * 
   * Weight(IP): 10
   * 
   * @param {string} symbol
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {string} newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  marginAccountCancelOrder(symbol :string, isIsolated? :string, orderId? :LONG, origClientOrderId? :string, newClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["marginAccountCancelOrder"]>;
  
  
  /** Margin Account Cancel Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-cancel-order-trade}
   * 
   * Cancel an active order for margin account.
   * 
   * EndPoint: /sapi/v1/margin/order
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.symbol
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {string} options.newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  marginAccountCancelOrder(options : { symbol :string, isIsolated? :string, orderId? :LONG, origClientOrderId? :string, newClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "LTCBTC"
     isIsolated: boolean,  // example: true  // if isolated margin
     orderId: NumberString,  // example: "28"
     origClientOrderId: string,  // example: "myOrder1"
     clientOrderId: string,  // example: "cancelMyOrder1"
     price: NumberString,  // example: "1.00000000"
     origQty: NumberString,  // example: "10.00000000"
     executedQty: NumberString,  // example: "8.00000000"
     cummulativeQuoteQty: NumberString,  // example: "8.00000000"
     status: string,  // example: "CANCELED"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     side: OrderSide  // example: "SELL"
    }>;
  
  
  marginAccountCancelOrder(...args : any) {
      return this._sendRequest("/sapi/v1/margin/order", "DELETE", "TRADE", false, args, ["symbol", "isIsolated", "orderId", "origClientOrderId", "newClientOrderId", "recvWindow", "timestamp"], "marginAccountCancelOrder");
  }
  
  
  /** Margin Account Cancel all Open Orders on a Symbol (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-cancel-all-open-orders-on-a-symbol-trade}
   * 
   * EndPoint: /sapi/v1/margin/openOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  marginAccountCancelAllOpenOrdersOnASymbol(symbol :string, isIsolated? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["marginAccountCancelAllOpenOrdersOnASymbol"]>;
  
  
  /** Margin Account Cancel all Open Orders on a Symbol (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-cancel-all-open-orders-on-a-symbol-trade}
   * 
   * EndPoint: /sapi/v1/margin/openOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  marginAccountCancelAllOpenOrdersOnASymbol(options : { symbol :string, isIsolated? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: "BTCUSDT"
       isIsolated: boolean,  // example: true  // if isolated margin
       origClientOrderId: string,  // example: "E6APeyTJvkMvLMYMqu1KQ4"
       orderId: number,  // example: 11
       orderListId: number,  // example: -1
       clientOrderId: string,  // example: "pXLV6Hz6mprAcVYpVMTGgx"
       price: NumberString,  // example: "0.089853"
       origQty: NumberString,  // example: "0.178622"
       executedQty: NumberString,  // example: "0.000000"
       cummulativeQuoteQty: NumberString,  // example: "0.000000"
       status: string,  // example: "CANCELED"
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       side: OrderSide,  // example: "BUY"
       selfTradePreventionMode: string  // example: "NONE"
     } |
     {
       orderListId: number,  // example: 1929
       contingencyType: string,  // example: "OCO"
       listStatusType: OCOStatus,  // example: "ALL_DONE"
       listOrderStatus: OCOOrderStatus,  // example: "ALL_DONE"
       listClientOrderId: string,  // example: "2inzWQdDvZLHbbAmAozX2N"
       transactionTime: number,  // example: 1585230948299
       symbol: string,  // example: "BTCUSDT"
       isIsolated: boolean,  // example: true  // if isolated margin
       orders: {
           symbol: string,  // example: "BTCUSDT"
           orderId: number,  // example: 20
           clientOrderId: string  // example: "CwOOIPHSmYywx6jZX77TdL"
         }[],
       orderReports: (
         {
           symbol: string,  // example: "BTCUSDT"
           origClientOrderId: string,  // example: "CwOOIPHSmYywx6jZX77TdL"
           orderId: number,  // example: 20
           orderListId: number,  // example: 1929
           clientOrderId: string,  // example: "pXLV6Hz6mprAcVYpVMTGgx"
           price: NumberString,  // example: "0.668611"
           origQty: NumberString,  // example: "0.690354"
           executedQty: NumberString,  // example: "0.000000"
           cummulativeQuoteQty: NumberString,  // example: "0.000000"
           status: string,  // example: "CANCELED"
           timeInForce: TimeInForce,  // example: "GTC"
           type: OrderType,  // example: "STOP_LOSS_LIMIT"
           side: OrderSide,  // example: "BUY"
           stopPrice: NumberString,  // example: "0.378131"
           icebergQty: NumberString  // example: "0.017083"
         } |
         {
           symbol: string,  // example: "BTCUSDT"
           origClientOrderId: string,  // example: "461cPg51vQjV3zIMOXNz39"
           orderId: number,  // example: 21
           orderListId: number,  // example: 1929
           clientOrderId: string,  // example: "pXLV6Hz6mprAcVYpVMTGgx"
           price: NumberString,  // example: "0.008791"
           origQty: NumberString,  // example: "0.690354"
           executedQty: NumberString,  // example: "0.000000"
           cummulativeQuoteQty: NumberString,  // example: "0.000000"
           status: string,  // example: "CANCELED"
           timeInForce: TimeInForce,  // example: "GTC"
           type: OrderType,  // example: "LIMIT_MAKER"
           side: OrderSide,  // example: "BUY"
           icebergQty: NumberString  // example: "0.639962"
         }
       )[]
     }
    )[]>;
  
  
  marginAccountCancelAllOpenOrdersOnASymbol(...args : any) {
      return this._sendRequest("/sapi/v1/margin/openOrders", "DELETE", "TRADE", false, args, ["symbol", "isIsolated", "recvWindow", "timestamp"], "marginAccountCancelAllOpenOrdersOnASymbol");
  }
  
  
  /** Adjust cross margin max leverage (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#adjust-cross-margin-max-leverage-user_data}
   * 
   * Adjust cross margin max leverage
   * 
   * EndPoint: /sapi/v1/margin/max-leverage
   * 
   * Weight(UID): 3000
   * 
   * @param {INTEGER} maxLeverage  -  Can only adjust 3 , 5 or 10，Example: maxLeverage=10 for Cross Margin Pro ，maxLeverage = 5 or 3 for Cross Margin Classic
   */
  adjustCrossMarginMaxLeverage(maxLeverage :INTEGER)  : ReturnType<MyBinanceClient["adjustCrossMarginMaxLeverage"]>;
  
  
  /** Adjust cross margin max leverage (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#adjust-cross-margin-max-leverage-user_data}
   * 
   * Adjust cross margin max leverage
   * 
   * EndPoint: /sapi/v1/margin/max-leverage
   * 
   * Weight(UID): 3000
   * 
   * @param {INTEGER} options.maxLeverage  -  Can only adjust 3 , 5 or 10，Example: maxLeverage=10 for Cross Margin Pro ，maxLeverage = 5 or 3 for Cross Margin Classic
   */
  adjustCrossMarginMaxLeverage(options : { maxLeverage :INTEGER })
  : Promise<{
     success: boolean  // example: true
    }>;
  
  
  adjustCrossMarginMaxLeverage(...args : any) {
      return this._sendRequest("/sapi/v1/margin/max-leverage", "POST", "USER_DATA", false, args, ["maxLeverage"], "adjustCrossMarginMaxLeverage");
  }
  
  
  /** Get Cross Margin Transfer History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-cross-margin-transfer-history-user_data}
   * 
   * EndPoint: /sapi/v1/margin/transfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} asset
   * @param {string} type  -  Transfer Type: ROLL_IN, ROLL_OUT
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10 Max:100
   * @param {string} isolatedSymbol  -  Symbol in Isolated Margin
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  getCrossMarginTransferHistory(asset? :string, type? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, isolatedSymbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getCrossMarginTransferHistory"]>;
  
  
  /** Get Cross Margin Transfer History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-cross-margin-transfer-history-user_data}
   * 
   * EndPoint: /sapi/v1/margin/transfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.asset
   * @param {string} options.type  -  Transfer Type: ROLL_IN, ROLL_OUT
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {string} options.isolatedSymbol  -  Symbol in Isolated Margin
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  getCrossMarginTransferHistory(options? : { asset? :string, type? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, isolatedSymbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: (
       {
         amount: NumberString,  // example: "0.10000000"
         asset: string,  // example: "BNB"
         status: string,  // example: "CONFIRMED"
         timestamp: number,  // example: 1566898617
         txId: number,  // example: 5240372201
         type: string,  // example: "ROLL_IN"
         transFrom: string,  // example: "SPOT"  //SPOT,FUTURES,FIAT,DELIVERY,MINING,ISOLATED_MARGIN,FUNDING,MOTHER_SPOT,OPTION,SUB_SPOT,SUB_MARGIN,CROSS_MARGIN
         transTo: string  // example: "ISOLATED_MARGIN"  //SPOT,FUTURES,FIAT,DELIVERY,MINING,ISOLATED_MARGIN,FUNDING,MOTHER_SPOT,OPTION,SUB_SPOT,SUB_MARGIN,CROSS_MARGIN
       } |
       {
         amount: NumberString,  // example: "5.00000000"
         asset: string,  // example: "USDT"
         status: string,  // example: "CONFIRMED"
         timestamp: number,  // example: 1566888436
         txId: number,  // example: 5239810406
         type: string,  // example: "ROLL_OUT"
         transFrom: string,  // example: "ISOLATED_MARGIN"  //SPOT,FUTURES,FIAT,DELIVERY,MINING,ISOLATED_MARGIN,FUNDING,MOTHER_SPOT,OPTION,SUB_SPOT,SUB_MARGIN,CROSS_MARGIN
         transTo: string,  // example: "ISOLATED_MARGIN"  //SPOT,FUTURES,FIAT,DELIVERY,MINING,ISOLATED_MARGIN,FUNDING,MOTHER_SPOT,OPTION,SUB_SPOT,SUB_MARGIN,CROSS_MARGIN
         fromSymbol: string,  // example: "BNBUSDT"
         toSymbol: string  // example: "BTCUSDT"
       } |
       {
         amount: NumberString,  // example: "1.00000000"
         asset: string,  // example: "EOS"
         status: string,  // example: "CONFIRMED"
         timestamp: number,  // example: 1566888403
         txId: number,  // example: 5239808703
         type: string  // example: "ROLL_IN"
       }
     )[],
     total: number  // example: 3
    }>;
  
  
  getCrossMarginTransferHistory(...args : any) {
      return this._sendRequest("/sapi/v1/margin/transfer", "GET", "USER_DATA", false, args, ["asset", "type", "startTime", "endTime", "current", "size", "isolatedSymbol", "recvWindow", "timestamp"], "getCrossMarginTransferHistory");
  }
  
  
  /** Get Interest History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-interest-history-user_data}
   * 
   * EndPoint: /sapi/v1/margin/interestHistory
   * 
   * Weight(IP): 1
   * 
   * @param {string} asset
   * @param {string} isolatedSymbol  -  isolated symbol
   * @param {LONG} startTime  -  per-second accuracy.  milliseconds input will be ignored. e.g. XXXXXXXXXX000ms
   * @param {LONG} endTime  -  per-second accuracy.  milliseconds input will be ignored. e.g. XXXXXXXXXX000ms
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10 Max:100
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  getInterestHistory(asset? :string, isolatedSymbol? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getInterestHistory"]>;
  
  
  /** Get Interest History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-interest-history-user_data}
   * 
   * EndPoint: /sapi/v1/margin/interestHistory
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.asset
   * @param {string} options.isolatedSymbol  -  isolated symbol
   * @param {LONG} options.startTime  -  per-second accuracy.  milliseconds input will be ignored. e.g. XXXXXXXXXX000ms
   * @param {LONG} options.endTime  -  per-second accuracy.  milliseconds input will be ignored. e.g. XXXXXXXXXX000ms
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  getInterestHistory(options? : { asset? :string, isolatedSymbol? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         txId: number,  // example: 1352286576452864800
         interestAccuredTime: number,  // example: 1672160400000
         asset: string,  // example: "USDT"
         rawAsset: string,  // example: "USDT"  // will not be returned for isolated margin
         principal: NumberString,  // example: "45.3313"
         interest: NumberString,  // example: "0.00024995"
         interestRate: NumberString,  // example: "0.00013233"
         type: string,  // example: "ON_BORROW"
         isolatedSymbol: string  // example: "BNBUSDT"  // isolated symbol, will not be returned for crossed margin
       }[],
     total: number  // example: 1
    }>;
  
  
  getInterestHistory(...args : any) {
      return this._sendRequest("/sapi/v1/margin/interestHistory", "GET", "USER_DATA", false, args, ["asset", "isolatedSymbol", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getInterestHistory");
  }
  
  
  /** Get Force Liquidation Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-force-liquidation-record-user_data}
   * 
   * EndPoint: /sapi/v1/margin/forceLiquidationRec
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {string} isolatedSymbol
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10 Max:100
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  getForceLiquidationRecord(startTime? :LONG, endTime? :LONG, isolatedSymbol? :string, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getForceLiquidationRecord"]>;
  
  
  /** Get Force Liquidation Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-force-liquidation-record-user_data}
   * 
   * EndPoint: /sapi/v1/margin/forceLiquidationRec
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {string} options.isolatedSymbol
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  getForceLiquidationRecord(options? : { startTime? :LONG, endTime? :LONG, isolatedSymbol? :string, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         avgPrice: NumberString,  // example: "0.00388359"
         executedQty: NumberString,  // example: "31.39000000"
         orderId: number,  // example: 180015097
         price: NumberString,  // example: "0.00388110"
         qty: NumberString,  // example: "31.39000000"
         side: OrderSide,  // example: "SELL"
         symbol: string,  // example: "BNBBTC"
         timeInForce: TimeInForce,  // example: "GTC"
         isIsolated: boolean,  // example: true
         updatedTime: number  // example: 1558941374745
       }[],
     total: number  // example: 1
    }>;
  
  
  getForceLiquidationRecord(...args : any) {
      return this._sendRequest("/sapi/v1/margin/forceLiquidationRec", "GET", "USER_DATA", false, args, ["startTime", "endTime", "isolatedSymbol", "current", "size", "recvWindow", "timestamp"], "getForceLiquidationRecord");
  }
  
  
  /** Query Cross Margin Account Details (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-cross-margin-account-details-user_data}
   * 
   * EndPoint: /sapi/v1/margin/account
   * 
   * Weight(IP): 10
   * 
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryCrossMarginAccountDetails(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryCrossMarginAccountDetails"]>;
  
  
  /** Query Cross Margin Account Details (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-cross-margin-account-details-user_data}
   * 
   * EndPoint: /sapi/v1/margin/account
   * 
   * Weight(IP): 10
   * 
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryCrossMarginAccountDetails(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     created: boolean,  // example: true  // True means margin account created , false means margin account not created.
     borrowEnabled: boolean,  // example: true
     marginLevel: NumberString,  // example: "11.64405625"
     collateralMarginLevel: NumberString,  // example: "3.2"
     totalAssetOfBtc: NumberString,  // example: "6.82728457"
     totalLiabilityOfBtc: NumberString,  // example: "0.58633215"
     totalNetAssetOfBtc: NumberString,  // example: "6.24095242"
     totalCollateralValueInUSDT: NumberString,  // example: "5.82728457"
     tradeEnabled: boolean,  // example: true
     transferEnabled: boolean,  // example: true
     accountType: string,  // example: "MARGIN_1"  // //MARGIN_1 for Cross Margin Classic, MARGIN_2 for Cross Margin Pro
     userAssets: {
         asset: string,  // example: "BTC"
         borrowed: NumberString,  // example: "0.00000000"
         free: NumberString,  // example: "0.00499500"
         interest: NumberString,  // example: "0.00000000"
         locked: NumberString,  // example: "0.00000000"
         netAsset: NumberString  // example: "0.00499500"
       }[]
    }>;
  
  
  queryCrossMarginAccountDetails(...args : any) {
      return this._sendRequest("/sapi/v1/margin/account", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryCrossMarginAccountDetails");
  }
  
  
  /** Query Margin Account's Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-order-user_data}
   * 
   * EndPoint: /sapi/v1/margin/order
   * 
   * Weight(IP): 10
   * 
   * @param {string} symbol
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryMarginAccountSOrder(symbol :string, isIsolated? :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMarginAccountSOrder"]>;
  
  
  /** Query Margin Account's Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-order-user_data}
   * 
   * EndPoint: /sapi/v1/margin/order
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.symbol
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryMarginAccountSOrder(options : { symbol :string, isIsolated? :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     clientOrderId: string,  // example: "ZwfQzuDIGpceVhKW5DvCmO"
     cummulativeQuoteQty: NumberString,  // example: "0.00000000"
     executedQty: NumberString,  // example: "0.00000000"
     icebergQty: NumberString,  // example: "0.00000000"
     isWorking: boolean,  // example: true
     orderId: number,  // example: 213205622
     origQty: NumberString,  // example: "0.30000000"
     price: NumberString,  // example: "0.00493630"
     side: OrderSide,  // example: "SELL"
     status: string,  // example: "NEW"
     stopPrice: NumberString,  // example: "0.00000000"
     symbol: string,  // example: "BNBBTC"
     isIsolated: boolean,  // example: true
     time: number,  // example: 1562133008725
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     selfTradePreventionMode: string,  // example: "NONE"
     updateTime: number  // example: 1562133008725
    }>;
  
  
  queryMarginAccountSOrder(...args : any) {
      return this._sendRequest("/sapi/v1/margin/order", "GET", "USER_DATA", false, args, ["symbol", "isIsolated", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "queryMarginAccountSOrder");
  }
  
  
  /** Query Margin Account's Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-open-orders-user_data}
   * 
   * EndPoint: /sapi/v1/margin/openOrders
   * 
   * Weight(IP): 10
   * 
   * @param {string} symbol
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryMarginAccountSOpenOrders(symbol? :string, isIsolated? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMarginAccountSOpenOrders"]>;
  
  
  /** Query Margin Account's Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-open-orders-user_data}
   * 
   * EndPoint: /sapi/v1/margin/openOrders
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.symbol
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryMarginAccountSOpenOrders(options? : { symbol? :string, isIsolated? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       clientOrderId: string,  // example: "qhcZw71gAkCCTv0t0k8LUK"
       cummulativeQuoteQty: NumberString,  // example: "0.00000000"
       executedQty: NumberString,  // example: "0.00000000"
       icebergQty: NumberString,  // example: "0.00000000"
       isWorking: boolean,  // example: true
       orderId: number,  // example: 211842552
       origQty: NumberString,  // example: "0.30000000"
       price: NumberString,  // example: "0.00475010"
       side: OrderSide,  // example: "SELL"
       status: string,  // example: "NEW"
       stopPrice: NumberString,  // example: "0.00000000"
       symbol: string,  // example: "BNBBTC"
       isIsolated: boolean,  // example: true
       time: number,  // example: 1562040170089
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       selfTradePreventionMode: string,  // example: "NONE"
       updateTime: number  // example: 1562040170089
     }[]>;
  
  
  queryMarginAccountSOpenOrders(...args : any) {
      return this._sendRequest("/sapi/v1/margin/openOrders", "GET", "USER_DATA", false, args, ["symbol", "isIsolated", "recvWindow", "timestamp"], "queryMarginAccountSOpenOrders");
  }
  
  
  /** Query Margin Account's All Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-all-orders-user_data}
   * 
   * EndPoint: /sapi/v1/margin/allOrders
   * 
   * Weight(IP): 200
   * 
   * @param {string} symbol
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 500.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryMarginAccountSAllOrders(symbol :string, isIsolated? :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMarginAccountSAllOrders"]>;
  
  
  /** Query Margin Account's All Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-all-orders-user_data}
   * 
   * EndPoint: /sapi/v1/margin/allOrders
   * 
   * Weight(IP): 200
   * 
   * @param {string} options.symbol
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 500.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryMarginAccountSAllOrders(options : { symbol :string, isIsolated? :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       clientOrderId: string,  // example: "D2KDy4DIeS56PvkM13f8cP"
       cummulativeQuoteQty: NumberString,  // example: "0.00000000"
       executedQty: NumberString,  // example: "0.00000000"
       icebergQty: NumberString,  // example: "0.00000000"
       isWorking: boolean,  // example: false
       orderId: number,  // example: 41295
       origQty: NumberString,  // example: "5.31000000"
       price: NumberString,  // example: "0.22500000"
       side: OrderSide,  // example: "SELL"
       status: string,  // example: "CANCELED"
       stopPrice: NumberString,  // example: "0.18000000"
       symbol: string,  // example: "BNBBTC"
       isIsolated: boolean,  // example: false
       time: number,  // example: 1565769338806
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "TAKE_PROFIT_LIMIT"
       selfTradePreventionMode: string,  // example: "NONE"
       updateTime: number  // example: 1565769342148
     }[]>;
  
  
  queryMarginAccountSAllOrders(...args : any) {
      return this._sendRequest("/sapi/v1/margin/allOrders", "GET", "USER_DATA", false, args, ["symbol", "isIsolated", "orderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "queryMarginAccountSAllOrders");
  }
  
  
  /** Margin Account New OCO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-new-oco-trade}
   * 
   * Send in a new OCO for a margin account
   * 
   * EndPoint: /sapi/v1/margin/order/oco
   * 
   * Weight(UID): 6
   * 
   * @param {string} symbol
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {string} listClientOrderId  -  A unique Id for the entire orderList
   * @param {OrderSide} side
   * @param {DECIMAL} quantity
   * @param {string} limitClientOrderId  -  A unique Id for the limit order
   * @param {DECIMAL} price
   * @param {DECIMAL} limitIcebergQty
   * @param {string} stopClientOrderId  -  A unique Id for the stop loss/stop loss limit leg
   * @param {DECIMAL} stopPrice
   * @param {DECIMAL} stopLimitPrice  -  If provided, stopLimitTimeInForce is required.
   * @param {DECIMAL} stopIcebergQty
   * @param {ENUM} stopLimitTimeInForce  -  Valid values are GTC/FOK/IOC
   * @param {OrderResponseType} newOrderRespType  -  Set the response JSON.
   * @param {"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY"} sideEffectType  -  NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in FAQ
   * @param {ENUM} selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
   * @param {boolean} autoRepayAtCancel  -  Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  marginAccountNewOCO(symbol :string, isIsolated :string|undefined, listClientOrderId :string|undefined, side :OrderSide, quantity :DECIMAL, limitClientOrderId :string|undefined, price :DECIMAL, limitIcebergQty :DECIMAL|undefined, stopClientOrderId :string|undefined, stopPrice :DECIMAL, stopLimitPrice? :DECIMAL, stopIcebergQty? :DECIMAL, stopLimitTimeInForce? :ENUM, newOrderRespType? :OrderResponseType, sideEffectType? :"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY", selfTradePreventionMode? :ENUM, autoRepayAtCancel? :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["marginAccountNewOCO"]>;
  
  
  /** Margin Account New OCO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-new-oco-trade}
   * 
   * Send in a new OCO for a margin account
   * 
   * EndPoint: /sapi/v1/margin/order/oco
   * 
   * Weight(UID): 6
   * 
   * @param {string} options.symbol
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {string} options.listClientOrderId  -  A unique Id for the entire orderList
   * @param {OrderSide} options.side
   * @param {DECIMAL} options.quantity
   * @param {string} options.limitClientOrderId  -  A unique Id for the limit order
   * @param {DECIMAL} options.price
   * @param {DECIMAL} options.limitIcebergQty
   * @param {string} options.stopClientOrderId  -  A unique Id for the stop loss/stop loss limit leg
   * @param {DECIMAL} options.stopPrice
   * @param {DECIMAL} options.stopLimitPrice  -  If provided, stopLimitTimeInForce is required.
   * @param {DECIMAL} options.stopIcebergQty
   * @param {ENUM} options.stopLimitTimeInForce  -  Valid values are GTC/FOK/IOC
   * @param {OrderResponseType} options.newOrderRespType  -  Set the response JSON.
   * @param {"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY"} options.sideEffectType  -  NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in FAQ
   * @param {ENUM} options.selfTradePreventionMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
   * @param {boolean} options.autoRepayAtCancel  -  Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  marginAccountNewOCO(options : { symbol :string, isIsolated? :string, listClientOrderId? :string, side :OrderSide, quantity :DECIMAL, limitClientOrderId? :string, price :DECIMAL, limitIcebergQty? :DECIMAL, stopClientOrderId? :string, stopPrice :DECIMAL, stopLimitPrice? :DECIMAL, stopIcebergQty? :DECIMAL, stopLimitTimeInForce? :ENUM, newOrderRespType? :OrderResponseType, sideEffectType? :"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY", selfTradePreventionMode? :ENUM, autoRepayAtCancel? :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 0
     contingencyType: string,  // example: "OCO"
     listStatusType: OCOStatus,  // example: "EXEC_STARTED"
     listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
     listClientOrderId: string,  // example: "JYVpp3F0f5CAG15DhtrqLp"
     transactionTime: number,  // example: 1563417480525
     symbol: string,  // example: "LTCBTC"
     marginBuyBorrowAmount: NumberString,  // example: "5"  // will not return if no margin trade happens
     marginBuyBorrowAsset: string,  // example: "BTC"  // will not return if no margin trade happens
     isIsolated: boolean,  // example: false  // if isolated margin
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 2
         clientOrderId: string  // example: "Kk7sqHb9J6mJWTMDVW7Vos"
       }[],
     orderReports: (
       {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 2
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "Kk7sqHb9J6mJWTMDVW7Vos"
         transactTime: number,  // example: 1563417480525
         price: NumberString,  // example: "0.000000"
         origQty: NumberString,  // example: "0.624363"
         executedQty: NumberString,  // example: "0.000000"
         cummulativeQuoteQty: NumberString,  // example: "0.000000"
         status: string,  // example: "NEW"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "STOP_LOSS"
         side: OrderSide,  // example: "BUY"
         stopPrice: NumberString,  // example: "0.960664"
         selfTradePreventionMode: string  // example: "NONE"
       } |
       {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 3
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "xTXKaGYd4bluPVp78IVRvl"
         transactTime: number,  // example: 1563417480525
         price: NumberString,  // example: "0.036435"
         origQty: NumberString,  // example: "0.624363"
         executedQty: NumberString,  // example: "0.000000"
         cummulativeQuoteQty: NumberString,  // example: "0.000000"
         status: string,  // example: "NEW"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "LIMIT_MAKER"
         side: OrderSide,  // example: "BUY"
         selfTradePreventionMode: string  // example: "NONE"
       }
     )[]
    }>;
  
  
  marginAccountNewOCO(...args : any) {
      return this._sendRequest("/sapi/v1/margin/order/oco", "POST", "TRADE", false, args, ["symbol", "isIsolated", "listClientOrderId", "side", "quantity", "limitClientOrderId", "price", "limitIcebergQty", "stopClientOrderId", "stopPrice", "stopLimitPrice", "stopIcebergQty", "stopLimitTimeInForce", "newOrderRespType", "sideEffectType", "selfTradePreventionMode", "autoRepayAtCancel", "recvWindow", "timestamp"], "marginAccountNewOCO");
  }
  
  
  /** Margin Account Cancel OCO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-cancel-oco-trade}
   * 
   * Cancel an entire Order List for a margin account.
   * 
   * EndPoint: /sapi/v1/margin/orderList
   * 
   * Weight(UID): 1
   * 
   * @param {string} symbol
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} orderListId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} listClientOrderId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  marginAccountCancelOCO(symbol :string, isIsolated? :string, orderListId? :LONG, listClientOrderId? :string, newClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["marginAccountCancelOCO"]>;
  
  
  /** Margin Account Cancel OCO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-account-cancel-oco-trade}
   * 
   * Cancel an entire Order List for a margin account.
   * 
   * EndPoint: /sapi/v1/margin/orderList
   * 
   * Weight(UID): 1
   * 
   * @param {string} options.symbol
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} options.orderListId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} options.listClientOrderId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} options.newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  marginAccountCancelOCO(options : { symbol :string, isIsolated? :string, orderListId? :LONG, listClientOrderId? :string, newClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 0
     contingencyType: string,  // example: "OCO"
     listStatusType: OCOStatus,  // example: "ALL_DONE"
     listOrderStatus: OCOOrderStatus,  // example: "ALL_DONE"
     listClientOrderId: string,  // example: "C3wyj4WVEktd7u9aVBRXcN"
     transactionTime: number,  // example: 1574040868128
     symbol: string,  // example: "LTCBTC"
     isIsolated: boolean,  // example: false  // if isolated margin
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 2
         clientOrderId: string  // example: "pO9ufTiFGg3nw2fOdgeOXa"
       }[],
     orderReports: (
       {
         symbol: string,  // example: "LTCBTC"
         origClientOrderId: string,  // example: "pO9ufTiFGg3nw2fOdgeOXa"
         orderId: number,  // example: 2
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "unfWT8ig8i0uj6lPuYLez6"
         price: NumberString,  // example: "1.00000000"
         origQty: NumberString,  // example: "10.00000000"
         executedQty: NumberString,  // example: "0.00000000"
         cummulativeQuoteQty: NumberString,  // example: "0.00000000"
         status: string,  // example: "CANCELED"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "STOP_LOSS_LIMIT"
         side: OrderSide,  // example: "SELL"
         stopPrice: NumberString,  // example: "1.00000000"
         selfTradePreventionMode: string  // example: "NONE"
       } |
       {
         symbol: string,  // example: "LTCBTC"
         origClientOrderId: string,  // example: "TXOvglzXuaubXAaENpaRCB"
         orderId: number,  // example: 3
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "unfWT8ig8i0uj6lPuYLez6"
         price: NumberString,  // example: "3.00000000"
         origQty: NumberString,  // example: "10.00000000"
         executedQty: NumberString,  // example: "0.00000000"
         cummulativeQuoteQty: NumberString,  // example: "0.00000000"
         status: string,  // example: "CANCELED"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "LIMIT_MAKER"
         side: OrderSide,  // example: "SELL"
         selfTradePreventionMode: string  // example: "NONE"
       }
     )[]
    }>;
  
  
  marginAccountCancelOCO(...args : any) {
      return this._sendRequest("/sapi/v1/margin/orderList", "DELETE", "TRADE", false, args, ["symbol", "isIsolated", "orderListId", "listClientOrderId", "newClientOrderId", "recvWindow", "timestamp"], "marginAccountCancelOCO");
  }
  
  
  /** Query Margin Account's OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-oco-user_data}
   * 
   * Retrieves a specific OCO based on provided optional parameters
   * 
   * EndPoint: /sapi/v1/margin/orderList
   * 
   * Weight(IP): 10
   * 
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {string} symbol  -  mandatory for isolated margin, not supported for cross margin
   * @param {LONG} orderListId  -  Either orderListId or origClientOrderId must be provided
   * @param {string} origClientOrderId  -  Either orderListId or origClientOrderId must be provided
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryMarginAccountSOCO(isIsolated? :string, symbol? :string, orderListId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMarginAccountSOCO"]>;
  
  
  /** Query Margin Account's OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-oco-user_data}
   * 
   * Retrieves a specific OCO based on provided optional parameters
   * 
   * EndPoint: /sapi/v1/margin/orderList
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {string} options.symbol  -  mandatory for isolated margin, not supported for cross margin
   * @param {LONG} options.orderListId  -  Either orderListId or origClientOrderId must be provided
   * @param {string} options.origClientOrderId  -  Either orderListId or origClientOrderId must be provided
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryMarginAccountSOCO(options? : { isIsolated? :string, symbol? :string, orderListId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 27
     contingencyType: string,  // example: "OCO"
     listStatusType: OCOStatus,  // example: "EXEC_STARTED"
     listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
     listClientOrderId: string,  // example: "h2USkA5YQpaXHPIrkd96xE"
     transactionTime: number,  // example: 1565245656253
     symbol: string,  // example: "LTCBTC"
     isIsolated: boolean,  // example: false  // if isolated margin
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 4
         clientOrderId: string  // example: "qD1gy3kc3Gx0rihm9Y3xwS"
       }[]
    }>;
  
  
  queryMarginAccountSOCO(...args : any) {
      return this._sendRequest("/sapi/v1/margin/orderList", "GET", "USER_DATA", false, args, ["isIsolated", "symbol", "orderListId", "origClientOrderId", "recvWindow", "timestamp"], "queryMarginAccountSOCO");
  }
  
  
  /** Query Margin Account's all OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-all-oco-user_data}
   * 
   * Retrieves all OCO for a specific margin account based on provided optional parameters
   * 
   * EndPoint: /sapi/v1/margin/allOrderList
   * 
   * Weight(IP): 200
   * 
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {string} symbol  -  mandatory for isolated margin, not supported for cross margin
   * @param {LONG} fromId  -  If supplied, neither startTime or endTime can be provided
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default Value: 500; Max Value: 1000
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryMarginAccountSAllOCO(isIsolated? :string, symbol? :string, fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMarginAccountSAllOCO"]>;
  
  
  /** Query Margin Account's all OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-all-oco-user_data}
   * 
   * Retrieves all OCO for a specific margin account based on provided optional parameters
   * 
   * EndPoint: /sapi/v1/margin/allOrderList
   * 
   * Weight(IP): 200
   * 
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {string} options.symbol  -  mandatory for isolated margin, not supported for cross margin
   * @param {LONG} options.fromId  -  If supplied, neither startTime or endTime can be provided
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default Value: 500; Max Value: 1000
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryMarginAccountSAllOCO(options? : { isIsolated? :string, symbol? :string, fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       orderListId: number,  // example: 29
       contingencyType: string,  // example: "OCO"
       listStatusType: OCOStatus,  // example: "EXEC_STARTED"
       listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
       listClientOrderId: string,  // example: "amEEAXryFzFwYF1FeRpUoZ"
       transactionTime: number,  // example: 1565245913483
       symbol: string,  // example: "LTCBTC"
       isIsolated: boolean,  // example: true  // if isolated margin
       orders: {
           symbol: string,  // example: "LTCBTC"
           orderId: number,  // example: 4
           clientOrderId: string  // example: "oD7aesZqjEGlZrbtRpy5zB"
         }[]
     } |
     {
       orderListId: number,  // example: 28
       contingencyType: string,  // example: "OCO"
       listStatusType: OCOStatus,  // example: "EXEC_STARTED"
       listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
       listClientOrderId: string,  // example: "hG7hFNxJV6cZy3Ze4AUT4d"
       transactionTime: number,  // example: 1565245913407
       symbol: string,  // example: "LTCBTC"
       orders: {
           symbol: string,  // example: "LTCBTC"
           orderId: number,  // example: 2
           clientOrderId: string  // example: "j6lFOfbmFMRjTYA7rRJ0LP"
         }[]
     }
    )[]>;
  
  
  queryMarginAccountSAllOCO(...args : any) {
      return this._sendRequest("/sapi/v1/margin/allOrderList", "GET", "USER_DATA", false, args, ["isIsolated", "symbol", "fromId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "queryMarginAccountSAllOCO");
  }
  
  
  /** Query Margin Account's Open OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-open-oco-user_data}
   * 
   * EndPoint: /sapi/v1/margin/openOrderList
   * 
   * Weight(IP): 10
   * 
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {string} symbol  -  mandatory for isolated margin, not supported for cross margin
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryMarginAccountSOpenOCO(isIsolated? :string, symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMarginAccountSOpenOCO"]>;
  
  
  /** Query Margin Account's Open OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-open-oco-user_data}
   * 
   * EndPoint: /sapi/v1/margin/openOrderList
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {string} options.symbol  -  mandatory for isolated margin, not supported for cross margin
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryMarginAccountSOpenOCO(options? : { isIsolated? :string, symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderListId: number,  // example: 31
       contingencyType: string,  // example: "OCO"
       listStatusType: OCOStatus,  // example: "EXEC_STARTED"
       listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
       listClientOrderId: string,  // example: "wuB13fmulKj3YjdqWEcsnp"
       transactionTime: number,  // example: 1565246080644
       symbol: string,  // example: "LTCBTC"
       isIsolated: boolean,  // example: false  // if isolated margin
       orders: {
           symbol: string,  // example: "LTCBTC"
           orderId: number,  // example: 4
           clientOrderId: string  // example: "r3EH2N76dHfLoSZWIUw1bT"
         }[]
     }[]>;
  
  
  queryMarginAccountSOpenOCO(...args : any) {
      return this._sendRequest("/sapi/v1/margin/openOrderList", "GET", "USER_DATA", false, args, ["isIsolated", "symbol", "recvWindow", "timestamp"], "queryMarginAccountSOpenOCO");
  }
  
  
  /** Query Margin Account's Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-trade-list-user_data}
   * 
   * EndPoint: /sapi/v1/margin/myTrades
   * 
   * Weight(IP): 10
   * 
   * @param {string} symbol
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} fromId  -  TradeId to fetch from. Default gets most recent trades.
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryMarginAccountSTradeList(symbol :string, isIsolated? :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMarginAccountSTradeList"]>;
  
  
  /** Query Margin Account's Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-account-39-s-trade-list-user_data}
   * 
   * EndPoint: /sapi/v1/margin/myTrades
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.symbol
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {LONG} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.fromId  -  TradeId to fetch from. Default gets most recent trades.
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryMarginAccountSTradeList(options : { symbol :string, isIsolated? :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       commission: NumberString,  // example: "0.00006000"
       commissionAsset: string,  // example: "BTC"
       id: number,  // example: 34
       isBestMatch: boolean,  // example: true
       isBuyer: boolean,  // example: false
       isMaker: boolean,  // example: false
       orderId: number,  // example: 39324
       price: NumberString,  // example: "0.02000000"
       qty: NumberString,  // example: "3.00000000"
       symbol: string,  // example: "BNBBTC"
       isIsolated: boolean,  // example: false
       time: number  // example: 1561973357171
     }[]>;
  
  
  queryMarginAccountSTradeList(...args : any) {
      return this._sendRequest("/sapi/v1/margin/myTrades", "GET", "USER_DATA", false, args, ["symbol", "isIsolated", "orderId", "startTime", "endTime", "fromId", "limit", "recvWindow", "timestamp"], "queryMarginAccountSTradeList");
  }
  
  
  /** Query Max Borrow (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-max-borrow-user_data}
   * 
   * EndPoint: /sapi/v1/margin/maxBorrowable
   * 
   * Weight(IP): 50
   * 
   * @param {string} asset
   * @param {string} isolatedSymbol  -  isolated symbol
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryMaxBorrow(asset :string, isolatedSymbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMaxBorrow"]>;
  
  
  /** Query Max Borrow (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-max-borrow-user_data}
   * 
   * EndPoint: /sapi/v1/margin/maxBorrowable
   * 
   * Weight(IP): 50
   * 
   * @param {string} options.asset
   * @param {string} options.isolatedSymbol  -  isolated symbol
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryMaxBorrow(options : { asset :string, isolatedSymbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     amount: NumberString,  // example: "1.69248805"  // account's currently max borrowable amount with sufficient system availability
     borrowLimit: NumberString  // example: "60"  // max borrowable amount limited by the account level
    }>;
  
  
  queryMaxBorrow(...args : any) {
      return this._sendRequest("/sapi/v1/margin/maxBorrowable", "GET", "USER_DATA", false, args, ["asset", "isolatedSymbol", "recvWindow", "timestamp"], "queryMaxBorrow");
  }
  
  
  /** Query Max Transfer-Out Amount (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-max-transfer-out-amount-user_data}
   * 
   * EndPoint: /sapi/v1/margin/maxTransferable
   * 
   * Weight(IP): 50
   * 
   * @param {string} asset
   * @param {string} isolatedSymbol  -  isolated symbol
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryMaxTransferOutAmount(asset :string, isolatedSymbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMaxTransferOutAmount"]>;
  
  
  /** Query Max Transfer-Out Amount (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-max-transfer-out-amount-user_data}
   * 
   * EndPoint: /sapi/v1/margin/maxTransferable
   * 
   * Weight(IP): 50
   * 
   * @param {string} options.asset
   * @param {string} options.isolatedSymbol  -  isolated symbol
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryMaxTransferOutAmount(options : { asset :string, isolatedSymbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     amount: NumberString  // example: "3.59498107"
    }>;
  
  
  queryMaxTransferOutAmount(...args : any) {
      return this._sendRequest("/sapi/v1/margin/maxTransferable", "GET", "USER_DATA", false, args, ["asset", "isolatedSymbol", "recvWindow", "timestamp"], "queryMaxTransferOutAmount");
  }
  
  
  /** Get Summary of Margin account (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-summary-of-margin-account-user_data}
   * 
   * Get personal margin level information
   * 
   * EndPoint: /sapi/v1/margin/tradeCoeff
   * 
   * Weight(IP): 10
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSummaryOfMarginAccount(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getSummaryOfMarginAccount"]>;
  
  
  /** Get Summary of Margin account (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-summary-of-margin-account-user_data}
   * 
   * Get personal margin level information
   * 
   * EndPoint: /sapi/v1/margin/tradeCoeff
   * 
   * Weight(IP): 10
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSummaryOfMarginAccount(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     normalBar: NumberString,  // example: "1.5"
     marginCallBar: NumberString,  // example: "1.3"
     forceLiquidationBar: NumberString  // example: "1.1"
    }>;
  
  
  getSummaryOfMarginAccount(...args : any) {
      return this._sendRequest("/sapi/v1/margin/tradeCoeff", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "getSummaryOfMarginAccount");
  }
  
  
  /** Query Isolated Margin Account Info (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-isolated-margin-account-info-user_data}
   * 
   * EndPoint: /sapi/v1/margin/isolated/account
   * 
   * Weight(IP): 10
   * 
   * @param {string} symbols  -  Max 5 symbols can be sent; separated by ",". e.g. "BTCUSDT,BNBUSDT,ADAUSDT"
   * @param {LONG} recvWindow  -  No more than 60000
   * @param {LONG} timestamp
   */
  queryIsolatedMarginAccountInfo(symbols? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryIsolatedMarginAccountInfo"]>;
  
  
  /** Query Isolated Margin Account Info (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-isolated-margin-account-info-user_data}
   * 
   * EndPoint: /sapi/v1/margin/isolated/account
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.symbols  -  Max 5 symbols can be sent; separated by ",". e.g. "BTCUSDT,BNBUSDT,ADAUSDT"
   * @param {LONG} options.recvWindow  -  No more than 60000
   * @param {LONG} options.timestamp
   */
  queryIsolatedMarginAccountInfo(options? : { symbols? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  // If "symbols" is not sent
     assets: {
         baseAsset: {
           asset: string,  // example: "BTC"
           borrowEnabled: boolean,  // example: true
           borrowed: NumberString,  // example: "0.00000000"
           free: NumberString,  // example: "0.00000000"
           interest: NumberString,  // example: "0.00000000"
           locked: NumberString,  // example: "0.00000000"
           netAsset: NumberString,  // example: "0.00000000"
           netAssetOfBtc: NumberString,  // example: "0.00000000"
           repayEnabled: boolean,  // example: true
           totalAsset: NumberString  // example: "0.00000000"
         },
         quoteAsset: {
           asset: string,  // example: "USDT"
           borrowEnabled: boolean,  // example: true
           borrowed: NumberString,  // example: "0.00000000"
           free: NumberString,  // example: "0.00000000"
           interest: NumberString,  // example: "0.00000000"
           locked: NumberString,  // example: "0.00000000"
           netAsset: NumberString,  // example: "0.00000000"
           netAssetOfBtc: NumberString,  // example: "0.00000000"
           repayEnabled: boolean,  // example: true
           totalAsset: NumberString  // example: "0.00000000"
         },
         symbol: string,  // example: "BTCUSDT"
         isolatedCreated: boolean,  // example: true
         enabled: boolean,  // example: true  // true-enabled, false-disabled
         marginLevel: NumberString,  // example: "0.00000000"
         marginLevelStatus: "EXCESSIVE"|"NORMAL"|"MARGIN_CALL"|"PRE_LIQUIDATION"|"FORCE_LIQUIDATION",  // example: "EXCESSIVE"  // "EXCESSIVE", "NORMAL", "MARGIN_CALL", "PRE_LIQUIDATION", "FORCE_LIQUIDATION"
         marginRatio: NumberString,  // example: "0.00000000"
         indexPrice: NumberString,  // example: "10000.00000000"
         liquidatePrice: NumberString,  // example: "1000.00000000"
         liquidateRate: NumberString,  // example: "1.00000000"
         tradeEnabled: boolean  // example: true
       }[],
     totalAssetOfBtc: NumberString,  // example: "0.00000000"
     totalLiabilityOfBtc: NumberString,  // example: "0.00000000"
     totalNetAssetOfBtc: NumberString  // example: "0.00000000"
    } | {  // If "symbols" is sent
     assets: {
         baseAsset: {
           asset: string,  // example: "BTC"
           borrowEnabled: boolean,  // example: true
           borrowed: NumberString,  // example: "0.00000000"
           free: NumberString,  // example: "0.00000000"
           interest: NumberString,  // example: "0.00000000"
           locked: NumberString,  // example: "0.00000000"
           netAsset: NumberString,  // example: "0.00000000"
           netAssetOfBtc: NumberString,  // example: "0.00000000"
           repayEnabled: boolean,  // example: true
           totalAsset: NumberString  // example: "0.00000000"
         },
         quoteAsset: {
           asset: string,  // example: "USDT"
           borrowEnabled: boolean,  // example: true
           borrowed: NumberString,  // example: "0.00000000"
           free: NumberString,  // example: "0.00000000"
           interest: NumberString,  // example: "0.00000000"
           locked: NumberString,  // example: "0.00000000"
           netAsset: NumberString,  // example: "0.00000000"
           netAssetOfBtc: NumberString,  // example: "0.00000000"
           repayEnabled: boolean,  // example: true
           totalAsset: NumberString  // example: "0.00000000"
         },
         symbol: string,  // example: "BTCUSDT"
         isolatedCreated: boolean,  // example: true
         enabled: boolean,  // example: true  // true-enabled, false-disabled
         marginLevel: NumberString,  // example: "0.00000000"
         marginLevelStatus: "EXCESSIVE"|"NORMAL"|"MARGIN_CALL"|"PRE_LIQUIDATION"|"FORCE_LIQUIDATION",  // example: "EXCESSIVE"  // "EXCESSIVE", "NORMAL", "MARGIN_CALL", "PRE_LIQUIDATION", "FORCE_LIQUIDATION"
         marginRatio: NumberString,  // example: "0.00000000"
         indexPrice: NumberString,  // example: "10000.00000000"
         liquidatePrice: NumberString,  // example: "1000.00000000"
         liquidateRate: NumberString,  // example: "1.00000000"
         tradeEnabled: boolean  // example: true
       }[]
    }>;
  
  
  queryIsolatedMarginAccountInfo(...args : any) {
      return this._sendRequest("/sapi/v1/margin/isolated/account", "GET", "USER_DATA", false, args, ["symbols", "recvWindow", "timestamp"], "queryIsolatedMarginAccountInfo");
  }
  
  
  /** Disable Isolated Margin Account (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#disable-isolated-margin-account-trade}
   * 
   * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24
   * hours.
   * 
   * EndPoint: /sapi/v1/margin/isolated/account
   * 
   * Weight(UID): 300
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow  -  No more than 60000
   * @param {LONG} timestamp
   */
  disableIsolatedMarginAccount(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["disableIsolatedMarginAccount"]>;
  
  
  /** Disable Isolated Margin Account (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#disable-isolated-margin-account-trade}
   * 
   * Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24
   * hours.
   * 
   * EndPoint: /sapi/v1/margin/isolated/account
   * 
   * Weight(UID): 300
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow  -  No more than 60000
   * @param {LONG} options.timestamp
   */
  disableIsolatedMarginAccount(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     success: boolean,  // example: true
     symbol: string  // example: "BTCUSDT"
    }>;
  
  
  disableIsolatedMarginAccount(...args : any) {
      return this._sendRequest("/sapi/v1/margin/isolated/account", "DELETE", "TRADE", true, args, ["symbol", "recvWindow", "timestamp"], "disableIsolatedMarginAccount");
  }
  
  
  /** Enable Isolated Margin Account (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#enable-isolated-margin-account-trade}
   * 
   * Enable isolated margin account for a specific symbol(Only supports activation of previously disabled accounts).
   * 
   * EndPoint: /sapi/v1/margin/isolated/account
   * 
   * Weight(UID): 300
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow  -  No more than 60000
   * @param {LONG} timestamp
   */
  enableIsolatedMarginAccount(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["enableIsolatedMarginAccount"]>;
  
  
  /** Enable Isolated Margin Account (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#enable-isolated-margin-account-trade}
   * 
   * Enable isolated margin account for a specific symbol(Only supports activation of previously disabled accounts).
   * 
   * EndPoint: /sapi/v1/margin/isolated/account
   * 
   * Weight(UID): 300
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow  -  No more than 60000
   * @param {LONG} options.timestamp
   */
  enableIsolatedMarginAccount(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     success: boolean,  // example: true
     symbol: string  // example: "BTCUSDT"
    }>;
  
  
  enableIsolatedMarginAccount(...args : any) {
      return this._sendRequest("/sapi/v1/margin/isolated/account", "POST", "TRADE", false, args, ["symbol", "recvWindow", "timestamp"], "enableIsolatedMarginAccount");
  }
  
  
  /** Query Enabled Isolated Margin Account Limit (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-enabled-isolated-margin-account-limit-user_data}
   * 
   * Query enabled isolated margin account limit.
   * 
   * EndPoint: /sapi/v1/margin/isolated/accountLimit
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow  -  No more than 60000
   * @param {LONG} timestamp
   */
  queryEnabledIsolatedMarginAccountLimit(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryEnabledIsolatedMarginAccountLimit"]>;
  
  
  /** Query Enabled Isolated Margin Account Limit (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-enabled-isolated-margin-account-limit-user_data}
   * 
   * Query enabled isolated margin account limit.
   * 
   * EndPoint: /sapi/v1/margin/isolated/accountLimit
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow  -  No more than 60000
   * @param {LONG} options.timestamp
   */
  queryEnabledIsolatedMarginAccountLimit(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     enabledAccount: number,  // example: 5
     maxAccount: number  // example: 20
    }>;
  
  
  queryEnabledIsolatedMarginAccountLimit(...args : any) {
      return this._sendRequest("/sapi/v1/margin/isolated/accountLimit", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryEnabledIsolatedMarginAccountLimit");
  }
  
  
  /** Get All Isolated Margin Symbol(MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-all-isolated-margin-symbol-market_data}
   * 
   * EndPoint: /sapi/v1/margin/isolated/allPairs
   * 
   * Weight(IP): 10
   * 
   * @param {string} symbol
   */
  getAllIsolatedMarginSymbol(symbol? :string)  : ReturnType<MyBinanceClient["getAllIsolatedMarginSymbol"]>;
  
  
  /** Get All Isolated Margin Symbol(MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-all-isolated-margin-symbol-market_data}
   * 
   * EndPoint: /sapi/v1/margin/isolated/allPairs
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.symbol
   */
  getAllIsolatedMarginSymbol(options? : { symbol? :string })
  : Promise<(
     {
       base: string,  // example: "BNB"
       isBuyAllowed: boolean,  // example: true
       isMarginTrade: boolean,  // example: true
       isSellAllowed: boolean,  // example: true
       quote: string,  // example: "BTC"
       symbol: string  // example: "BNBBTC"
     } |
     {
       base: string,  // example: "TRX"
       isBuyAllowed: boolean,  // example: true
       isMarginTrade: boolean,  // example: true
       isSellAllowed: boolean,  // example: true
       quote: string,  // example: "BTC"
       symbol: string,  // example: "TRXBTC"
       delistTime: number  // example: 1704973040
     }
    )[]>;
  
  
  getAllIsolatedMarginSymbol(...args : any) {
      return this._sendRequest("/sapi/v1/margin/isolated/allPairs", "GET", "MARKET_DATA", false, args, ["symbol"], "getAllIsolatedMarginSymbol");
  }
  
  
  /** Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#toggle-bnb-burn-on-spot-trade-and-margin-interest-user_data}
   * 
   * EndPoint: /sapi/v1/bnbBurn
   * 
   * Weight(IP): 1
   * 
   * @param {string} spotBNBBurn  -  "true" or "false"; Determines whether to use BNB to pay for trading fees on SPOT
   * @param {string} interestBNBBurn  -  "true" or "false"; Determines whether to use BNB to pay for margin loan's interest
   * @param {LONG} recvWindow  -  No more than 60000
   * @param {LONG} timestamp
   */
  toggleBNBBurnOnSpotTradeAndMarginInterest(spotBNBBurn? :string, interestBNBBurn? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["toggleBNBBurnOnSpotTradeAndMarginInterest"]>;
  
  
  /** Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#toggle-bnb-burn-on-spot-trade-and-margin-interest-user_data}
   * 
   * EndPoint: /sapi/v1/bnbBurn
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.spotBNBBurn  -  "true" or "false"; Determines whether to use BNB to pay for trading fees on SPOT
   * @param {string} options.interestBNBBurn  -  "true" or "false"; Determines whether to use BNB to pay for margin loan's interest
   * @param {LONG} options.recvWindow  -  No more than 60000
   * @param {LONG} options.timestamp
   */
  toggleBNBBurnOnSpotTradeAndMarginInterest(options? : { spotBNBBurn? :string, interestBNBBurn? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     spotBNBBurn: boolean,  // example: true
     interestBNBBurn: boolean  // example: false
    }>;
  
  
  toggleBNBBurnOnSpotTradeAndMarginInterest(...args : any) {
      return this._sendRequest("/sapi/v1/bnbBurn", "POST", "USER_DATA", false, args, ["spotBNBBurn", "interestBNBBurn", "recvWindow", "timestamp"], "toggleBNBBurnOnSpotTradeAndMarginInterest");
  }
  
  
  /** Get BNB Burn Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-bnb-burn-status-user_data}
   * 
   * EndPoint: /sapi/v1/bnbBurn
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow  -  No more than 60000
   * @param {LONG} timestamp
   */
  getBNBBurnStatus(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["getBNBBurnStatus"]>;
  
  
  /** Get BNB Burn Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-bnb-burn-status-user_data}
   * 
   * EndPoint: /sapi/v1/bnbBurn
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow  -  No more than 60000
   * @param {LONG} options.timestamp
   */
  getBNBBurnStatus(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     spotBNBBurn: boolean,  // example: true
     interestBNBBurn: boolean  // example: false
    }>;
  
  
  getBNBBurnStatus(...args : any) {
      return this._sendRequest("/sapi/v1/bnbBurn", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "getBNBBurnStatus");
  }
  
  
  /** Query Margin Interest Rate History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-interest-rate-history-user_data}
   * 
   * EndPoint: /sapi/v1/margin/interestRateHistory
   * 
   * Weight(IP): 1
   * 
   * @param {string} asset
   * @param {INT} vipLevel  -  Default: user's vip level
   * @param {LONG} startTime  -  Default: 7 days ago
   * @param {LONG} endTime  -  Default: present. Maximum range: 1 months.
   * @param {LONG} recvWindow  -  No more than 60000
   * @param {LONG} timestamp
   */
  queryMarginInterestRateHistory(asset :string, vipLevel? :INT, startTime? :LONG, endTime? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMarginInterestRateHistory"]>;
  
  
  /** Query Margin Interest Rate History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-interest-rate-history-user_data}
   * 
   * EndPoint: /sapi/v1/margin/interestRateHistory
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.asset
   * @param {INT} options.vipLevel  -  Default: user's vip level
   * @param {LONG} options.startTime  -  Default: 7 days ago
   * @param {LONG} options.endTime  -  Default: present. Maximum range: 1 months.
   * @param {LONG} options.recvWindow  -  No more than 60000
   * @param {LONG} options.timestamp
   */
  queryMarginInterestRateHistory(options : { asset :string, vipLevel? :INT, startTime? :LONG, endTime? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       asset: string,  // example: "BTC"
       dailyInterestRate: NumberString,  // example: "0.00025000"
       timestamp: number,  // example: 1611544731000
       vipLevel: number  // example: 1
     }[]>;
  
  
  queryMarginInterestRateHistory(...args : any) {
      return this._sendRequest("/sapi/v1/margin/interestRateHistory", "GET", "USER_DATA", false, args, ["asset", "vipLevel", "startTime", "endTime", "recvWindow", "timestamp"], "queryMarginInterestRateHistory");
  }
  
  
  /** Query Cross Margin Fee Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-cross-margin-fee-data-user_data}
   * 
   * Get cross margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee
   * 
   * EndPoint: /sapi/v1/margin/crossMarginData
   * 
   * Weight(IP): 
   *   1 when coin is specified; 
   *   5 when the coin parameter is omitted
   * 
   * @param {INT} vipLevel  -  when parameter vipLevel is not sent, it returns data associated with the user's specific config; when parameter vipLevel is sent, it returns the default tier data (assuming user is not logged in)
   * @param {string} coin
   * @param {LONG} recvWindow  -  No more than 60000
   * @param {LONG} timestamp
   */
  queryCrossMarginFeeData(vipLevel? :INT, coin? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryCrossMarginFeeData"]>;
  
  
  /** Query Cross Margin Fee Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-cross-margin-fee-data-user_data}
   * 
   * Get cross margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee
   * 
   * EndPoint: /sapi/v1/margin/crossMarginData
   * 
   * Weight(IP): 
   *   1 when coin is specified; 
   *   5 when the coin parameter is omitted
   * 
   * @param {INT} options.vipLevel  -  when parameter vipLevel is not sent, it returns data associated with the user's specific config; when parameter vipLevel is sent, it returns the default tier data (assuming user is not logged in)
   * @param {string} options.coin
   * @param {LONG} options.recvWindow  -  No more than 60000
   * @param {LONG} options.timestamp
   */
  queryCrossMarginFeeData(options? : { vipLevel? :INT, coin? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       vipLevel: number,  // example: 0
       coin: string,  // example: "BTC"
       transferIn: boolean,  // example: true
       borrowable: boolean,  // example: true
       dailyInterest: NumberString,  // example: "0.00026125"
       yearlyInterest: NumberString,  // example: "0.0953"
       borrowLimit: NumberString,  // example: "180"
       marginablePairs: string[]  // example: "BNBBTC"
     }[]>;
  
  
  queryCrossMarginFeeData(...args : any) {
      return this._sendRequest("/sapi/v1/margin/crossMarginData", "GET", "USER_DATA", false, args, ["vipLevel", "coin", "recvWindow", "timestamp"], "queryCrossMarginFeeData");
  }
  
  
  /** Query Isolated Margin Fee Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-isolated-margin-fee-data-user_data}
   * 
   * Get isolated margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee
   * 
   * EndPoint: /sapi/v1/margin/isolatedMarginData
   * 
   * Weight(IP): 
   *   1 when a single is specified; 
   *   10 when the symbol parameter is omitted
   * 
   * @param {INT} vipLevel  -  User's current specific margin data will be returned if vipLevel is omitted
   * @param {string} symbol
   * @param {LONG} recvWindow  -  No more than 60000
   * @param {LONG} timestamp
   */
  queryIsolatedMarginFeeData(vipLevel? :INT, symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryIsolatedMarginFeeData"]>;
  
  
  /** Query Isolated Margin Fee Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-isolated-margin-fee-data-user_data}
   * 
   * Get isolated margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee
   * 
   * EndPoint: /sapi/v1/margin/isolatedMarginData
   * 
   * Weight(IP): 
   *   1 when a single is specified; 
   *   10 when the symbol parameter is omitted
   * 
   * @param {INT} options.vipLevel  -  User's current specific margin data will be returned if vipLevel is omitted
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow  -  No more than 60000
   * @param {LONG} options.timestamp
   */
  queryIsolatedMarginFeeData(options? : { vipLevel? :INT, symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       vipLevel: number,  // example: 0
       symbol: string,  // example: "BTCUSDT"
       leverage: NumberString,  // example: "10"
       data: {
           coin: string,  // example: "BTC"
           dailyInterest: NumberString,  // example: "0.00026125"
           borrowLimit: NumberString  // example: "270"
         }[]
     }[]>;
  
  
  queryIsolatedMarginFeeData(...args : any) {
      return this._sendRequest("/sapi/v1/margin/isolatedMarginData", "GET", "USER_DATA", false, args, ["vipLevel", "symbol", "recvWindow", "timestamp"], "queryIsolatedMarginFeeData");
  }
  
  
  /** Query Isolated Margin Tier Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-isolated-margin-tier-data-user_data}
   * 
   * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data
   * 
   * EndPoint: /sapi/v1/margin/isolatedMarginTier
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {INTEGER} tier  -  All margin tier data will be returned if tier is omitted
   * @param {LONG} recvWindow  -  No more than 60000
   * @param {LONG} timestamp
   */
  queryIsolatedMarginTierData(symbol :string, tier? :INTEGER, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryIsolatedMarginTierData"]>;
  
  
  /** Query Isolated Margin Tier Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-isolated-margin-tier-data-user_data}
   * 
   * Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data
   * 
   * EndPoint: /sapi/v1/margin/isolatedMarginTier
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {INTEGER} options.tier  -  All margin tier data will be returned if tier is omitted
   * @param {LONG} options.recvWindow  -  No more than 60000
   * @param {LONG} options.timestamp
   */
  queryIsolatedMarginTierData(options : { symbol :string, tier? :INTEGER, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       tier: number,  // example: 1
       effectiveMultiple: NumberString,  // example: "10"
       initialRiskRatio: NumberString,  // example: "1.111"
       liquidationRiskRatio: NumberString,  // example: "1.05"
       baseAssetMaxBorrowable: NumberString,  // example: "9"
       quoteAssetMaxBorrowable: NumberString  // example: "70000"
     }[]>;
  
  
  queryIsolatedMarginTierData(...args : any) {
      return this._sendRequest("/sapi/v1/margin/isolatedMarginTier", "GET", "USER_DATA", false, args, ["symbol", "tier", "recvWindow", "timestamp"], "queryIsolatedMarginTierData");
  }
  
  
  /** Query Current Margin Order Count Usage (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-current-margin-order-count-usage-trade}
   * 
   * Displays the user's current margin order count usage for all intervals.
   * 
   * EndPoint: /sapi/v1/margin/rateLimit/order
   * 
   * Weight(IP): 20
   * 
   * @param {string} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {string} symbol  -  isolated symbol, mandatory for isolated margin
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryCurrentMarginOrderCountUsage(isIsolated? :string, symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryCurrentMarginOrderCountUsage"]>;
  
  
  /** Query Current Margin Order Count Usage (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-current-margin-order-count-usage-trade}
   * 
   * Displays the user's current margin order count usage for all intervals.
   * 
   * EndPoint: /sapi/v1/margin/rateLimit/order
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
   * @param {string} options.symbol  -  isolated symbol, mandatory for isolated margin
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryCurrentMarginOrderCountUsage(options? : { isIsolated? :string, symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       rateLimitType: RateLimitType,  // example: "ORDERS"
       interval: RateLimitInterval,  // example: "SECOND"
       intervalNum: number,  // example: 10
       limit: number,  // example: 10000
       count: number  // example: 0
     }[]>;
  
  
  queryCurrentMarginOrderCountUsage(...args : any) {
      return this._sendRequest("/sapi/v1/margin/rateLimit/order", "GET", "TRADE", false, args, ["isIsolated", "symbol", "recvWindow", "timestamp"], "queryCurrentMarginOrderCountUsage");
  }
  
  
  /** Cross margin collateral ratio (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cross-margin-collateral-ratio-market_data}
   * 
   * EndPoint: /sapi/v1/margin/crossMarginCollateralRatio
   * 
   * Weight(IP): 100
   * 
   */
  crossMarginCollateralRatio() : Promise<(
     {
       collaterals: (
         {
           minUsdValue: NumberString,  // example: "0"
           maxUsdValue: NumberString,  // example: "13000000"
           discountRate: NumberString  // example: "1"
         } |
         {
           minUsdValue: NumberString,  // example: "20000000"
           discountRate: NumberString  // example: "0"
         }
       )[],
       assetNames: string[]  // example: "BNX"
     } |
     {
       collaterals: {
           minUsdValue: NumberString,  // example: "0"
           discountRate: NumberString  // example: "1"
         }[],
       assetNames: string[]  // example: "BTC"
     }
    )[]> {
      return this._sendRequest("/sapi/v1/margin/crossMarginCollateralRatio", "GET", "MARKET_DATA", false, [], [], "crossMarginCollateralRatio");
  }
  
  
  /** Get Small Liability Exchange Coin List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-small-liability-exchange-coin-list-user_data}
   * 
   * Query the coins which can be small liability exchange
   * 
   * EndPoint: /sapi/v1/margin/exchange-small-liability
   * 
   * Weight(IP): 100
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSmallLiabilityExchangeCoinList(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getSmallLiabilityExchangeCoinList"]>;
  
  
  /** Get Small Liability Exchange Coin List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-small-liability-exchange-coin-list-user_data}
   * 
   * Query the coins which can be small liability exchange
   * 
   * EndPoint: /sapi/v1/margin/exchange-small-liability
   * 
   * Weight(IP): 100
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSmallLiabilityExchangeCoinList(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       asset: string,  // example: "ETH"
       interest: NumberString,  // example: "0.00083334"
       principal: NumberString,  // example: "0.001"
       liabilityAsset: string,  // example: "USDT"
       liabilityQty: number  // example: 0.3552
     }[]>;
  
  
  getSmallLiabilityExchangeCoinList(...args : any) {
      return this._sendRequest("/sapi/v1/margin/exchange-small-liability", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "getSmallLiabilityExchangeCoinList");
  }
  
  
  /** Small Liability Exchange (MARGIN)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#small-liability-exchange-margin}
   * 
   * Cross Margin Small Liability Exchange
   * 
   * EndPoint: /sapi/v1/margin/exchange-small-liability
   * 
   * Weight(UID): 3000
   * 
   * @param {[]} assetNames  -  The assets list of small liability exchange， Example: assetNames = BTC,ETH
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  smallLiabilityExchange(assetNames :[], recvWindow :LONG|undefined, timestamp :LONG)  : Promise<unknown>;
  
  
  /** Small Liability Exchange (MARGIN)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#small-liability-exchange-margin}
   * 
   * Cross Margin Small Liability Exchange
   * 
   * EndPoint: /sapi/v1/margin/exchange-small-liability
   * 
   * Weight(UID): 3000
   * 
   * @param {[]} options.assetNames  -  The assets list of small liability exchange， Example: assetNames = BTC,ETH
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  smallLiabilityExchange(options : { assetNames :[], recvWindow? :LONG, timestamp :LONG })  : Promise<unknown>;
  
  
  smallLiabilityExchange(...args : any) {
      return this._sendRequest("/sapi/v1/margin/exchange-small-liability", "POST", "MARGIN", false, args, ["assetNames", "recvWindow", "timestamp"], "smallLiabilityExchange");
  }
  
  
  /** Get Small Liability Exchange History  (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-small-liability-exchange-history-user_data}
   * 
   * Get Small liability Exchange History 
   * 
   * EndPoint: /sapi/v1/margin/exchange-small-liability-history
   * 
   * Weight(UID): 100
   * 
   * @param {INT} current  -  Currently querying page. Start from 1. Default:1
   * @param {INT} size  -  Default:10, Max:100
   * @param {LONG} startTime  -  Default: 30 days from current timestamp
   * @param {LONG} endTime  -  Default: present timestamp
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSmallLiabilityExchangeHistory(current :INT, size :INT, startTime? :LONG, endTime? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getSmallLiabilityExchangeHistory"]>;
  
  
  /** Get Small Liability Exchange History  (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-small-liability-exchange-history-user_data}
   * 
   * Get Small liability Exchange History 
   * 
   * EndPoint: /sapi/v1/margin/exchange-small-liability-history
   * 
   * Weight(UID): 100
   * 
   * @param {INT} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {INT} options.size  -  Default:10, Max:100
   * @param {LONG} options.startTime  -  Default: 30 days from current timestamp
   * @param {LONG} options.endTime  -  Default: present timestamp
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSmallLiabilityExchangeHistory(options : { current :INT, size :INT, startTime? :LONG, endTime? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 1
     rows: {
         asset: string,  // example: "ETH"
         amount: NumberString,  // example: "0.00083434"
         targetAsset: string,  // example: "BUSD"
         targetAmount: NumberString,  // example: "1.37576819"
         bizType: string,  // example: "EXCHANGE_SMALL_LIABILITY"
         timestamp: number  // example: 1672801339253
       }[]
    }>;
  
  
  getSmallLiabilityExchangeHistory(...args : any) {
      return this._sendRequest("/sapi/v1/margin/exchange-small-liability-history", "GET", "USER_DATA", false, args, ["current", "size", "startTime", "endTime", "recvWindow", "timestamp"], "getSmallLiabilityExchangeHistory");
  }
  
  
  /** Get a future hourly interest rate  (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-a-future-hourly-interest-rate-user_data}
   * 
   * Get user the next hourly estimate interest
   * 
   * EndPoint: /sapi/v1/margin/next-hourly-interest-rate
   * 
   * Weight(IP): 100
   * 
   * @param {string} assets  -  List of assets, separated by commas, up to 20
   * @param {boolean} isIsolated  -  for isolated margin or not, "TRUE", "FALSE"
   */
  getAFutureHourlyInterestRate(assets :string, isIsolated :boolean)
  : ReturnType<MyBinanceClient["getAFutureHourlyInterestRate"]>;
  
  
  /** Get a future hourly interest rate  (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-a-future-hourly-interest-rate-user_data}
   * 
   * Get user the next hourly estimate interest
   * 
   * EndPoint: /sapi/v1/margin/next-hourly-interest-rate
   * 
   * Weight(IP): 100
   * 
   * @param {string} options.assets  -  List of assets, separated by commas, up to 20
   * @param {boolean} options.isIsolated  -  for isolated margin or not, "TRUE", "FALSE"
   */
  getAFutureHourlyInterestRate(options : { assets :string, isIsolated :boolean })
  : Promise<{
       asset: string,  // example: "BTC"
       nextHourlyInterestRate: NumberString  // example: "0.00000571"
     }[]>;
  
  
  getAFutureHourlyInterestRate(...args : any) {
      return this._sendRequest("/sapi/v1/margin/next-hourly-interest-rate", "GET", "USER_DATA", false, args, ["assets", "isIsolated"], "getAFutureHourlyInterestRate");
  }
  
  
  /** Get cross or isolated margin capital flow(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-cross-or-isolated-margin-capital-flow-user_data}
   * 
   * Get cross or isolated margin capital flow
   * 
   * EndPoint: /sapi/v1/margin/capital-flow
   * 
   * Weight(IP): 100
   * 
   * @param {string} asset
   * @param {string} symbol  -  Required when querying isolated data
   * @param {string} type
   * @param {LONG} startTime  -  Only supports querying the data of the last 90 days
   * @param {LONG} endTime
   * @param {LONG} fromId  -  
   * If fromId is set, the data with id > fromId will be returned. Otherwise the latest data will be returned
   * @param {LONG} limit  -  The number of data items returned each time is limited. Default 500; Max 1000.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getCrossOrIsolatedMarginCapitalFlow(asset? :string, symbol? :string, type? :string, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getCrossOrIsolatedMarginCapitalFlow"]>;
  
  
  /** Get cross or isolated margin capital flow(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-cross-or-isolated-margin-capital-flow-user_data}
   * 
   * Get cross or isolated margin capital flow
   * 
   * EndPoint: /sapi/v1/margin/capital-flow
   * 
   * Weight(IP): 100
   * 
   * @param {string} options.asset
   * @param {string} options.symbol  -  Required when querying isolated data
   * @param {string} options.type
   * @param {LONG} options.startTime  -  Only supports querying the data of the last 90 days
   * @param {LONG} options.endTime
   * @param {LONG} options.fromId  -  
   * If fromId is set, the data with id > fromId will be returned. Otherwise the latest data will be returned
   * @param {LONG} options.limit  -  The number of data items returned each time is limited. Default 500; Max 1000.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getCrossOrIsolatedMarginCapitalFlow(options? : { asset? :string, symbol? :string, type? :string, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       id: number,  // example: 123456
       tranId: number,  // example: 123123
       timestamp: number,  // example: 1691116657000
       asset: string,  // example: "USDT"
       symbol: string,  // example: "BTCUSDT"
       type: string,  // example: "BORROW"
       amount: NumberString  // example: "101"
     }[]>;
  
  
  getCrossOrIsolatedMarginCapitalFlow(...args : any) {
      return this._sendRequest("/sapi/v1/margin/capital-flow", "GET", "USER_DATA", false, args, ["asset", "symbol", "type", "startTime", "endTime", "fromId", "limit", "recvWindow", "timestamp"], "getCrossOrIsolatedMarginCapitalFlow");
  }
  
  
  /** Get tokens or symbols delist schedule for cross margin and isolated margin (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-tokens-or-symbols-delist-schedule-for-cross-margin-and-isolated-margin-market_data}
   * 
   * Get tokens or symbols delist schedule for cross margin and isolated margin
   * 
   * EndPoint: /sapi/v1/margin/delist-schedule
   * 
   * Weight(IP): 100
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getTokensOrSymbolsDelistScheduleForCrossMarginAndIsolatedMargin(recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["getTokensOrSymbolsDelistScheduleForCrossMarginAndIsolatedMargin"]>;
  
  
  /** Get tokens or symbols delist schedule for cross margin and isolated margin (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-tokens-or-symbols-delist-schedule-for-cross-margin-and-isolated-margin-market_data}
   * 
   * Get tokens or symbols delist schedule for cross margin and isolated margin
   * 
   * EndPoint: /sapi/v1/margin/delist-schedule
   * 
   * Weight(IP): 100
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getTokensOrSymbolsDelistScheduleForCrossMarginAndIsolatedMargin(options : { recvWindow? :LONG, timestamp :LONG })
  : Promise<(
     {
       delistTime: number,  // example: 1686161202000
       crossMarginAssets: string[]  // example: "BTC",
       isolatedMarginSymbols: string[]  // example: "ADAUSDT"
     } |
     {
       delistTime: number,  // example: 1686222232000
       crossMarginAssets: string[]  // example: "ADA",
       isolatedMarginSymbols: unknown[]
     }
    )[]>;
  
  
  getTokensOrSymbolsDelistScheduleForCrossMarginAndIsolatedMargin(...args : any) {
      return this._sendRequest("/sapi/v1/margin/delist-schedule", "GET", "MARKET_DATA", false, args, ["recvWindow", "timestamp"], "getTokensOrSymbolsDelistScheduleForCrossMarginAndIsolatedMargin");
  }
  
  
  /** Query Margin Available Inventory (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-available-inventory-user_data}
   * 
   * Margin available Inventory query
   * 
   * EndPoint: /sapi/v1/margin/available-inventory
   * 
   * Weight(UID): 50
   * 
   * @param {string} type  -  MARGIN,ISOLATED
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryMarginAvailableInventory(type :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryMarginAvailableInventory"]>;
  
  
  /** Query Margin Available Inventory (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-margin-available-inventory-user_data}
   * 
   * Margin available Inventory query
   * 
   * EndPoint: /sapi/v1/margin/available-inventory
   * 
   * Weight(UID): 50
   * 
   * @param {string} options.type  -  MARGIN,ISOLATED
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryMarginAvailableInventory(options : { type :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     assets: {
       MATIC: NumberString,  // example: "100000000"
       STPT: NumberString,  // example: "100000000"
       TVK: NumberString,  // example: "100000000"
       SHIB: NumberString  // example: "97409653"
     },
     updateTime: number  // example: 1699272487
    }>;
  
  
  queryMarginAvailableInventory(...args : any) {
      return this._sendRequest("/sapi/v1/margin/available-inventory", "GET", "USER_DATA", false, args, ["type", "recvWindow", "timestamp"], "queryMarginAvailableInventory");
  }
  
  
  /** Margin manual liquidation(MARGIN)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-manual-liquidation-margin}
   * 
   * Margin manual liquidation
   * 
   * EndPoint: /sapi/v1/margin/manual-liquidation
   * 
   * Weight(UID): 3000
   * 
   * @param {string} type  -  MARGIN,ISOLATED
   * @param {string} symbol  -  When type selects ISOLATED, symbol must be filled in
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  marginManualLiquidation(type :string, symbol :string|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["marginManualLiquidation"]>;
  
  
  /** Margin manual liquidation(MARGIN)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#margin-manual-liquidation-margin}
   * 
   * Margin manual liquidation
   * 
   * EndPoint: /sapi/v1/margin/manual-liquidation
   * 
   * Weight(UID): 3000
   * 
   * @param {string} options.type  -  MARGIN,ISOLATED
   * @param {string} options.symbol  -  When type selects ISOLATED, symbol must be filled in
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  marginManualLiquidation(options : { type :string, symbol? :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
       asset: string,  // example: "ETH"
       interest: NumberString,  // example: "0.00083334"
       principal: NumberString,  // example: "0.001"
       liabilityAsset: string,  // example: "USDT"
       liabilityQty: number  // example: 0.3552
     }[]>;
  
  
  marginManualLiquidation(...args : any) {
      return this._sendRequest("/sapi/v1/margin/manual-liquidation", "POST", "MARGIN", false, args, ["type", "symbol", "recvWindow", "timestamp"], "marginManualLiquidation");
  }
  
  
  /** Query Liability Coin Leverage Bracket in Cross Margin Pro Mode(MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-liability-coin-leverage-bracket-in-cross-margin-pro-mode-market_data}
   * 
   * Liability Coin Leverage Bracket in Cross Margin Pro Mode
   * 
   * EndPoint: /sapi/v1/margin/leverageBracket
   * 
   * Weight(IP): 1
   * 
   */
  queryLiabilityCoinLeverageBracketInCrossMarginProMode() : Promise<{
       assetNames: string[]  // example: "SHIB",
       rank: number,  // example: 1
       brackets: {
           leverage: number,  // example: 10
           maxDebt: number,  // example: 1000000
           maintenanceMarginRate: number,  // example: 0.02
           initialMarginRate: number,  // example: 0.1112
           fastNum: number  // example: 0
         }[]
     }[]> {
      return this._sendRequest("/sapi/v1/margin/leverageBracket", "GET", "MARKET_DATA", false, [], [], "queryLiabilityCoinLeverageBracketInCrossMarginProMode");
  }
  
  
  
  //***** LISTEN KEY (SPOT) *****
  
  
  /** Create a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#create-a-listenkey-user_stream}
   * 
   * EndPoint: /api/v3/userDataStream
   * 
   * Weight(IP): 2
   * 
   */
  createAListenKey_Spot() : Promise<{
     listenKey: string  // example: "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
    }> {
      return this._sendRequest("/api/v3/userDataStream", "POST", "USER_STREAM", false, [], [], "createAListenKey_Spot");
  }
  
  
  /** Ping/Keep-alive a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#ping-keep-alive-a-listenkey-user_stream}
   * 
   * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.
   * 
   * EndPoint: /api/v3/userDataStream
   * 
   * Weight(IP): 2
   * 
   * @param {string} listenKey
   */
  pingKeepAliveAListenKey_Spot(listenKey :string)  : Promise<{    }>;
  
  
  /** Ping/Keep-alive a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#ping-keep-alive-a-listenkey-user_stream}
   * 
   * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.
   * 
   * EndPoint: /api/v3/userDataStream
   * 
   * Weight(IP): 2
   * 
   * @param {string} options.listenKey
   */
  pingKeepAliveAListenKey_Spot(options : { listenKey :string })  : Promise<{    }>;
  
  
  pingKeepAliveAListenKey_Spot(...args : any) {
      return this._sendRequest("/api/v3/userDataStream", "PUT", "USER_STREAM", false, args, ["listenKey"], "pingKeepAliveAListenKey_Spot");
  }
  
  
  /** Close a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#close-a-listenkey-user_stream}
   * 
   * Close out a user data stream.
   * 
   * EndPoint: /api/v3/userDataStream
   * 
   * Weight(IP): 2
   * 
   * @param {string} listenKey
   */
  closeAListenKey_Spot(listenKey :string)  : Promise<{    }>;
  
  
  /** Close a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#close-a-listenkey-user_stream}
   * 
   * Close out a user data stream.
   * 
   * EndPoint: /api/v3/userDataStream
   * 
   * Weight(IP): 2
   * 
   * @param {string} options.listenKey
   */
  closeAListenKey_Spot(options : { listenKey :string })  : Promise<{    }>;
  
  
  closeAListenKey_Spot(...args : any) {
      return this._sendRequest("/api/v3/userDataStream", "DELETE", "USER_STREAM", false, args, ["listenKey"], "closeAListenKey_Spot");
  }
  
  
  
  //***** LISTEN KEY (MARGIN) *****
  
  
  /** Create a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#create-a-listenkey-user_stream-2}
   * 
   * EndPoint: /sapi/v1/userDataStream
   * 
   * Weight(IP): 1
   * 
   */
  createAListenKey_Margin() : Promise<{
     listenKey: string  // example: "T3ee22BIYuWqmvne0HNq2A2WsFlEtLhvWCtItw6ffhhdmjifQ2tRbuKkTHhr"
    }> {
      return this._sendRequest("/sapi/v1/userDataStream", "POST", "USER_STREAM", false, [], [], "createAListenKey_Margin");
  }
  
  
  /** Ping/Keep-alive a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#ping-keep-alive-a-listenkey-user_stream-2}
   * 
   * EndPoint: /sapi/v1/userDataStream
   * 
   * Weight(IP): 1
   * 
   * @param {string} listenKey
   */
  pingKeepAliveAListenKey_Margin(listenKey :string)  : Promise<{    }>;
  
  
  /** Ping/Keep-alive a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#ping-keep-alive-a-listenkey-user_stream-2}
   * 
   * EndPoint: /sapi/v1/userDataStream
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.listenKey
   */
  pingKeepAliveAListenKey_Margin(options : { listenKey :string })  : Promise<{    }>;
  
  
  pingKeepAliveAListenKey_Margin(...args : any) {
      return this._sendRequest("/sapi/v1/userDataStream", "PUT", "USER_STREAM", false, args, ["listenKey"], "pingKeepAliveAListenKey_Margin");
  }
  
  
  /** Close a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#close-a-listenkey-user_stream-2}
   * 
   * EndPoint: /sapi/v1/userDataStream
   * 
   * Weight(IP): 1
   * 
   * @param {string} listenKey
   */
  closeAListenKey_Margin(listenKey :string)  : Promise<{    }>;
  
  
  /** Close a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#close-a-listenkey-user_stream-2}
   * 
   * EndPoint: /sapi/v1/userDataStream
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.listenKey
   */
  closeAListenKey_Margin(options : { listenKey :string })  : Promise<{    }>;
  
  
  closeAListenKey_Margin(...args : any) {
      return this._sendRequest("/sapi/v1/userDataStream", "DELETE", "USER_STREAM", false, args, ["listenKey"], "closeAListenKey_Margin");
  }
  
  
  
  //***** LISTEN KEY (ISOLATED MARGIN) *****
  
  
  /** Generate a Listen Key (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#generate-a-listen-key-user_stream}
   * 
   * EndPoint: /sapi/v1/userDataStream/isolated
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   */
  generateAListenKey_MarginIso(symbol :string)  : ReturnType<MyBinanceClient["generateAListenKey_MarginIso"]>;
  
  
  /** Generate a Listen Key (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#generate-a-listen-key-user_stream}
   * 
   * EndPoint: /sapi/v1/userDataStream/isolated
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   */
  generateAListenKey_MarginIso(options : { symbol :string })
  : Promise<{
     listenKey: string  // example: "T3ee22BIYuWqmvne0HNq2A2WsFlEtLhvWCtItw6ffhhdmjifQ2tRbuKkTHhr"
    }>;
  
  
  generateAListenKey_MarginIso(...args : any) {
      return this._sendRequest("/sapi/v1/userDataStream/isolated", "POST", "USER_STREAM", false, args, ["symbol"], "generateAListenKey_MarginIso");
  }
  
  
  /** Ping/Keep-alive a Listen Key  (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#ping-keep-alive-a-listen-key-user_stream}
   * 
   * EndPoint: /sapi/v1/userDataStream/isolated
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {string} listenKey
   */
  pingKeepAliveAListenKey_MarginIso(symbol :string, listenKey :string)  : Promise<{    }>;
  
  
  /** Ping/Keep-alive a Listen Key  (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#ping-keep-alive-a-listen-key-user_stream}
   * 
   * EndPoint: /sapi/v1/userDataStream/isolated
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {string} options.listenKey
   */
  pingKeepAliveAListenKey_MarginIso(options : { symbol :string, listenKey :string })  : Promise<{    }>;
  
  
  pingKeepAliveAListenKey_MarginIso(...args : any) {
      return this._sendRequest("/sapi/v1/userDataStream/isolated", "PUT", "USER_STREAM", false, args, ["symbol", "listenKey"], "pingKeepAliveAListenKey_MarginIso");
  }
  
  
  /** Close a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#close-a-listenkey-user_stream-3}
   * 
   * EndPoint: /sapi/v1/userDataStream/isolated
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {string} listenKey
   */
  closeAListenKey_MarginIso(symbol :string, listenKey :string)  : Promise<{    }>;
  
  
  /** Close a ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#close-a-listenkey-user_stream-3}
   * 
   * EndPoint: /sapi/v1/userDataStream/isolated
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {string} options.listenKey
   */
  closeAListenKey_MarginIso(options : { symbol :string, listenKey :string })  : Promise<{    }>;
  
  
  closeAListenKey_MarginIso(...args : any) {
      return this._sendRequest("/sapi/v1/userDataStream/isolated", "DELETE", "USER_STREAM", false, args, ["symbol", "listenKey"], "closeAListenKey_MarginIso");
  }
  
  
  
  //***** LISTEN KEY *****
  
  
  /** Create a Margin ListenKey (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#create-a-margin-listenkey-user_stream}
   * 
   * Start a new margin user data stream.
   * 
   * EndPoint: /sapi/v1/margin/listen-key
   * 
   * Weight(UID): 1
   * 
   */
  createAMarginListenKey() : Promise<{
     listenKey: string  // example: "T3ee22BIYuWqmvne0HNq2A2WsFlEtLhvWCtItw6ffhhd"
    }> {
      return this._sendRequest("/sapi/v1/margin/listen-key", "POST", "USER_STREAM", false, [], [], "createAMarginListenKey");
  }
  
  
  /** Keep-alive a Margin ListenKey  (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#keep-alive-a-margin-listenkey-user_stream}
   * 
   * Keepalive a user data stream to prevent a time out.
   * 
   * EndPoint: /sapi/v1/margin/listen-key
   * 
   * Weight(UID): 1
   * 
   * @param {string} listenKey
   */
  keepAliveAMarginListenKey(listenKey :string)  : Promise<{    }>;
  
  
  /** Keep-alive a Margin ListenKey  (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#keep-alive-a-margin-listenkey-user_stream}
   * 
   * Keepalive a user data stream to prevent a time out.
   * 
   * EndPoint: /sapi/v1/margin/listen-key
   * 
   * Weight(UID): 1
   * 
   * @param {string} options.listenKey
   */
  keepAliveAMarginListenKey(options : { listenKey :string })  : Promise<{    }>;
  
  
  keepAliveAMarginListenKey(...args : any) {
      return this._sendRequest("/sapi/v1/margin/listen-key", "PUT", "USER_STREAM", false, args, ["listenKey"], "keepAliveAMarginListenKey");
  }
  
  
  /** Close a Margin ListenKey(USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#close-a-margin-listenkey-user_stream}
   * 
   * Close out a user data stream.
   * 
   * EndPoint: /sapi/v1/margin/listen-key
   * 
   * Weight(UID): 3000
   * 
   * @param {string} listenKey
   */
  closeAMarginListenKey(listenKey :string)  : Promise<{    }>;
  
  
  /** Close a Margin ListenKey(USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#close-a-margin-listenkey-user_stream}
   * 
   * Close out a user data stream.
   * 
   * EndPoint: /sapi/v1/margin/listen-key
   * 
   * Weight(UID): 3000
   * 
   * @param {string} options.listenKey
   */
  closeAMarginListenKey(options : { listenKey :string })  : Promise<{    }>;
  
  
  closeAMarginListenKey(...args : any) {
      return this._sendRequest("/sapi/v1/margin/listen-key", "DELETE", "USER_STREAM", false, args, ["listenKey"], "closeAMarginListenKey");
  }
  
  
  
  //***** Simple Earn Endpoints *****
  
  
  /** Get Simple Earn Flexible Product List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-simple-earn-flexible-product-list-user_data}
   * 
   * Get available Simple Earn flexible product list
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/list
   * 
   * Weight(IP): 150
   * 
   * @param {string} asset
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSimpleEarnFlexibleProductList(asset? :string, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getSimpleEarnFlexibleProductList"]>;
  
  
  /** Get Simple Earn Flexible Product List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-simple-earn-flexible-product-list-user_data}
   * 
   * Get available Simple Earn flexible product list
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/list
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.asset
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSimpleEarnFlexibleProductList(options? : { asset? :string, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         asset: string,  // example: "BTC"
         latestAnnualPercentageRate: NumberString,  // example: "0.05000000"
         tierAnnualPercentageRate: {
           "0-5BTC": number,
           "5-10BTC": number
         },
         airDropPercentageRate: NumberString,  // example: "0.05000000"
         canPurchase: boolean,  // example: true
         canRedeem: boolean,  // example: true
         isSoldOut: boolean,  // example: true
         hot: boolean,  // example: true
         minPurchaseAmount: NumberString,  // example: "0.01000000"
         productId: string,  // example: "BTC001"
         subscriptionStartTime: NumberString,  // example: "1646182276000"
         status: string  // example: "PURCHASING"
       }[],
     total: number  // example: 1
    }>;
  
  
  getSimpleEarnFlexibleProductList(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/list", "GET", "USER_DATA", false, args, ["asset", "current", "size", "recvWindow", "timestamp"], "getSimpleEarnFlexibleProductList");
  }
  
  
  /** Get Simple Earn Locked Product List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-simple-earn-locked-product-list-user_data}
   * 
   * Get available Simple Earn locked product list
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/list
   * 
   * Weight(IP): 150
   * 
   * @param {string} asset
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSimpleEarnLockedProductList(asset? :string, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getSimpleEarnLockedProductList"]>;
  
  
  /** Get Simple Earn Locked Product List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-simple-earn-locked-product-list-user_data}
   * 
   * Get available Simple Earn locked product list
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/list
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.asset
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSimpleEarnLockedProductList(options? : { asset? :string, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         projectId: string,  // example: "Axs*90"
         detail: {
           asset: string,  // example: "AXS"
           rewardAsset: string,  // example: "AXS"
           duration: number,  // example: 90
           renewable: boolean,  // example: true
           isSoldOut: boolean,  // example: true
           apr: NumberString,  // example: "1.2069"
           status: string,  // example: "CREATED"
           subscriptionStartTime: NumberString,  // example: "1646182276000"
           extraRewardAsset: string,  // example: "BNB"
           extraRewardAPR: NumberString  // example: "0.23"
         },
         quota: {
           totalPersonalQuota: NumberString,  // example: "2"
           minimum: NumberString  // example: "0.001"
         }
       }[],
     total: number  // example: 1
    }>;
  
  
  getSimpleEarnLockedProductList(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/locked/list", "GET", "USER_DATA", false, args, ["asset", "current", "size", "recvWindow", "timestamp"], "getSimpleEarnLockedProductList");
  }
  
  
  /** Subscribe Flexible Product (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#subscribe-flexible-product-trade}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/subscribe
   * 
   * Weight(IP): 1
   * 
   * @param {string} productId
   * @param {DECIMAL} amount
   * @param {boolean} autoSubscribe  -  true or false, default true.
   * @param {"SPOT"|"FUND"|"ALL"} sourceAccount  -  SPOT,FUND,ALL, default SPOT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  subscribeFlexibleProduct(productId :string, amount :DECIMAL, autoSubscribe? :boolean, sourceAccount? :"SPOT"|"FUND"|"ALL", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["subscribeFlexibleProduct"]>;
  
  
  /** Subscribe Flexible Product (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#subscribe-flexible-product-trade}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/subscribe
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.productId
   * @param {DECIMAL} options.amount
   * @param {boolean} options.autoSubscribe  -  true or false, default true.
   * @param {"SPOT"|"FUND"|"ALL"} options.sourceAccount  -  SPOT,FUND,ALL, default SPOT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  subscribeFlexibleProduct(options : { productId :string, amount :DECIMAL, autoSubscribe? :boolean, sourceAccount? :"SPOT"|"FUND"|"ALL", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     purchaseId: number,  // example: 40607
     success: boolean  // example: true
    }>;
  
  
  subscribeFlexibleProduct(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/subscribe", "POST", "TRADE", false, args, ["productId", "amount", "autoSubscribe", "sourceAccount", "recvWindow", "timestamp"], "subscribeFlexibleProduct");
  }
  
  
  /** Subscribe Locked Product (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#subscribe-locked-product-trade}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/subscribe
   * 
   * Weight(IP): 1
   * 
   * @param {string} projectId
   * @param {DECIMAL} amount
   * @param {boolean} autoSubscribe  -  true or false, default true.
   * @param {"SPOT"|"FUND"|"ALL"} sourceAccount  -  SPOT,FUND,ALL, default SPOT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  subscribeLockedProduct(projectId :string, amount :DECIMAL, autoSubscribe? :boolean, sourceAccount? :"SPOT"|"FUND"|"ALL", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["subscribeLockedProduct"]>;
  
  
  /** Subscribe Locked Product (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#subscribe-locked-product-trade}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/subscribe
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.projectId
   * @param {DECIMAL} options.amount
   * @param {boolean} options.autoSubscribe  -  true or false, default true.
   * @param {"SPOT"|"FUND"|"ALL"} options.sourceAccount  -  SPOT,FUND,ALL, default SPOT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  subscribeLockedProduct(options : { projectId :string, amount :DECIMAL, autoSubscribe? :boolean, sourceAccount? :"SPOT"|"FUND"|"ALL", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     purchaseId: number,  // example: 40607
     positionId: NumberString,  // example: "12345"
     success: boolean  // example: true
    }>;
  
  
  subscribeLockedProduct(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/locked/subscribe", "POST", "TRADE", false, args, ["projectId", "amount", "autoSubscribe", "sourceAccount", "recvWindow", "timestamp"], "subscribeLockedProduct");
  }
  
  
  /** Redeem Flexible Product (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#redeem-flexible-product-trade}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/redeem
   * 
   * Weight(IP): 1
   * 
   * @param {string} productId
   * @param {boolean} redeemAll  -  true or false, default to false
   * @param {DECIMAL} amount  -  if redeemAll is false, amount is mandatory
   * @param {"SPOT"|"FUND"} destAccount  -  SPOT,FUND, default SPOT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  redeemFlexibleProduct(productId :string, redeemAll? :boolean, amount? :DECIMAL, destAccount? :"SPOT"|"FUND", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["redeemFlexibleProduct"]>;
  
  
  /** Redeem Flexible Product (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#redeem-flexible-product-trade}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/redeem
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.productId
   * @param {boolean} options.redeemAll  -  true or false, default to false
   * @param {DECIMAL} options.amount  -  if redeemAll is false, amount is mandatory
   * @param {"SPOT"|"FUND"} options.destAccount  -  SPOT,FUND, default SPOT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  redeemFlexibleProduct(options : { productId :string, redeemAll? :boolean, amount? :DECIMAL, destAccount? :"SPOT"|"FUND", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     redeemId: number,  // example: 40607
     success: boolean  // example: true
    }>;
  
  
  redeemFlexibleProduct(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/redeem", "POST", "TRADE", false, args, ["productId", "redeemAll", "amount", "destAccount", "recvWindow", "timestamp"], "redeemFlexibleProduct");
  }
  
  
  /** Redeem Locked Product (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#redeem-locked-product-trade}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/redeem
   * 
   * Weight(IP): 1
   * 
   * @param {string} positionId  -  "1234"
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  redeemLockedProduct(positionId :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["redeemLockedProduct"]>;
  
  
  /** Redeem Locked Product (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#redeem-locked-product-trade}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/redeem
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.positionId  -  "1234"
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  redeemLockedProduct(options : { positionId :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     redeemId: number,  // example: 40607
     success: boolean  // example: true
    }>;
  
  
  redeemLockedProduct(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/locked/redeem", "POST", "TRADE", false, args, ["positionId", "recvWindow", "timestamp"], "redeemLockedProduct");
  }
  
  
  /** Get Flexible Product Position (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-product-position-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/position
   * 
   * Weight(IP): 150
   * 
   * @param {string} asset
   * @param {string} productId
   * @param {LONG} current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFlexibleProductPosition(asset? :string, productId? :string, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFlexibleProductPosition"]>;
  
  
  /** Get Flexible Product Position (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-product-position-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/position
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.asset
   * @param {string} options.productId
   * @param {LONG} options.current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFlexibleProductPosition(options? : { asset? :string, productId? :string, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         totalAmount: NumberString,  // example: "75.46000000"
         tierAnnualPercentageRate: {
           "0-5BTC": number,
           "5-10BTC": number
         },
         latestAnnualPercentageRate: NumberString,  // example: "0.02599895"
         yesterdayAirdropPercentageRate: NumberString,  // example: "0.02599895"
         asset: string,  // example: "USDT"
         airDropAsset: string,  // example: "BETH"
         canRedeem: boolean,  // example: true
         collateralAmount: NumberString,  // example: "232.23123213"
         productId: string,  // example: "USDT001"
         yesterdayRealTimeRewards: NumberString,  // example: "0.10293829"
         cumulativeBonusRewards: NumberString,  // example: "0.22759183"
         cumulativeRealTimeRewards: NumberString,  // example: "0.22759183"
         cumulativeTotalRewards: NumberString,  // example: "0.45459183"
         autoSubscribe: boolean  // example: true
       }[],
     total: number  // example: 1
    }>;
  
  
  getFlexibleProductPosition(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/position", "GET", "USER_DATA", false, args, ["asset", "productId", "current", "size", "recvWindow", "timestamp"], "getFlexibleProductPosition");
  }
  
  
  /** Get Locked Product Position (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-product-position-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/position
   * 
   * Weight(IP): 150
   * 
   * @param {string} asset
   * @param {string} positionId
   * @param {string} projectId
   * @param {LONG} current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getLockedProductPosition(asset? :string, positionId? :string, projectId? :string, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getLockedProductPosition"]>;
  
  
  /** Get Locked Product Position (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-product-position-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/position
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.asset
   * @param {string} options.positionId
   * @param {string} options.projectId
   * @param {LONG} options.current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getLockedProductPosition(options? : { asset? :string, positionId? :string, projectId? :string, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         positionId: NumberString,  // example: "123123"
         projectId: string,  // example: "Axs*90"
         asset: string,  // example: "AXS"
         amount: NumberString,  // example: "122.09202928"
         purchaseTime: NumberString,  // example: "1646182276000"
         duration: NumberString,  // example: "60"
         accrualDays: NumberString,  // example: "4"
         rewardAsset: string,  // example: "AXS"
         APY: NumberString,  // example: "0.23"
         isRenewable: boolean,  // example: true
         isAutoRenew: boolean,  // example: true
         redeemDate: NumberString  // example: "1732182276000"
       }[],
     total: number  // example: 1
    }>;
  
  
  getLockedProductPosition(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/locked/position", "GET", "USER_DATA", false, args, ["asset", "positionId", "projectId", "current", "size", "recvWindow", "timestamp"], "getLockedProductPosition");
  }
  
  
  /** Simple Account (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#simple-account-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/account
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  simpleAccount(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["simpleAccount"]>;
  
  
  /** Simple Account (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#simple-account-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/account
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  simpleAccount(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     totalAmountInBTC: NumberString,  // example: "0.01067982"
     totalAmountInUSDT: NumberString,  // example: "77.13289230"
     totalFlexibleAmountInBTC: NumberString,  // example: "0.00000000"
     totalFlexibleAmountInUSDT: NumberString,  // example: "0.00000000"
     totalLockedInBTC: NumberString,  // example: "0.01067982"
     totalLockedInUSDT: NumberString  // example: "77.13289230"
    }>;
  
  
  simpleAccount(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/account", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "simpleAccount");
  }
  
  
  /** Get Flexible Subscription Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-subscription-record-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/history/subscriptionRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} productId
   * @param {string} purchaseId
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFlexibleSubscriptionRecord(productId? :string, purchaseId? :string, asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFlexibleSubscriptionRecord"]>;
  
  
  /** Get Flexible Subscription Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-subscription-record-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/history/subscriptionRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.productId
   * @param {string} options.purchaseId
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFlexibleSubscriptionRecord(options? : { productId? :string, purchaseId? :string, asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         amount: NumberString,  // example: "100.00000000"
         asset: string,  // example: "USDT"
         time: number,  // example: 1575018510000
         purchaseId: number,  // example: 26055
         type: string,  // example: "AUTO"  // AUTO for auto subscribe, NORMAL for normal subscription, CONVERT for Locked to Flexible, LOAN for flexible loan collateral, AI for Auto Invest subscribe, TRANSFER for Locked Savings to Flexible
         sourceAccount: string,  // example: "SPOT"  // SPOT, FUNDING, SPOTANDFUNDING
         amtFromSpot: NumberString,  // example: "30"  // Display if sourceAccount is SPOTANDFUNDING
         amtFromFunding: NumberString,  // example: "70"  // Display if sourceAccount is SPOTANDFUNDING
         status: string  // example: "SUCCESS"  // PURCHASING/SUCCESS/FAILED
       }[],
     total: number  // example: 1
    }>;
  
  
  getFlexibleSubscriptionRecord(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/history/subscriptionRecord", "GET", "USER_DATA", false, args, ["productId", "purchaseId", "asset", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getFlexibleSubscriptionRecord");
  }
  
  
  /** Get Locked Subscription Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-subscription-record-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/history/subscriptionRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} purchaseId
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getLockedSubscriptionRecord(purchaseId? :string, asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getLockedSubscriptionRecord"]>;
  
  
  /** Get Locked Subscription Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-subscription-record-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/history/subscriptionRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.purchaseId
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getLockedSubscriptionRecord(options? : { purchaseId? :string, asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         positionId: NumberString,  // example: "123123"
         purchaseId: number,  // example: 26055
         time: number,  // example: 1575018510000
         asset: string,  // example: "BNB"
         amount: NumberString,  // example: "21312.23223"
         lockPeriod: NumberString,  // example: "30"
         type: string,  // example: "AUTO"  // NORMAL for normal subscription, AUTO for auto-subscription order, ACTIVITY for activity order, TRIAL for trial fund order, RESTAKE for restake order
         sourceAccount: string,  // example: "SPOT"  // SPOT, FUNDING, SPOTANDFUNDING
         amtFromSpot: NumberString,  // example: "30"  // Display if sourceAccount is SPOTANDFUNDING
         amtFromFunding: NumberString,  // example: "70"  // Display if sourceAccount is SPOTANDFUNDING
         status: string  // example: "SUCCESS"  // PURCHASING/SUCCESS/FAILED
       }[],
     total: number  // example: 1
    }>;
  
  
  getLockedSubscriptionRecord(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/locked/history/subscriptionRecord", "GET", "USER_DATA", false, args, ["purchaseId", "asset", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getLockedSubscriptionRecord");
  }
  
  
  /** Get Flexible Redemption Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-redemption-record-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/history/redemptionRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} productId
   * @param {string} redeemId
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   */
  getFlexibleRedemptionRecord(productId? :string, redeemId? :string, asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG)
  : ReturnType<MyBinanceClient["getFlexibleRedemptionRecord"]>;
  
  
  /** Get Flexible Redemption Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-redemption-record-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/history/redemptionRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.productId
   * @param {string} options.redeemId
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   */
  getFlexibleRedemptionRecord(options? : { productId? :string, redeemId? :string, asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG })
  : Promise<{
     rows: {
         amount: NumberString,  // example: "10.54000000"
         asset: string,  // example: "USDT"
         time: number,  // example: 1577257222000
         productId: string,  // example: "USDT001"
         redeemId: number,  // example: 40607
         destAccount: string,  // example: "SPOT"  // SPOT, FUNDING
         status: string  // example: "PAID"
       }[],
     total: number  // example: 1
    }>;
  
  
  getFlexibleRedemptionRecord(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/history/redemptionRecord", "GET", "USER_DATA", false, args, ["productId", "redeemId", "asset", "startTime", "endTime", "current", "size"], "getFlexibleRedemptionRecord");
  }
  
  
  /** Get Locked Redemption Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-redemption-record-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/history/redemptionRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} positionId
   * @param {string} redeemId
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getLockedRedemptionRecord(positionId? :string, redeemId? :string, asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getLockedRedemptionRecord"]>;
  
  
  /** Get Locked Redemption Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-redemption-record-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/history/redemptionRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.positionId
   * @param {string} options.redeemId
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getLockedRedemptionRecord(options? : { positionId? :string, redeemId? :string, asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         positionId: NumberString,  // example: "123123"
         redeemId: number,  // example: 40607
         time: number,  // example: 1575018510000
         asset: string,  // example: "BNB"
         lockPeriod: NumberString,  // example: "30"
         amount: NumberString,  // example: "21312.23223"
         type: string,  // example: "MATURE"  //MATURE for redeem to Spot Wallet, NEW_TRANSFERRED for redeem to Flexible product, AHEAD for early redemption
         deliverDate: NumberString,  // example: "1575018510000"
         status: string  // example: "PAID"
       }[],
     total: number  // example: 1
    }>;
  
  
  getLockedRedemptionRecord(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/locked/history/redemptionRecord", "GET", "USER_DATA", false, args, ["positionId", "redeemId", "asset", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getLockedRedemptionRecord");
  }
  
  
  /** Get Flexible Rewards History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-rewards-history-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/history/rewardsRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} productId
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {OrderType} type  -  BONUS - Bonus tiered APR, REALTIME Real-time APR, REWARDS Historical rewards
   * @param {LONG} current  -  current page 1， default 1
   * @param {LONG} size  -  default 10，max 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFlexibleRewardsHistory(productId :string|undefined, asset :string|undefined, startTime :LONG|undefined, endTime :LONG|undefined, type :OrderType, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFlexibleRewardsHistory"]>;
  
  
  /** Get Flexible Rewards History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-rewards-history-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/history/rewardsRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.productId
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {OrderType} options.type  -  BONUS - Bonus tiered APR, REALTIME Real-time APR, REWARDS Historical rewards
   * @param {LONG} options.current  -  current page 1， default 1
   * @param {LONG} options.size  -  default 10，max 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFlexibleRewardsHistory(options : { productId? :string, asset? :string, startTime? :LONG, endTime? :LONG, type :OrderType, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         asset: string,  // example: "BUSD"
         rewards: NumberString,  // example: "0.00006408"
         projectId: string,  // example: "USDT001"
         type: string,  // example: "BONUS"
         time: number  // example: 1577233578000
       }[],
     total: number  // example: 2
    }>;
  
  
  getFlexibleRewardsHistory(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/history/rewardsRecord", "GET", "USER_DATA", false, args, ["productId", "asset", "startTime", "endTime", "type", "current", "size", "recvWindow", "timestamp"], "getFlexibleRewardsHistory");
  }
  
  
  /** Get Locked Rewards History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-rewards-history-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/history/rewardsRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} positionId
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getLockedRewardsHistory(positionId? :string, asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getLockedRewardsHistory"]>;
  
  
  /** Get Locked Rewards History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-rewards-history-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/history/rewardsRecord
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.positionId
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying the page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getLockedRewardsHistory(options? : { positionId? :string, asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         positionId: NumberString,  // example: "123123"
         time: number,  // example: 1575018510000
         asset: string,  // example: "BNB"
         lockPeriod: NumberString,  // example: "30"
         amount: NumberString  // example: "21312.23223"
       }[],
     total: number  // example: 1
    }>;
  
  
  getLockedRewardsHistory(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/locked/history/rewardsRecord", "GET", "USER_DATA", false, args, ["positionId", "asset", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getLockedRewardsHistory");
  }
  
  
  /** Set Flexible Auto Subscribe (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#set-flexible-auto-subscribe-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/setAutoSubscribe
   * 
   * Weight(IP): 150
   * 
   * @param {string} productId
   * @param {boolean} autoSubscribe  -  true or false
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  setFlexibleAutoSubscribe(productId :string, autoSubscribe :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["setFlexibleAutoSubscribe"]>;
  
  
  /** Set Flexible Auto Subscribe (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#set-flexible-auto-subscribe-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/setAutoSubscribe
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.productId
   * @param {boolean} options.autoSubscribe  -  true or false
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  setFlexibleAutoSubscribe(options : { productId :string, autoSubscribe :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     success: boolean  // example: true
    }>;
  
  
  setFlexibleAutoSubscribe(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/setAutoSubscribe", "POST", "USER_DATA", false, args, ["productId", "autoSubscribe", "recvWindow", "timestamp"], "setFlexibleAutoSubscribe");
  }
  
  
  /** Set Locked Auto Subscribe (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#set-locked-auto-subscribe-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/setAutoSubscribe
   * 
   * Weight(IP): 150
   * 
   * @param {string} positionId
   * @param {boolean} autoSubscribe  -  true or false
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  setLockedAutoSubscribe(positionId :string, autoSubscribe :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["setLockedAutoSubscribe"]>;
  
  
  /** Set Locked Auto Subscribe (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#set-locked-auto-subscribe-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/setAutoSubscribe
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.positionId
   * @param {boolean} options.autoSubscribe  -  true or false
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  setLockedAutoSubscribe(options : { positionId :string, autoSubscribe :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     success: boolean  // example: true
    }>;
  
  
  setLockedAutoSubscribe(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/locked/setAutoSubscribe", "POST", "USER_DATA", false, args, ["positionId", "autoSubscribe", "recvWindow", "timestamp"], "setLockedAutoSubscribe");
  }
  
  
  /** Get Flexible Personal Left Quota (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-personal-left-quota-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/personalLeftQuota
   * 
   * Weight(IP): 150
   * 
   * @param {string} productId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFlexiblePersonalLeftQuota(productId :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFlexiblePersonalLeftQuota"]>;
  
  
  /** Get Flexible Personal Left Quota (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-personal-left-quota-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/personalLeftQuota
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.productId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFlexiblePersonalLeftQuota(options : { productId :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     leftPersonalQuota: NumberString  // example: "1000"
    }>;
  
  
  getFlexiblePersonalLeftQuota(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/personalLeftQuota", "GET", "USER_DATA", false, args, ["productId", "recvWindow", "timestamp"], "getFlexiblePersonalLeftQuota");
  }
  
  
  /** Get Locked Personal Left Quota (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-personal-left-quota-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/personalLeftQuota
   * 
   * Weight(IP): 150
   * 
   * @param {string} projectId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getLockedPersonalLeftQuota(projectId :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getLockedPersonalLeftQuota"]>;
  
  
  /** Get Locked Personal Left Quota (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-personal-left-quota-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/personalLeftQuota
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.projectId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getLockedPersonalLeftQuota(options : { projectId :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     leftPersonalQuota: NumberString  // example: "1000"
    }>;
  
  
  getLockedPersonalLeftQuota(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/locked/personalLeftQuota", "GET", "USER_DATA", false, args, ["projectId", "recvWindow", "timestamp"], "getLockedPersonalLeftQuota");
  }
  
  
  /** Get Flexible Subscription Preview (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-subscription-preview-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/subscriptionPreview
   * 
   * Weight(IP): 150
   * 
   * @param {string} productId
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFlexibleSubscriptionPreview(productId :string, amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFlexibleSubscriptionPreview"]>;
  
  
  /** Get Flexible Subscription Preview (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-subscription-preview-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/subscriptionPreview
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.productId
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFlexibleSubscriptionPreview(options : { productId :string, amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     totalAmount: NumberString,  // example: "1232.32230982"
     rewardAsset: string,  // example: "BUSD"
     airDropAsset: string,  // example: "BETH"
     estDailyBonusRewards: NumberString,  // example: "0.22759183"
     estDailyRealTimeRewards: NumberString,  // example: "0.22759183"
     estDailyAirdropRewards: NumberString  // example: "0.22759183"
    }>;
  
  
  getFlexibleSubscriptionPreview(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/subscriptionPreview", "GET", "USER_DATA", false, args, ["productId", "amount", "recvWindow", "timestamp"], "getFlexibleSubscriptionPreview");
  }
  
  
  /** Get Locked Subscription Preview (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-subscription-preview-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/subscriptionPreview
   * 
   * Weight(IP): 150
   * 
   * @param {string} projectId
   * @param {DECIMAL} amount
   * @param {boolean} autoSubscribe  -  true or false, default true.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getLockedSubscriptionPreview(projectId :string, amount :DECIMAL, autoSubscribe? :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getLockedSubscriptionPreview"]>;
  
  
  /** Get Locked Subscription Preview (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-locked-subscription-preview-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/locked/subscriptionPreview
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.projectId
   * @param {DECIMAL} options.amount
   * @param {boolean} options.autoSubscribe  -  true or false, default true.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getLockedSubscriptionPreview(options : { projectId :string, amount :DECIMAL, autoSubscribe? :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       rewardAsset: string,  // example: "AXS"
       totalRewardAmt: NumberString,  // example: "5.17181528"
       extraRewardAsset: string,  // example: "BNB"
       estTotalExtraRewardAmt: NumberString,  // example: "5.17181528"
       nextPay: NumberString,  // example: "1.29295383"
       nextPayDate: NumberString,  // example: "1646697600000"
       valueDate: NumberString,  // example: "1646697600000"
       rewardsEndDate: NumberString,  // example: "1651449600000"
       deliverDate: NumberString,  // example: "1651536000000"
       nextSubscriptionDate: NumberString  // example: "1651536000000"
     }[]>;
  
  
  getLockedSubscriptionPreview(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/locked/subscriptionPreview", "GET", "USER_DATA", false, args, ["projectId", "amount", "autoSubscribe", "recvWindow", "timestamp"], "getLockedSubscriptionPreview");
  }
  
  
  /** Get Rate History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-rate-history-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/history/rateHistory
   * 
   * Weight(IP): 150
   * 
   * @param {string} productId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  getRateHistory(productId :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getRateHistory"]>;
  
  
  /** Get Rate History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-rate-history-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/history/rateHistory
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.productId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  getRateHistory(options : { productId :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         productId: string,  // example: "BUSD001"
         asset: string,  // example: "BUSD"
         annualPercentageRate: NumberString,  // example: "0.00006408"
         time: number  // example: 1577233578000
       }[],
     total: NumberString  // example: "1"
    }>;
  
  
  getRateHistory(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/history/rateHistory", "GET", "USER_DATA", false, args, ["productId", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getRateHistory");
  }
  
  
  /** Get Collateral Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-collateral-record-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/history/collateralRecord
   * 
   * Weight(IP): 1
   * 
   * @param {string} productId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  getCollateralRecord(productId? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getCollateralRecord"]>;
  
  
  /** Get Collateral Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-collateral-record-user_data}
   * 
   * EndPoint: /sapi/v1/simple-earn/flexible/history/collateralRecord
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.productId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  getCollateralRecord(options? : { productId? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         amount: NumberString,  // example: "100.00000000"
         productId: string,  // example: "BUSD001"
         asset: string,  // example: "USDT"
         createTime: number,  // example: 1575018510000
         type: string,  // example: "REPAY"
         productName: string,  // example: "USDT"
         orderId: number  // example: 26055
       }[],
     total: NumberString  // example: "1"
    }>;
  
  
  getCollateralRecord(...args : any) {
      return this._sendRequest("/sapi/v1/simple-earn/flexible/history/collateralRecord", "GET", "USER_DATA", false, args, ["productId", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getCollateralRecord");
  }
  
  
  
  //***** Dual Investment Endpoints *****
  
  
  /** Get Dual Investment product list(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-dual-investment-product-list-user_data}
   * 
   * Get Dual Investment product list
   * 
   * EndPoint: /sapi/v1/dci/product/list
   * 
   * Weight(IP): 1
   * 
   * @param {string} optionType  -  Input CALL or PUT
   * @param {string} exercisedCoin  -  Target exercised asset, e.g.: if you subscribe to a high sell product (call option), you should input: optionType:CALL,exercisedCoin:USDT,investCoin:BNB; if you subscribe to a low buy product (put option), you should input: optionType:PUT,exercisedCoin:BNB,investCoin:USDT
   * @param {string} investCoin  -  Asset used for subscribing, e.g.: if you subscribe to a high sell product (call option), you should input: optionType:CALL,exercisedCoin:USDT,investCoin:BNB; if you subscribe to a low buy product (put option), you should input: optionType:PUT,exercisedCoin:BNB,investCoin:USDT
   * @param {LONG} pageSize  -  Default: 10, Maximum: 100
   * @param {INT} pageIndex  -  Default: 1
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  getDualInvestmentProductList(optionType :string, exercisedCoin :string, investCoin :string, pageSize? :LONG, pageIndex? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getDualInvestmentProductList"]>;
  
  
  /** Get Dual Investment product list(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-dual-investment-product-list-user_data}
   * 
   * Get Dual Investment product list
   * 
   * EndPoint: /sapi/v1/dci/product/list
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.optionType  -  Input CALL or PUT
   * @param {string} options.exercisedCoin  -  Target exercised asset, e.g.: if you subscribe to a high sell product (call option), you should input: optionType:CALL,exercisedCoin:USDT,investCoin:BNB; if you subscribe to a low buy product (put option), you should input: optionType:PUT,exercisedCoin:BNB,investCoin:USDT
   * @param {string} options.investCoin  -  Asset used for subscribing, e.g.: if you subscribe to a high sell product (call option), you should input: optionType:CALL,exercisedCoin:USDT,investCoin:BNB; if you subscribe to a low buy product (put option), you should input: optionType:PUT,exercisedCoin:BNB,investCoin:USDT
   * @param {LONG} options.pageSize  -  Default: 10, Maximum: 100
   * @param {INT} options.pageIndex  -  Default: 1
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  getDualInvestmentProductList(options : { optionType :string, exercisedCoin :string, investCoin :string, pageSize? :LONG, pageIndex? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 1
     list: {
         id: NumberString,  // example: "741590"
         investCoin: string,  // example: "USDT"
         exercisedCoin: string,  // example: "BNB"
         strikePrice: NumberString,  // example: "380"
         duration: number,  // example: 4
         settleDate: number,  // example: 1709020800000
         purchaseDecimal: number,  // example: 8
         purchaseEndTime: number,  // example: 1708934400000
         canPurchase: boolean,  // example: true  //true, false
         apr: NumberString,  // example: "0.6076"
         orderId: number,  // example: 8257205859
         minAmount: NumberString,  // example: "0.1"
         maxAmount: NumberString,  // example: "25265.7"
         createTimestamp: number,  // example: 1708560084000
         optionType: string,  // example: "PUT"
         isAutoCompoundEnable: boolean,  // example: true  //true, false
         autoCompoundPlanList: string[]  // example: "STANDARD"
       }[]
    }>;
  
  
  getDualInvestmentProductList(...args : any) {
      return this._sendRequest("/sapi/v1/dci/product/list", "GET", "USER_DATA", false, args, ["optionType", "exercisedCoin", "investCoin", "pageSize", "pageIndex", "recvWindow", "timestamp"], "getDualInvestmentProductList");
  }
  
  
  /** Subscribe Dual Investment products(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#subscribe-dual-investment-products-user_data}
   * 
   * Subscribe Dual Investment products
   * 
   * EndPoint: /sapi/v1/dci/product/subscribe
   * 
   * Weight(IP): 1
   * 
   * @param {string} id  -  get id from /sapi/v1/dci/product/list
   * @param {string} orderId  -  get orderId from /sapi/v1/dci/product/list
   * @param {DECIMAL} depositAmount  -  the amount for subscribing
   * @param {ENUM} autoCompoundPlan  -  NONE: switch off the plan, STANDARD:standard plan,ADVANCED:advanced plan
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  subscribeDualInvestmentProducts(id :string, orderId :string, depositAmount :DECIMAL, autoCompoundPlan :ENUM, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["subscribeDualInvestmentProducts"]>;
  
  
  /** Subscribe Dual Investment products(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#subscribe-dual-investment-products-user_data}
   * 
   * Subscribe Dual Investment products
   * 
   * EndPoint: /sapi/v1/dci/product/subscribe
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.id  -  get id from /sapi/v1/dci/product/list
   * @param {string} options.orderId  -  get orderId from /sapi/v1/dci/product/list
   * @param {DECIMAL} options.depositAmount  -  the amount for subscribing
   * @param {ENUM} options.autoCompoundPlan  -  NONE: switch off the plan, STANDARD:standard plan,ADVANCED:advanced plan
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  subscribeDualInvestmentProducts(options : { id :string, orderId :string, depositAmount :DECIMAL, autoCompoundPlan :ENUM, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     positionId: number,  // example: 10208824
     investCoin: string,  // example: "BNB"
     exercisedCoin: string,  // example: "USDT"
     subscriptionAmount: NumberString,  // example: "0.002"
     duration: number,  // example: 4
     autoCompoundPlan: string,  // example: "STANDARD"  //STANDARD, ADVANCED, this field won't display when autocompound is set to None
     strikePrice: NumberString,  // example: "380"
     settleDate: number,  // example: 1709020800000
     purchaseStatus: string,  // example: "PURCHASE_SUCCESS"
     apr: NumberString,  // example: "0.7397"
     orderId: number,  // example: 8259117597
     purchaseTime: number,  // example: 1708677583874
     optionType: string  // example: "CALL"
    }>;
  
  
  subscribeDualInvestmentProducts(...args : any) {
      return this._sendRequest("/sapi/v1/dci/product/subscribe", "POST", "USER_DATA", false, args, ["id", "orderId", "depositAmount", "autoCompoundPlan", "recvWindow", "timestamp"], "subscribeDualInvestmentProducts");
  }
  
  
  /** Get Dual Investment positions(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-dual-investment-positions-user_data}
   * 
   * Get Dual Investment positions (batch)
   * 
   * EndPoint: /sapi/v1/dci/product/positions
   * 
   * Weight(IP): 1
   * 
   * @param {ENUM} status  -  PENDING:Products are purchasing, will give results later;PURCHASE_SUCCESS:purchase successfully;SETTLED: Products are finish settling;PURCHASE_FAIL:fail to purchase;REFUNDING:refund ongoing;REFUND_SUCCESS:refund to spot account successfully; SETTLING:Products are settling. If don't fill this field, will response all the position status.
   * @param {LONG} pageSize  -  Default: 10, Max:100
   * @param {INT} pageIndex  -  Default:1
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  getDualInvestmentPositions(status? :ENUM, pageSize? :LONG, pageIndex? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getDualInvestmentPositions"]>;
  
  
  /** Get Dual Investment positions(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-dual-investment-positions-user_data}
   * 
   * Get Dual Investment positions (batch)
   * 
   * EndPoint: /sapi/v1/dci/product/positions
   * 
   * Weight(IP): 1
   * 
   * @param {ENUM} options.status  -  PENDING:Products are purchasing, will give results later;PURCHASE_SUCCESS:purchase successfully;SETTLED: Products are finish settling;PURCHASE_FAIL:fail to purchase;REFUNDING:refund ongoing;REFUND_SUCCESS:refund to spot account successfully; SETTLING:Products are settling. If don't fill this field, will response all the position status.
   * @param {LONG} options.pageSize  -  Default: 10, Max:100
   * @param {INT} options.pageIndex  -  Default:1
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  getDualInvestmentPositions(options? : { status? :ENUM, pageSize? :LONG, pageIndex? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 1
     list: {
         id: NumberString,  // example: "10160533"  //positionId
         investCoin: string,  // example: "USDT"
         exercisedCoin: string,  // example: "BNB"
         subscriptionAmount: NumberString,  // example: "0.5"
         strikePrice: NumberString,  // example: "330"
         duration: number,  // example: 4
         settleDate: number,  // example: 1708416000000
         purchaseStatus: string,  // example: "PURCHASE_SUCCESS"
         apr: NumberString,  // example: "0.0365"
         orderId: number,  // example: 7973677530
         purchaseEndTime: number,  // example: 1708329600000  //申购中, 申购成功, 已结算, 申购失败, 退款中, 退款成功, 结算中
         optionType: string,  // example: "PUT"
         autoCompoundPlan: string  // example: "STANDARD"  //关闭计划, 基础计划, 进阶计划
       }[]
    }>;
  
  
  getDualInvestmentPositions(...args : any) {
      return this._sendRequest("/sapi/v1/dci/product/positions", "GET", "USER_DATA", false, args, ["status", "pageSize", "pageIndex", "recvWindow", "timestamp"], "getDualInvestmentPositions");
  }
  
  
  /** Check Dual Investment accounts(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#check-dual-investment-accounts-user_data}
   * 
   * Check Dual Investment accounts
   * 
   * EndPoint: /sapi/v1/dci/product/accounts
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  checkDualInvestmentAccounts(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["checkDualInvestmentAccounts"]>;
  
  
  /** Check Dual Investment accounts(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#check-dual-investment-accounts-user_data}
   * 
   * Check Dual Investment accounts
   * 
   * EndPoint: /sapi/v1/dci/product/accounts
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  checkDualInvestmentAccounts(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     totalAmountInBTC: NumberString,  // example: "0.01067982"  //Total BTC amounts in Dual Investment
     totalAmountInUSDT: NumberString  // example: "77.13289230"  //Total USDT equivalents in BTC in Dual Investment
    }>;
  
  
  checkDualInvestmentAccounts(...args : any) {
      return this._sendRequest("/sapi/v1/dci/product/accounts", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "checkDualInvestmentAccounts");
  }
  
  
  /** Change Auto-Compound status(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#change-auto-compound-status-user_data}
   * 
   * Change Auto-Compound status
   * 
   * EndPoint: /sapi/v1/dci/product/auto_compound/edit-status
   * 
   * Weight(IP): 1
   * 
   * @param {string} positionId  -  Get positionId from /sapi/v1/dci/product/positions
   * @param {string} autoCompoundPlan  -  NONE, STANDARD,ADVANCED
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  changeAutoCompoundStatus(positionId :string, autoCompoundPlan :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["changeAutoCompoundStatus"]>;
  
  
  /** Change Auto-Compound status(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#change-auto-compound-status-user_data}
   * 
   * Change Auto-Compound status
   * 
   * EndPoint: /sapi/v1/dci/product/auto_compound/edit-status
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.positionId  -  Get positionId from /sapi/v1/dci/product/positions
   * @param {string} options.autoCompoundPlan  -  NONE, STANDARD,ADVANCED
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  changeAutoCompoundStatus(options : { positionId :string, autoCompoundPlan :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     positionId: NumberString,  // example: "123456789"
     autoCompoundPlan: string  // example: "ADVANCED"  //NONE,STANDARD,ADVANCED
    }>;
  
  
  changeAutoCompoundStatus(...args : any) {
      return this._sendRequest("/sapi/v1/dci/product/auto_compound/edit-status", "POST", "USER_DATA", false, args, ["positionId", "autoCompoundPlan", "recvWindow", "timestamp"], "changeAutoCompoundStatus");
  }
  
  
  
  //***** Auto-Invest Endpoints *****
  
  
  /** Get target asset list(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-target-asset-list-user_data}
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/target-asset/list
   * 
   * Weight(IP): 1
   * 
   * @param {string} targetAsset
   * @param {LONG} size  -  Default: 8, Max:100
   * @param {LONG} current  -  Current query page. Default: 1, start from 1
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  getTargetAssetList(targetAsset? :string, size? :LONG, current? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getTargetAssetList"]>;
  
  
  /** Get target asset list(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-target-asset-list-user_data}
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/target-asset/list
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.targetAsset
   * @param {LONG} options.size  -  Default: 8, Max:100
   * @param {LONG} options.current  -  Current query page. Default: 1, start from 1
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  getTargetAssetList(options? : { targetAsset? :string, size? :LONG, current? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     targetAssets: string[]  // example: "BTC",
     autoInvestAssetList: {
         targetAsset: string,  // example: "BTC"
         roiAndDimensionTypeList: {
             simulateRoi: NumberString,  // example: "5.004"
             dimensionValue: NumberString,  // example: "3"
             dimensionUnit: string  // example: "year"
           }[]
       }[]
    }>;
  
  
  getTargetAssetList(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/target-asset/list", "GET", "USER_DATA", false, args, ["targetAsset", "size", "current", "recvWindow", "timestamp"], "getTargetAssetList");
  }
  
  
  /** Get target asset ROI data(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-target-asset-roi-data-user_data}
   * 
   * ROI return list for target asset
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/target-asset/roi/list
   * 
   * Weight(IP): 1
   * 
   * @param {string} targetAsset  -  e.g "BTC"
   * @param {"FIVE_YEAR"|"THREE_YEAR"|"ONE_YEAR"|"SIX_MONTH"|"THREE_MONTH"|"SEVEN_DAY"} hisRoiType  -  FIVE_YEAR,THREE_YEAR,ONE_YEAR,SIX_MONTH,THREE_MONTH,SEVEN_DAY
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  getTargetAssetROIData(targetAsset :string, hisRoiType :"FIVE_YEAR"|"THREE_YEAR"|"ONE_YEAR"|"SIX_MONTH"|"THREE_MONTH"|"SEVEN_DAY", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getTargetAssetROIData"]>;
  
  
  /** Get target asset ROI data(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-target-asset-roi-data-user_data}
   * 
   * ROI return list for target asset
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/target-asset/roi/list
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.targetAsset  -  e.g "BTC"
   * @param {"FIVE_YEAR"|"THREE_YEAR"|"ONE_YEAR"|"SIX_MONTH"|"THREE_MONTH"|"SEVEN_DAY"} options.hisRoiType  -  FIVE_YEAR,THREE_YEAR,ONE_YEAR,SIX_MONTH,THREE_MONTH,SEVEN_DAY
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  getTargetAssetROIData(options : { targetAsset :string, hisRoiType :"FIVE_YEAR"|"THREE_YEAR"|"ONE_YEAR"|"SIX_MONTH"|"THREE_MONTH"|"SEVEN_DAY", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       date: NumberString,  // example: "1648378800000"  // date of the ROI accumulation
       simulateRoi: NumberString  // example: "1.75"  // value of calculated ROI till the date
     }[]>;
  
  
  getTargetAssetROIData(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/target-asset/roi/list", "GET", "USER_DATA", false, args, ["targetAsset", "hisRoiType", "recvWindow", "timestamp"], "getTargetAssetROIData");
  }
  
  
  /** Query all source asset and target asset(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-all-source-asset-and-target-asset-user_data}
   * 
   * Query all source assets and target assets
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/all/asset
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  queryAllSourceAssetAndTargetAsset(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryAllSourceAssetAndTargetAsset"]>;
  
  
  /** Query all source asset and target asset(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-all-source-asset-and-target-asset-user_data}
   * 
   * Query all source assets and target assets
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/all/asset
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  queryAllSourceAssetAndTargetAsset(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     targetAssets: string[]  // example: "BTC",
     sourceAssets: string[]  // example: "USDT"
    }>;
  
  
  queryAllSourceAssetAndTargetAsset(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/all/asset", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryAllSourceAssetAndTargetAsset");
  }
  
  
  /** Query source asset list(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-source-asset-list-user_data}
   * 
   * Query Source Asset to be used for investment
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/source-asset/list
   * 
   * Weight(IP): 1
   * 
   * @param {string[]} targetAsset  -  BTC、ETH、BNB
   * @param {LONG} indexId  -  指数identifier,   value = 1
   * @param {"RECURRING"|"ONE_TIME"} usageType  -  "RECURRING", "ONE_TIME"
   * @param {boolean} flexibleAllowedToUse
   * @param {ENUM} sourceType  -  MAIN_SITE for Binance user,TR for Binance Turkey user
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  querySourceAssetList(targetAsset :readonly string[]|undefined, indexId :LONG|undefined, usageType :"RECURRING"|"ONE_TIME", flexibleAllowedToUse? :boolean, sourceType? :ENUM, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["querySourceAssetList"]>;
  
  
  /** Query source asset list(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-source-asset-list-user_data}
   * 
   * Query Source Asset to be used for investment
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/source-asset/list
   * 
   * Weight(IP): 1
   * 
   * @param {string[]} options.targetAsset  -  BTC、ETH、BNB
   * @param {LONG} options.indexId  -  指数identifier,   value = 1
   * @param {"RECURRING"|"ONE_TIME"} options.usageType  -  "RECURRING", "ONE_TIME"
   * @param {boolean} options.flexibleAllowedToUse
   * @param {ENUM} options.sourceType  -  MAIN_SITE for Binance user,TR for Binance Turkey user
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  querySourceAssetList(options : { targetAsset? :readonly string[], indexId? :LONG, usageType :"RECURRING"|"ONE_TIME", flexibleAllowedToUse? :boolean, sourceType? :ENUM, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     feeRate: NumberString,  // example: "0.002"
     taxRate: NumberString,  // example: "0.001"
     sourceAssets: {
         sourceAsset: string,  // example: "USDT"
         assetMinAmount: NumberString,  // example: "0.1"
         assetMaxAmount: NumberString,  // example: "1000000"
         scale: NumberString,  // example: "2"
         flexibleAmount: NumberString  // example: "1111"
       }[]
    }>;
  
  
  querySourceAssetList(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/source-asset/list", "GET", "USER_DATA", false, args, ["targetAsset", "indexId", "usageType", "flexibleAllowedToUse", "sourceType", "recvWindow", "timestamp"], "querySourceAssetList");
  }
  
  
  /** Investment plan creation(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#investment-plan-creation-user_data}
   * 
   * Post an investment plan creation
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/plan/add
   * 
   * Weight(IP): 1
   * 
   * @param {ENUM} sourceType  -  "MAIN_SITE" for Binance,"TR" for Binance Turkey
   * @param {string} requestId  -  if not null, must follow sourceType + unique string, e.g: TR12354859
   * @param {"SINGLE"|"PORTFOLIO"|"INDEX"} planType  -  "SINGLE","PORTFOLIO","INDEX"
   * @param {LONG} indexId  -  Only for planType = INDEX ,  value = 1
   * @param {DECIMAL} subscriptionAmount  -  Fiat&stablecoin: 2dp, BNB/ETH/BTC: 4dp
   * @param {"H1"|"H4"|"H8"|"H12"|"WEEKLY"|"DAILY"|"MONTHLY"|"BI_WEEKLY"} subscriptionCycle  -  "H1", "H4", "H8","H12", "WEEKLY","DAILY","MONTHLY","BI_WEEKLY"
   * @param {INTEGER} subscriptionStartDay  -  "1",..."31"; Mandatory if "subscriptionCycleNumberUnit" = "MONTHLY", Must be sent in form of UTC+0
   * @param {"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT"|"SUN"} subscriptionStartWeekday  -  "MON","TUE","WED","THU","FRI","SAT","SUN"; Mandatory if "subscriptionCycleNumberUnit" = "WEEKLY" or "BI_WEEKLY", Must be sent in form of UTC+0
   * @param {INTEGER} subscriptionStartTime  -  "0,1,2,3,4,5,6,7,8,..23";Must be sent in form of UTC+0
   * @param {string} sourceAsset  -  like "USDT"
   * @param {boolean} flexibleAllowedToUse  -  true/false；true: use flexible wallet
   * @param {PortfolioDetail[]} details  -  sum(all node's percentage) == 100，sum(all node's percentage) == 100， When input request parameter, each entry should be like details[0].targetAsset=BTC, Example of the request parameter array:
   * details[0].targetAsset=BTC details[0].percentage=60 details[1].targetAsset=ETH details[1].percentage=40
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  investmentPlanCreation(sourceType :ENUM, requestId :string|undefined, planType :"SINGLE"|"PORTFOLIO"|"INDEX", indexId :LONG|undefined, subscriptionAmount :DECIMAL, subscriptionCycle :"H1"|"H4"|"H8"|"H12"|"WEEKLY"|"DAILY"|"MONTHLY"|"BI_WEEKLY", subscriptionStartDay :INTEGER|undefined, subscriptionStartWeekday :"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT"|"SUN"|undefined, subscriptionStartTime :INTEGER, sourceAsset :string, flexibleAllowedToUse :boolean|undefined, details :readonly PortfolioDetail[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["investmentPlanCreation"]>;
  
  
  /** Investment plan creation(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#investment-plan-creation-user_data}
   * 
   * Post an investment plan creation
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/plan/add
   * 
   * Weight(IP): 1
   * 
   * @param {ENUM} options.sourceType  -  "MAIN_SITE" for Binance,"TR" for Binance Turkey
   * @param {string} options.requestId  -  if not null, must follow sourceType + unique string, e.g: TR12354859
   * @param {"SINGLE"|"PORTFOLIO"|"INDEX"} options.planType  -  "SINGLE","PORTFOLIO","INDEX"
   * @param {LONG} options.indexId  -  Only for planType = INDEX ,  value = 1
   * @param {DECIMAL} options.subscriptionAmount  -  Fiat&stablecoin: 2dp, BNB/ETH/BTC: 4dp
   * @param {"H1"|"H4"|"H8"|"H12"|"WEEKLY"|"DAILY"|"MONTHLY"|"BI_WEEKLY"} options.subscriptionCycle  -  "H1", "H4", "H8","H12", "WEEKLY","DAILY","MONTHLY","BI_WEEKLY"
   * @param {INTEGER} options.subscriptionStartDay  -  "1",..."31"; Mandatory if "subscriptionCycleNumberUnit" = "MONTHLY", Must be sent in form of UTC+0
   * @param {"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT"|"SUN"} options.subscriptionStartWeekday  -  "MON","TUE","WED","THU","FRI","SAT","SUN"; Mandatory if "subscriptionCycleNumberUnit" = "WEEKLY" or "BI_WEEKLY", Must be sent in form of UTC+0
   * @param {INTEGER} options.subscriptionStartTime  -  "0,1,2,3,4,5,6,7,8,..23";Must be sent in form of UTC+0
   * @param {string} options.sourceAsset  -  like "USDT"
   * @param {boolean} options.flexibleAllowedToUse  -  true/false；true: use flexible wallet
   * @param {PortfolioDetail[]} options.details  -  sum(all node's percentage) == 100，sum(all node's percentage) == 100， When input request parameter, each entry should be like details[0].targetAsset=BTC, Example of the request parameter array:
   * details[0].targetAsset=BTC details[0].percentage=60 details[1].targetAsset=ETH details[1].percentage=40
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  investmentPlanCreation(options : { sourceType :ENUM, requestId? :string, planType :"SINGLE"|"PORTFOLIO"|"INDEX", indexId? :LONG, subscriptionAmount :DECIMAL, subscriptionCycle :"H1"|"H4"|"H8"|"H12"|"WEEKLY"|"DAILY"|"MONTHLY"|"BI_WEEKLY", subscriptionStartDay? :INTEGER, subscriptionStartWeekday? :"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT"|"SUN", subscriptionStartTime :INTEGER, sourceAsset :string, flexibleAllowedToUse? :boolean, details :readonly PortfolioDetail[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     planId: number,  // example: 12345  //for success creation, planId is associated. PlanId remains constant when plan is being updated
     nextExecutionDateTime: number  // example: 1648378800000  //plan next excute timestamp
    }>;
  
  
  investmentPlanCreation(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/plan/add", "POST", "USER_DATA", false, args, ["sourceType", "requestId", "planType", "indexId", "subscriptionAmount", "subscriptionCycle", "subscriptionStartDay", "subscriptionStartWeekday", "subscriptionStartTime", "sourceAsset", "flexibleAllowedToUse", "details", "recvWindow", "timestamp"], "investmentPlanCreation");
  }
  
  
  /** Investment plan adjustment (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#investment-plan-adjustment-trade}
   * 
   * Query Source Asset to be used for investment
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/plan/edit
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} planId  -  Plan identifier
   * @param {DECIMAL} subscriptionAmount  -  Fiat&Stablecoin: 2dp, BNB/ETH/BTC: 4dp
   * @param {"H1"|"H4"|"H8"|"H12"|"WEEKLY"|"DAILY"|"MONTHLY"|"BI_WEEKLY"} subscriptionCycle  -  "H1", "H4", "H8","H12", "WEEKLY","DAILY","MONTHLY","BI_WEEKLY"
   * @param {INTEGER} subscriptionStartDay  -  "1",..."31";Mandatory if "subscriptionCycleNumberUnit" = "MONTHLY",Must be sent in form of UTC+0
   * @param {"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT"|"SUN"} subscriptionStartWeekday  -  "MON","TUE","WED","THU","FRI","SAT","SUN";Mandatory if "subscriptionCycleNumberUnit" = "WEEKLY" or "BI_WEEKLY", Must be sent in form of UTC+0
   * @param {INTEGER} subscriptionStartTime  -  "0,1, 2,3,4,5,6,7,8,..23"; Must be sent in form of UTC+0
   * @param {string} sourceAsset  -  e.g. "USDT"
   * @param {boolean} flexibleAllowedToUse  -  true/false；true:use flexible wallet
   * @param {PortfolioDetail[]} details  -  sum(all node's percentage) == 100，sum(all node's percentage) == 100， When input request parameter, each entry should be like details[0].targetAsset=BTC, Example of the request parameter array:
   * details[0].targetAsset=BTC details[0].percentage=60 details[1].targetAsset=ETH details[1].percentage=40
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  investmentPlanAdjustment(planId :LONG, subscriptionAmount :DECIMAL, subscriptionCycle :"H1"|"H4"|"H8"|"H12"|"WEEKLY"|"DAILY"|"MONTHLY"|"BI_WEEKLY", subscriptionStartDay :INTEGER|undefined, subscriptionStartWeekday :"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT"|"SUN"|undefined, subscriptionStartTime :INTEGER, sourceAsset :string, flexibleAllowedToUse :boolean|undefined, details :readonly PortfolioDetail[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["investmentPlanAdjustment"]>;
  
  
  /** Investment plan adjustment (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#investment-plan-adjustment-trade}
   * 
   * Query Source Asset to be used for investment
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/plan/edit
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.planId  -  Plan identifier
   * @param {DECIMAL} options.subscriptionAmount  -  Fiat&Stablecoin: 2dp, BNB/ETH/BTC: 4dp
   * @param {"H1"|"H4"|"H8"|"H12"|"WEEKLY"|"DAILY"|"MONTHLY"|"BI_WEEKLY"} options.subscriptionCycle  -  "H1", "H4", "H8","H12", "WEEKLY","DAILY","MONTHLY","BI_WEEKLY"
   * @param {INTEGER} options.subscriptionStartDay  -  "1",..."31";Mandatory if "subscriptionCycleNumberUnit" = "MONTHLY",Must be sent in form of UTC+0
   * @param {"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT"|"SUN"} options.subscriptionStartWeekday  -  "MON","TUE","WED","THU","FRI","SAT","SUN";Mandatory if "subscriptionCycleNumberUnit" = "WEEKLY" or "BI_WEEKLY", Must be sent in form of UTC+0
   * @param {INTEGER} options.subscriptionStartTime  -  "0,1, 2,3,4,5,6,7,8,..23"; Must be sent in form of UTC+0
   * @param {string} options.sourceAsset  -  e.g. "USDT"
   * @param {boolean} options.flexibleAllowedToUse  -  true/false；true:use flexible wallet
   * @param {PortfolioDetail[]} options.details  -  sum(all node's percentage) == 100，sum(all node's percentage) == 100， When input request parameter, each entry should be like details[0].targetAsset=BTC, Example of the request parameter array:
   * details[0].targetAsset=BTC details[0].percentage=60 details[1].targetAsset=ETH details[1].percentage=40
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  investmentPlanAdjustment(options : { planId :LONG, subscriptionAmount :DECIMAL, subscriptionCycle :"H1"|"H4"|"H8"|"H12"|"WEEKLY"|"DAILY"|"MONTHLY"|"BI_WEEKLY", subscriptionStartDay? :INTEGER, subscriptionStartWeekday? :"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT"|"SUN", subscriptionStartTime :INTEGER, sourceAsset :string, flexibleAllowedToUse? :boolean, details :readonly PortfolioDetail[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     planId: number,  // example: 12345  //for success creation, planId is associated. PlanId remains constant when plan is being updated
     nextExecutionDateTime: number  // example: 1648378800000
    }>;
  
  
  investmentPlanAdjustment(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/plan/edit", "POST", "TRADE", false, args, ["planId", "subscriptionAmount", "subscriptionCycle", "subscriptionStartDay", "subscriptionStartWeekday", "subscriptionStartTime", "sourceAsset", "flexibleAllowedToUse", "details", "recvWindow", "timestamp"], "investmentPlanAdjustment");
  }
  
  
  /** Change Plan Status (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#change-plan-status-trade}
   * 
   * Change Plan Status
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/plan/edit-status
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} planId  -  Plan identifier
   * @param {"ONGOING"|"PAUSED"|"REMOVED"} status  -  "ONGOING","PAUSED","REMOVED"
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  changePlanStatus(planId :LONG, status :"ONGOING"|"PAUSED"|"REMOVED", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["changePlanStatus"]>;
  
  
  /** Change Plan Status (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#change-plan-status-trade}
   * 
   * Change Plan Status
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/plan/edit-status
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.planId  -  Plan identifier
   * @param {"ONGOING"|"PAUSED"|"REMOVED"} options.status  -  "ONGOING","PAUSED","REMOVED"
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  changePlanStatus(options : { planId :LONG, status :"ONGOING"|"PAUSED"|"REMOVED", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     planId: number,  // example: 12345  //planId is constant regardless the change of the status
     nextExecutionDateTime: number,  // example: 1648378800000
     status: string  // example: "ONGOING"  //ONGOING, PAUSED, REMOVED
    }>;
  
  
  changePlanStatus(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/plan/edit-status", "POST", "TRADE", false, args, ["planId", "status", "recvWindow", "timestamp"], "changePlanStatus");
  }
  
  
  /** Get list of plans (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-list-of-plans-user_data}
   * 
   * Query plan lists
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/plan/list
   * 
   * Weight(IP): 1
   * 
   * @param {string} planType  -  Plan identifier
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  getListOfPlans(planType :string, recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["getListOfPlans"]>;
  
  
  /** Get list of plans (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-list-of-plans-user_data}
   * 
   * Query plan lists
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/plan/list
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.planType  -  Plan identifier
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  getListOfPlans(options : { planType :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  // SINGLE/PORTFOLIO
     planValueInUSD: NumberString,  // example: "123"
     planValueInBTC: NumberString,  // example: "0.1"
     pnlInUSD: NumberString,  // example: "120"
     roi: NumberString,  // example: "2.3"
     plans: {
         planId: number,  // example: 12345
         planType: string,  // example: "SINGLE"
         editAllowed: string,  // example: "true"
         creationDateTime: number,  // example: 1648378800000
         firstExecutionDateTime: number,  // example: 1648378800000  //first subscription date time
         nextExecutionDateTime: number,  // example: 1648378800000
         status: string,  // example: "ONGOING"  // ONGOING,PAUSED
         lastUpdatedDateTime: number,  // example: 1648378800000
         targetAsset: string,  // example: "BTC"
         totalTargetAmount: NumberString,  // example: "0.111"
         sourceAsset: string,  // example: "BUSD"
         totalInvestedInUSD: NumberString,  // example: "4.555"
         subscriptionAmount: NumberString,  // example: "0.1"
         subscriptionCycle: string,  // example: "WEEKLY"
         subscriptionStartDay: null,  // example: null
         subscriptionStartWeekday: string,  // example: "MON"
         subscriptionStartTime: NumberString,  // example: "1"
         sourceWallet: string,  // example: "SPOT_WALLET"
         flexibleAllowedToUse: string,  // example: "false"
         planValueInUSD: NumberString,  // example: "101.2"
         pnlInUSD: NumberString,  // example: "101.2"
         roi: NumberString  // example: "1.02"
       }[]
    } | {  // INDEX
     planValueInUSD: NumberString,  // example: "123"
     planValueInBTC: NumberString,  // example: "0.1"
     plans: {
         planId: number,  // example: 12345
         planType: string,  // example: "INDEX"
         editAllowed: string,  // example: "true"
         creationDateTime: number,  // example: 1648378800000
         firstExecutionDateTime: number,  // example: 1648378800000  //first subscription date time
         nextExecutionDateTime: number,  // example: 1648378800000
         status: string,  // example: "ONGOING"
         lastUpdatedDateTime: number,  // example: 1648378800000
         targetAsset: string,  // example: "BTC"
         sourceAsset: string,  // example: "BUSD"
         totalInvestedInUSD: NumberString,  // example: "4.555"
         subscriptionAmount: NumberString,  // example: "0.1"
         subscriptionCycle: string,  // example: "DAILY"
         subscriptionStartDay: NumberString,  // example: "1"
         subscriptionStartWeekday: null,  // example: null
         subscriptionStartTime: NumberString,  // example: "2"
         sourceWallet: string,  // example: "SPOT"
         flexibleAllowedToUse: string  // example: "false"
       }[]
    }>;
  
  
  getListOfPlans(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/plan/list", "GET", "USER_DATA", false, args, ["planType", "recvWindow", "timestamp"], "getListOfPlans");
  }
  
  
  /** Query holding details of the plan (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-holding-details-of-the-plan-user_data}
   * 
   * Query holding details of the plan
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/plan/id
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} planId  -  Plan identifier
   * @param {string} requestId  -  requestId when create
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  queryHoldingDetailsOfThePlan(planId? :LONG, requestId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryHoldingDetailsOfThePlan"]>;
  
  
  /** Query holding details of the plan (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-holding-details-of-the-plan-user_data}
   * 
   * Query holding details of the plan
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/plan/id
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.planId  -  Plan identifier
   * @param {string} options.requestId  -  requestId when create
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  queryHoldingDetailsOfThePlan(options? : { planId? :LONG, requestId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     planId: number,  // example: 111212
     planType: string,  // example: "INDEX"  // this is the plan type: "SINGLE","PORTFOLIO","INDEX"
     editAllowed: string,  // example: "true"  //whether this plan is allowed to be modified
     flexibleAllowedToUse: string,  // example: "false"
     creationDateTime: number,  // example: 1648378800000  // date time that this plan is created. YYYY-MM-DD HH:mm:SS e.g 2022-01-07 08:00:00
     firstExecutionDateTime: number,  // example: 1648378800000  //first subscription date time
     nextExecutionDateTime: number,  // example: 1648378800000  //next subscription date time
     status: string,  // example: "ONGOING"  //plan status of the selected plan
     targetAsset: string,  // example: "BTC"
     sourceAsset: string,  // example: "BUSD"  //source asset of the plan created
     planValueInUSD: NumberString,  // example: "101.2"  //market value of the plan
     pnlInUSD: NumberString,  // example: "101.2"  // PNL of the plan in USD
     roi: NumberString,  // example: "1.023"  //ROI of the plan
     totalInvestedInUSD: NumberString,  // example: "122"  //total source asset invested in equivilent of USD
     details: {
         targetAsset: string,  // example: "ADA"
         averagePriceInUSD: NumberString,  // example: "3.4"  //average price of the asset in USD
         totalInvestedInUSD: NumberString,  // example: "222.21"  //total source asset invested for this target asset in equivilent of USD
         purchasedAmount: NumberString,  // example: "122.12345678"  //purchased amount of target asset
         purchasedAmountUnit: string,  // example: "ADA"
         pnlInUSD: NumberString,  // example: "109.2"  //PNL denominated in USD
         roi: NumberString,  // example: "0.1"  //ROI calculated in decimal
         percentage: NumberString,  // example: "50"  //asset allocation in the plan. If it's single plan, then it's 100
         assetStatus: string,  // example: "ACTIVE"  // ACTIVE / INACTIVE whether this asset is still being subscribed in this plan
         availableAmount: NumberString,  // example: "122.12345678"  // Only for planType = INDEX
         availableAmountUnit: string,  // example: "ADA"  // Only for planType = INDEX
         redeemedAmout: NumberString,  // example: "122.12345678"  // Only for planType = INDEX
         redeemedAmoutUnit: string,  // example: "ADA"  // Only for planType = INDEX
         assetValueInUSD: NumberString  // example: "101.2"  // Only for planType = INDEX
       }[]
    }>;
  
  
  queryHoldingDetailsOfThePlan(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/plan/id", "GET", "USER_DATA", false, args, ["planId", "requestId", "recvWindow", "timestamp"], "queryHoldingDetailsOfThePlan");
  }
  
  
  /** Query subscription transaction history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-subscription-transaction-history-user_data}
   * 
   * Query subscription transaction history of a plan
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/history/list
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} planId  -  Plan identifier
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {string} targetAsset
   * @param {"SINGLE"|"PORTFOLIO"|"INDEX"|"ALL"} planType  -  SINGLE, PORTFOLIO, INDEX, ALL
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  querySubscriptionTransactionHistory(planId? :LONG, startTime? :LONG, endTime? :LONG, targetAsset? :string, planType? :"SINGLE"|"PORTFOLIO"|"INDEX"|"ALL", size? :LONG, current? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["querySubscriptionTransactionHistory"]>;
  
  
  /** Query subscription transaction history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-subscription-transaction-history-user_data}
   * 
   * Query subscription transaction history of a plan
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/history/list
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.planId  -  Plan identifier
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {string} options.targetAsset
   * @param {"SINGLE"|"PORTFOLIO"|"INDEX"|"ALL"} options.planType  -  SINGLE, PORTFOLIO, INDEX, ALL
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  querySubscriptionTransactionHistory(options? : { planId? :LONG, startTime? :LONG, endTime? :LONG, targetAsset? :string, planType? :"SINGLE"|"PORTFOLIO"|"INDEX"|"ALL", size? :LONG, current? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       id: number,  // example: 1111
       targetAsset: string,  // example: "BTC"  //name of the asset
       planType: string,  // example: "SINGLE"  //plan type of which this transaction is from
       planName: string,  // example: "BTC"  // plan name of which this transaction is from
       planId: number,  // example: 1234  // plan identifier of which this transaction is from
       transactionDateTime: number,  // example: 1648378800000  //transaction timestamp
       transactionStatus: string,  // example: "SUCCESS"  //status of the transaction: "SUCCESS","FAILED","PENDING"
       failedType: string,  // example: "INSUFFICIENT_BALANCE"  // only show when transactionStatus = FAILED,  INSUFFICIENT_BALANCE,TRANSACTION_REJECT/GCC_RJECT
       sourceAsset: string,  // example: "BUSD"  //source asset of the transaction
       sourceAssetAmount: NumberString,  // example: "297.12345"  //amount of source asset used
       targetAssetAmount: NumberString,  // example: "0.005"  //purchased amount of the asset
       sourceWallet: string,  // example: "SPOT_WALLET"  // SPOT_WALLET,FLEXIBLE_SAVINGS,SPOT_WALLET_FLEXIBLE_SAVINGS,REWARDS
       flexibleUsed: string,  // example: "false"  //whether simple earn wallet is used
       transactionFee: NumberString,  // example: "0.002"  //transaction fee amount
       transactionFeeUnit: string,  // example: "BUSD"  //denominated coin of the transaction fee
       executionPrice: NumberString,  // example: "2342"  //price of the subscription price. It's amount of source asset equivilent of 1 unit of target asset
       executionType: string,  // example: "RECURRING"  //ONE_TIME,RECURRING
       subscriptionCycle: string  // example: "WEEKLY"
     }[]>;
  
  
  querySubscriptionTransactionHistory(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/history/list", "GET", "USER_DATA", false, args, ["planId", "startTime", "endTime", "targetAsset", "planType", "size", "current", "recvWindow", "timestamp"], "querySubscriptionTransactionHistory");
  }
  
  
  /** Query Index Details(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-index-details-user_data}
   * 
   * Query index details
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/index/info
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} indexId
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  queryIndexDetails(indexId :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryIndexDetails"]>;
  
  
  /** Query Index Details(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-index-details-user_data}
   * 
   * Query index details
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/index/info
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.indexId
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  queryIndexDetails(options : { indexId :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     indexId: number,  // example: 1
     indexName: string,  // example: "BINANCE TOP 10 EW "
     status: string,  // example: "RUNNING"  // RUNNING/REBALANCING/PAUSED
     assetAllocation: {
         targetAsset: string,  // example: "ADA"  // for pie chart
         allocation: NumberString  // example: "10"
       }[]
    }>;
  
  
  queryIndexDetails(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/index/info", "GET", "USER_DATA", false, args, ["indexId", "recvWindow", "timestamp"], "queryIndexDetails");
  }
  
  
  /** Query Index Linked Plan Position Details(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-index-linked-plan-position-details-user_data}
   * 
   * Details on users Index-Linked plan position details
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/index/user-summary
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} indexId
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  queryIndexLinkedPlanPositionDetails(indexId :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryIndexLinkedPlanPositionDetails"]>;
  
  
  /** Query Index Linked Plan Position Details(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-index-linked-plan-position-details-user_data}
   * 
   * Details on users Index-Linked plan position details
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/index/user-summary
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.indexId
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  queryIndexLinkedPlanPositionDetails(options : { indexId :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     indexId: number,  // example: 1
     totalInvestedInUSD: NumberString,  // example: "114.555"
     currentInvestedInUSD: NumberString,  // example: "101.2"  //current invest
     pnlInUSD: NumberString,  // example: "101.2"  // PNL of the plan in USD based on current amount
     roi: NumberString,  // example: "1.023"  //ROI of the plan based on current amount
     assetAllocation: {
         targetAsset: string,  // example: "ADA"  // for pie chart
         allocation: NumberString  // example: "10"
       }[],
     details: {
         targetAsset: string,  // example: "ADA"
         averagePriceInUSD: NumberString,  // example: "3.4"  //average price of the asset in USD
         totalInvestedInUSD: NumberString,  // example: "222.21"  //total source asset invested for this target asset in equivilent of USD
         currentInvestedInUSD: NumberString,  // example: "101.2"  //current invest
         purchasedAmount: NumberString,  // example: "122.12345678"  //purchased amount of target asset
         pnlInUSD: NumberString,  // example: "109.2"  //PNL denominated in USD
         roi: NumberString,  // example: "0.1"  //ROI calculated in decimal
         percentage: NumberString,  // example: "10"  //asset allocation in the plan. If it's single plan, then it's 100
         availableAmount: NumberString,  // example: "122.12345678"
         redeemedAmount: NumberString,  // example: "122.12345678"
         assetValueInUSD: NumberString  // example: "101.2"
       }[]
    }>;
  
  
  queryIndexLinkedPlanPositionDetails(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/index/user-summary", "GET", "USER_DATA", false, args, ["indexId", "recvWindow", "timestamp"], "queryIndexLinkedPlanPositionDetails");
  }
  
  
  /** One Time Transaction(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#one-time-transaction-trade}
   * 
   * One time transaction
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/one-off
   * 
   * Weight(IP): 1
   * 
   * @param {string} sourceType  -  "MAIN_SITE" for Binance,"TR" for Binance Turkey
   * @param {string} requestId  -  if not null, must follow sourceType + unique string, e.g: TR12354859
   * @param {DECIMAL} subscriptionAmount
   * @param {string} sourceAsset  -  e.g "USDT"
   * @param {boolean} flexibleAllowedToUse  -  true/false；true: using flexible wallet
   * @param {LONG} planId  -  PORTFOLIO plan's Id
   * @param {LONG} indexId  -  now only can set = 1
   * @param {PortfolioDetail[]} details  -  sum(all node's percentage) == 100，sum(all node's percentage) == 100， When input request parameter, each entry should be like details[0].targetAsset=BTC, Example of the request parameter array:
   * details[0].targetAsset=BTC details[0].percentage=60 details[1].targetAsset=ETH details[1].percentage=40
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  oneTimeTransaction(sourceType :string, requestId :string|undefined, subscriptionAmount :DECIMAL, sourceAsset :string, flexibleAllowedToUse :boolean|undefined, planId :LONG|undefined, indexId :LONG|undefined, details :readonly PortfolioDetail[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["oneTimeTransaction"]>;
  
  
  /** One Time Transaction(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#one-time-transaction-trade}
   * 
   * One time transaction
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/one-off
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.sourceType  -  "MAIN_SITE" for Binance,"TR" for Binance Turkey
   * @param {string} options.requestId  -  if not null, must follow sourceType + unique string, e.g: TR12354859
   * @param {DECIMAL} options.subscriptionAmount
   * @param {string} options.sourceAsset  -  e.g "USDT"
   * @param {boolean} options.flexibleAllowedToUse  -  true/false；true: using flexible wallet
   * @param {LONG} options.planId  -  PORTFOLIO plan's Id
   * @param {LONG} options.indexId  -  now only can set = 1
   * @param {PortfolioDetail[]} options.details  -  sum(all node's percentage) == 100，sum(all node's percentage) == 100， When input request parameter, each entry should be like details[0].targetAsset=BTC, Example of the request parameter array:
   * details[0].targetAsset=BTC details[0].percentage=60 details[1].targetAsset=ETH details[1].percentage=40
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  oneTimeTransaction(options : { sourceType :string, requestId? :string, subscriptionAmount :DECIMAL, sourceAsset :string, flexibleAllowedToUse? :boolean, planId? :LONG, indexId? :LONG, details :readonly PortfolioDetail[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     transactionId: number,  // example: 12345  //transaction identifier
     waitSecond: number  // example: 5  // wait this second,then check the result
    }>;
  
  
  oneTimeTransaction(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/one-off", "POST", "TRADE", false, args, ["sourceType", "requestId", "subscriptionAmount", "sourceAsset", "flexibleAllowedToUse", "planId", "indexId", "details", "recvWindow", "timestamp"], "oneTimeTransaction");
  }
  
  
  /** Query One-Time Transaction Status(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-one-time-transaction-status-user_data}
   * 
   * Transaction status for one-time transaction
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/one-off/status
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} transactionId  -  PORTFOLIO plan's Id
   * @param {string} requestId  -  sourceType + unique, transactionId and requestId cannot be empty at the same time
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  queryOneTimeTransactionStatus(transactionId :LONG, requestId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryOneTimeTransactionStatus"]>;
  
  
  /** Query One-Time Transaction Status(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-one-time-transaction-status-user_data}
   * 
   * Transaction status for one-time transaction
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/one-off/status
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.transactionId  -  PORTFOLIO plan's Id
   * @param {string} options.requestId  -  sourceType + unique, transactionId and requestId cannot be empty at the same time
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  queryOneTimeTransactionStatus(options : { transactionId :LONG, requestId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     transactionId: number,  // example: 12345  //transaction identifier
     status: string  // example: "SUCCESS"  //status of transaction"SUCCESS"/"CONVERTING"
    }>;
  
  
  queryOneTimeTransactionStatus(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/one-off/status", "GET", "USER_DATA", false, args, ["transactionId", "requestId", "recvWindow", "timestamp"], "queryOneTimeTransactionStatus");
  }
  
  
  /** Index Linked Plan Redemption(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#index-linked-plan-redemption-trade}
   * 
   * To redeem index-Linked plan holdings
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/redeem
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} indexId  -  PORTFOLIO plan's Id
   * @param {string} requestId  -  sourceType + unique, transactionId and requestId cannot be empty at the same time
   * @param {LONG} redemptionPercentage  -  user redeem percentage,10/20/100..
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  indexLinkedPlanRedemption_Trade(indexId :LONG, requestId :string|undefined, redemptionPercentage :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["indexLinkedPlanRedemption_Trade"]>;
  
  
  /** Index Linked Plan Redemption(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#index-linked-plan-redemption-trade}
   * 
   * To redeem index-Linked plan holdings
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/redeem
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.indexId  -  PORTFOLIO plan's Id
   * @param {string} options.requestId  -  sourceType + unique, transactionId and requestId cannot be empty at the same time
   * @param {LONG} options.redemptionPercentage  -  user redeem percentage,10/20/100..
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  indexLinkedPlanRedemption_Trade(options : { indexId :LONG, requestId? :string, redemptionPercentage :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     redemptionId: number  // example: 19  //This is the identifier for this redemption requests
    }>;
  
  
  indexLinkedPlanRedemption_Trade(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/redeem", "POST", "TRADE", false, args, ["indexId", "requestId", "redemptionPercentage", "recvWindow", "timestamp"], "indexLinkedPlanRedemption_Trade");
  }
  
  
  /** Index Linked Plan Redemption(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#index-linked-plan-redemption-user_data}
   * 
   * Get the history of Index Linked Plan Redemption transactions
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/redeem/history
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} requestId  -  request id
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1,Default:1
   * @param {string} asset
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  indexLinkedPlanRedemption_UserData(requestId :LONG, startTime? :LONG, endTime? :LONG, current? :LONG, asset? :string, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["indexLinkedPlanRedemption_UserData"]>;
  
  
  /** Index Linked Plan Redemption(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#index-linked-plan-redemption-user_data}
   * 
   * Get the history of Index Linked Plan Redemption transactions
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/redeem/history
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.requestId  -  request id
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1,Default:1
   * @param {string} options.asset
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  indexLinkedPlanRedemption_UserData(options : { requestId :LONG, startTime? :LONG, endTime? :LONG, current? :LONG, asset? :string, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       indexId: number,  // example: 1  //index identifier
       indexName: string,  // example: "BINANCE TOP 10 EW"  //index name
       redemptionId: number,  // example: 11  //redemption record identifier
       status: string,  // example: "SUCCESS"  //redemption SUCCESS/FAILED
       asset: string,  // example: "BTC"  //asset invovled
       amount: NumberString,  // example: "0.005"  //redemption amount
       redemptionDateTime: number,  // example: 1648378800000  //redemption timestamp
       transactionFee: NumberString,  // example: "0"  //redemption fee
       transactionFeeUnit: string  // example: "USDT"  //denomination of redemption fee amount
     }[]>;
  
  
  indexLinkedPlanRedemption_UserData(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/redeem/history", "GET", "USER_DATA", false, args, ["requestId", "startTime", "endTime", "current", "asset", "size", "recvWindow", "timestamp"], "indexLinkedPlanRedemption_UserData");
  }
  
  
  /** Index Linked Plan Rebalance Details(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#index-linked-plan-rebalance-details-user_data}
   * 
   * Get the history of Index Linked Plan Redemption transactions
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/rebalance/history
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1,Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow  -  no more than 60000
   * @param {LONG} timestamp
   */
  indexLinkedPlanRebalanceDetails(startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["indexLinkedPlanRebalanceDetails"]>;
  
  
  /** Index Linked Plan Rebalance Details(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#index-linked-plan-rebalance-details-user_data}
   * 
   * Get the history of Index Linked Plan Redemption transactions
   * 
   * EndPoint: /sapi/v1/lending/auto-invest/rebalance/history
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1,Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow  -  no more than 60000
   * @param {LONG} options.timestamp
   */
  indexLinkedPlanRebalanceDetails(options? : { startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       indexId: number,  // example: 1  //index identifier
       indexName: string,  // example: "BINANCE TOP 10 EW"  //index name
       rebalanceId: number,  // example: 11  //rebalance identifier
       status: string,  // example: "SUCCESS"  //rebalance status  SUCCESS/INIT
       rebalanceFee: NumberString,  // example: "10"  //rebalance fee
       rebalanceFeeUnit: string,  // example: "USDT"  // rebalance fee unit
       transactionDetails: {
           asset: string,  // example: "BTC"  //assets to be rebalanced
           transactionDateTime: number,  // example: 1648378800000  //rebalance transaction timestamp
           rebalanceDirection: string,  // example: "BUY"  //rebalance direction
           rebalanceAmount: NumberString  // example: "0.005"  //rebalance amount for the asset
         }[]
     }[]>;
  
  
  indexLinkedPlanRebalanceDetails(...args : any) {
      return this._sendRequest("/sapi/v1/lending/auto-invest/rebalance/history", "GET", "USER_DATA", false, args, ["startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "indexLinkedPlanRebalanceDetails");
  }
  
  
  
  //***** Staking Endpoints *****
  
  
  /** Subscribe ETH Staking(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#subscribe-eth-staking-trade}
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/stake
   * 
   * Weight(IP): 150
   * 
   * @param {DECIMAL} amount  -  Amount in ETH, limit 4 decimals
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  subscribeETHStaking(amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["subscribeETHStaking"]>;
  
  
  /** Subscribe ETH Staking(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#subscribe-eth-staking-trade}
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/stake
   * 
   * Weight(IP): 150
   * 
   * @param {DECIMAL} options.amount  -  Amount in ETH, limit 4 decimals
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  subscribeETHStaking(options : { amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     success: boolean  // example: true
    }>;
  
  
  subscribeETHStaking(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/eth/stake", "POST", "TRADE", false, args, ["amount", "recvWindow", "timestamp"], "subscribeETHStaking");
  }
  
  
  /** Subscribe ETH Staking V2(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#subscribe-eth-staking-v2-trade}
   * 
   * Stake ETH to get WBETH
   * 
   * EndPoint: /sapi/v2/eth-staking/eth/stake
   * 
   * Weight(IP): 150
   * 
   * @param {DECIMAL} amount  -  Amount in ETH, limit 4 decimals
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  subscribeETHStakingV2(amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["subscribeETHStakingV2"]>;
  
  
  /** Subscribe ETH Staking V2(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#subscribe-eth-staking-v2-trade}
   * 
   * Stake ETH to get WBETH
   * 
   * EndPoint: /sapi/v2/eth-staking/eth/stake
   * 
   * Weight(IP): 150
   * 
   * @param {DECIMAL} options.amount  -  Amount in ETH, limit 4 decimals
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  subscribeETHStakingV2(options : { amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     success: boolean,  // example: true
     wbethAmount: NumberString,  // example: "0.23092091"
     conversionRatio: NumberString  // example: "1.001212342342"  // ETH amount per 1 WBETH
    }>;
  
  
  subscribeETHStakingV2(...args : any) {
      return this._sendRequest("/sapi/v2/eth-staking/eth/stake", "POST", "TRADE", false, args, ["amount", "recvWindow", "timestamp"], "subscribeETHStakingV2");
  }
  
  
  /** Redeem ETH (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#redeem-eth-trade}
   * 
   * Redeem WBETH or BETH and get ETH
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/redeem
   * 
   * Weight(IP): 150
   * 
   * @param {string} asset  -  WBETH or BETH, default to BETH
   * @param {DECIMAL} amount  -  Amount in BETH, limit 8 decimals
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  redeemETH(asset :string|undefined, amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["redeemETH"]>;
  
  
  /** Redeem ETH (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#redeem-eth-trade}
   * 
   * Redeem WBETH or BETH and get ETH
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/redeem
   * 
   * Weight(IP): 150
   * 
   * @param {string} options.asset  -  WBETH or BETH, default to BETH
   * @param {DECIMAL} options.amount  -  Amount in BETH, limit 8 decimals
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  redeemETH(options : { asset? :string, amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     success: boolean,  // example: true
     arrivalTime: number,  // example: 1575018510000
     ethAmount: NumberString,  // example: "0.23092091"
     conversionRatio: NumberString  // example: "1.00121234"
    }>;
  
  
  redeemETH(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/eth/redeem", "POST", "TRADE", false, args, ["asset", "amount", "recvWindow", "timestamp"], "redeemETH");
  }
  
  
  /** Get ETH staking history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-eth-staking-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/history/stakingHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default: 1
   * @param {LONG} size  -  Default: 10, Max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getETHStakingHistory(startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getETHStakingHistory"]>;
  
  
  /** Get ETH staking history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-eth-staking-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/history/stakingHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default: 1
   * @param {LONG} options.size  -  Default: 10, Max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getETHStakingHistory(options? : { startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         time: number,  // example: 1575018510000
         asset: string,  // example: "ETH"
         amount: NumberString,  // example: "21312.23223"
         status: string,  // example: "SUCCESS"  //PENDING,SUCCESS,FAILED
         distributeAmount: NumberString,  // example: "21286.42584"
         conversionRatio: NumberString  // example: "1.00121234"
       }[],
     total: number  // example: 1
    }>;
  
  
  getETHStakingHistory(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/eth/history/stakingHistory", "GET", "USER_DATA", false, args, ["startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getETHStakingHistory");
  }
  
  
  /** Get ETH redemption history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-eth-redemption-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/history/redemptionHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default: 1
   * @param {LONG} size  -  Default: 10, Max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getETHRedemptionHistory(startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getETHRedemptionHistory"]>;
  
  
  /** Get ETH redemption history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-eth-redemption-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/history/redemptionHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default: 1
   * @param {LONG} options.size  -  Default: 10, Max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getETHRedemptionHistory(options? : { startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         time: number,  // example: 1575018510000
         arrivalTime: number,  // example: 1575018510000
         amount: NumberString,  // example: "21312.23223"
         status: string,  // example: "SUCCESS"
         asset: string,  // example: "WBETH"
         distributeAsset: string,  // example: "ETH"  //PENDING,SUCCESS,FAILED
         distributeAmount: NumberString,  // example: "21338.0699"
         conversionRatio: NumberString  // example: "1.00121234"
       }[],
     total: number  // example: 1
    }>;
  
  
  getETHRedemptionHistory(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/eth/history/redemptionHistory", "GET", "USER_DATA", false, args, ["startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getETHRedemptionHistory");
  }
  
  
  /** Get BETH rewards distribution history(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-beth-rewards-distribution-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/history/rewardsHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default: 1
   * @param {LONG} size  -  Default: 10, Max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getBETHRewardsDistributionHistory(startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getBETHRewardsDistributionHistory"]>;
  
  
  /** Get BETH rewards distribution history(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-beth-rewards-distribution-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/history/rewardsHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default: 1
   * @param {LONG} options.size  -  Default: 10, Max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getBETHRewardsDistributionHistory(options? : { startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         time: number,  // example: 1575018510000
         asset: string,  // example: "BETH"
         holding: NumberString,  // example: "2.3223"  // BETH holding balance
         amount: NumberString,  // example: "0.23223"  // Distributed rewards
         annualPercentageRate: NumberString,  // example: "0.5"  // 0.5 means 50% here
         status: string  // example: "SUCCESS"
       }[],
     total: number  // example: 1
    }>;
  
  
  getBETHRewardsDistributionHistory(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/eth/history/rewardsHistory", "GET", "USER_DATA", false, args, ["startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getBETHRewardsDistributionHistory");
  }
  
  
  /** Get current ETH staking quota (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-current-eth-staking-quota-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/quota
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getCurrentETHStakingQuota(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getCurrentETHStakingQuota"]>;
  
  
  /** Get current ETH staking quota (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-current-eth-staking-quota-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/quota
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getCurrentETHStakingQuota(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     leftStakingPersonalQuota: NumberString,  // example: "1000"  // Show min(Daily available limit, total personal staking quota)
     leftRedemptionPersonalQuota: NumberString  // example: "1000"  // Show min(Daily personal redeem quota, total redemption limit)
    }>;
  
  
  getCurrentETHStakingQuota(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/eth/quota", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "getCurrentETHStakingQuota");
  }
  
  
  /** Get WBETH Rate History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-wbeth-rate-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/history/rateHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getWBETHRateHistory(startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getWBETHRateHistory"]>;
  
  
  /** Get WBETH Rate History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-wbeth-rate-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/history/rateHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getWBETHRateHistory(options? : { startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         annualPercentageRate: NumberString,  // example: "0.00006408"  // BETH APR
         exchangeRate: NumberString,  // example: "1.00121234"  // BETH value per 1 WBETH
         time: number  // example: 1577233578000
       }[],
     total: NumberString  // example: "1"
    }>;
  
  
  getWBETHRateHistory(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/eth/history/rateHistory", "GET", "USER_DATA", false, args, ["startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getWBETHRateHistory");
  }
  
  
  /** ETH Staking account (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#eth-staking-account-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/account
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  etHStakingAccount(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["etHStakingAccount"]>;
  
  
  /** ETH Staking account (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#eth-staking-account-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/account
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  etHStakingAccount(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     cumulativeProfitInBETH: NumberString,  // example: "0.01067982"
     lastDayProfitInBETH: NumberString  // example: "0.01067982"
    }>;
  
  
  etHStakingAccount(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/account", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "etHStakingAccount");
  }
  
  
  /** ETH Staking account V2(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#eth-staking-account-v2-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v2/eth-staking/account
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  etHStakingAccountV2(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["etHStakingAccountV2"]>;
  
  
  /** ETH Staking account V2(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#eth-staking-account-v2-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v2/eth-staking/account
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  etHStakingAccountV2(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     holdingInETH: NumberString,  // example: "1.22330928"
     holdings: {
       wbethAmount: NumberString,  // example: "1.10928781"
       bethAmount: NumberString  // example: "1.90002112"
     },
     thirtyDaysProfitInETH: NumberString,  // example: "0.22330928"
     profit: {
       amountFromWBETH: NumberString,  // example: "0.12330928"  //Profit accrued within WBETH
       amountFromBETH: NumberString  // example: "0.1"  //BETH distributed to your Spot Wallet
     }
    }>;
  
  
  etHStakingAccountV2(...args : any) {
      return this._sendRequest("/sapi/v2/eth-staking/account", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "etHStakingAccountV2");
  }
  
  
  /** Wrap BETH(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#wrap-beth-trade}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/wbeth/wrap
   * 
   * Weight(IP): 150
   * 
   * @param {DECIMAL} amount  -  Amount in BETH, limit 4 decimals
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  wrapBETH(amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["wrapBETH"]>;
  
  
  /** Wrap BETH(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#wrap-beth-trade}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/wbeth/wrap
   * 
   * Weight(IP): 150
   * 
   * @param {DECIMAL} options.amount  -  Amount in BETH, limit 4 decimals
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  wrapBETH(options : { amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     success: boolean,  // example: true
     wbethAmount: NumberString,  // example: "0.23092091"
     exchangeRate: NumberString  // example: "1.001212343432"
    }>;
  
  
  wrapBETH(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/wbeth/wrap", "POST", "TRADE", false, args, ["amount", "recvWindow", "timestamp"], "wrapBETH");
  }
  
  
  /** Get WBETH wrap history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-wbeth-wrap-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/wbeth/history/wrapHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getWBETHWrapHistory(startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getWBETHWrapHistory"]>;
  
  
  /** Get WBETH wrap history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-wbeth-wrap-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/wbeth/history/wrapHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getWBETHWrapHistory(options? : { startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         time: number,  // example: 1575018510000
         fromAsset: string,  // example: "BETH"
         fromAmount: NumberString,  // example: "21312.23223"
         toAsset: string,  // example: "WBETH"
         toAmount: NumberString,  // example: "21312.23223"
         exchangeRate: NumberString,  // example: "1.01243253"  // BETH amount per 1 WBETH
         status: string  // example: "SUCCESS"  //PENDING,SUCCESS,FAILED
       }[],
     total: number  // example: 1
    }>;
  
  
  getWBETHWrapHistory(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/wbeth/history/wrapHistory", "GET", "USER_DATA", false, args, ["startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getWBETHWrapHistory");
  }
  
  
  /** Get WBETH unwrap history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-wbeth-unwrap-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/wbeth/history/unwrapHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getWBETHUnwrapHistory(startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getWBETHUnwrapHistory"]>;
  
  
  /** Get WBETH unwrap history (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-wbeth-unwrap-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/wbeth/history/unwrapHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getWBETHUnwrapHistory(options? : { startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         time: number,  // example: 1575018510000
         fromAsset: string,  // example: "WBETH"
         fromAmount: NumberString,  // example: "21312.23223"
         toAsset: string,  // example: "BETH"
         toAmount: NumberString,  // example: "21312.23223"
         exchangeRate: NumberString,  // example: "1.01243253"  // BETH value per 1 WBETH
         status: string  // example: "SUCCESS"  //PENDING,SUCCESS,FAILED
       }[],
     total: number  // example: 1
    }>;
  
  
  getWBETHUnwrapHistory(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/wbeth/history/unwrapHistory", "GET", "USER_DATA", false, args, ["startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getWBETHUnwrapHistory");
  }
  
  
  /** Get WBETH rewards history(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-wbeth-rewards-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/history/wbethRewardsHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10, Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getWBETHRewardsHistory(startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getWBETHRewardsHistory"]>;
  
  
  /** Get WBETH rewards history(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-wbeth-rewards-history-user_data}
   * 
   * 150
   * 
   * EndPoint: /sapi/v1/eth-staking/eth/history/wbethRewardsHistory
   * 
   * Weight(IP): 150
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10, Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getWBETHRewardsHistory(options? : { startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     estRewardsInETH: NumberString,  // example: "1.23230920"
     rows: {
         time: number,  // example: 1575018510000
         amountInETH: NumberString,  // example: "0.23223"  // Estimated rewards accrued within WBETH
         holding: NumberString,  // example: "2.3223"  // WBETH holding balance
         holdingInETH: NumberString,  // example: "2.4231"
         annualPercentageRate: NumberString  // example: "0.5"
       }[],
     total: number  // example: 1
    }>;
  
  
  getWBETHRewardsHistory(...args : any) {
      return this._sendRequest("/sapi/v1/eth-staking/eth/history/wbethRewardsHistory", "GET", "USER_DATA", false, args, ["startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getWBETHRewardsHistory");
  }
  
  
  
  //***** Mining Endpoints *****
  
  
  /** Acquiring Algorithm (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#acquiring-algorithm-market_data}
   * 
   * EndPoint: /sapi/v1/mining/pub/algoList
   * 
   * Weight(IP): 1
   * 
   */
  acquiringAlgorithm() : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
         algoName: string,  // example: "sha256"  //  Algorithm name
         algoId: number,  // example: 1  // Algorithm ID
         poolIndex: number,  // example: 0  // Sequence
         unit: string  // example: "h/s"  //   Unit
       }[]
    }> {
      return this._sendRequest("/sapi/v1/mining/pub/algoList", "GET", "MARKET_DATA", false, [], [], "acquiringAlgorithm");
  }
  
  
  /** Acquiring CoinName (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#acquiring-coinname-market_data}
   * 
   * EndPoint: /sapi/v1/mining/pub/coinList
   * 
   * Weight(IP): 1
   * 
   */
  acquiringCoinName() : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
         coinName: string,  // example: "BTC"  //  Currencyname
         coinId: number,  // example: 1  // id
         poolIndex: number,  // example: 0  // Sort
         algoId: number,  // example: 1  // Algorithm
         algoName: string  // example: "sha256"  //Name of algorithm
       }[]
    }> {
      return this._sendRequest("/sapi/v1/mining/pub/coinList", "GET", "MARKET_DATA", false, [], [], "acquiringCoinName");
  }
  
  
  /** Request for Detail Miner List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#request-for-detail-miner-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/worker/detail
   * 
   * Weight(IP): 5
   * 
   * @param {string} algo  -  Algorithm(sha256)
   * @param {string} userName  -  Mining account
   * @param {string} workerName  -  Miner’s name(required)
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  requestForDetailMinerList(algo :string, userName :string, workerName :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["requestForDetailMinerList"]>;
  
  
  /** Request for Detail Miner List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#request-for-detail-miner-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/worker/detail
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.algo  -  Algorithm(sha256)
   * @param {string} options.userName  -  Mining account
   * @param {string} options.workerName  -  Miner’s name(required)
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  requestForDetailMinerList(options : { algo :string, userName :string, workerName :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
         workerName: string,  // example: "bhdc1.16A10404B"  //Mining Account name
         type: string,  // example: "H_hashrate"  // Type of hourly hashrate
         hashrateDatas: {
             time: number,  // example: 1587902400000  //  Time
             hashrate: NumberString,  // example: "0"  // Hashrate
             reject: number  // example: 0  //Rejection Rate
           }[]
       }[]
    }>;
  
  
  requestForDetailMinerList(...args : any) {
      return this._sendRequest("/sapi/v1/mining/worker/detail", "GET", "USER_DATA", false, args, ["algo", "userName", "workerName", "recvWindow", "timestamp"], "requestForDetailMinerList");
  }
  
  
  /** Request for Miner List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#request-for-miner-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/worker/list
   * 
   * Weight(IP): 5
   * 
   * @param {string} algo  -  Algorithm(sha256)
   * @param {string} userName  -  Mining account
   * @param {INTEGER} pageIndex  -  Page number，default is first page，start from 1
   * @param {INTEGER} sort  -  sort sequence(default=0)0 positive sequence，1 negative sequence
   * @param {INTEGER} sortColumn  -  Sort by( default 1): 1: miner name, 2: real-time computing power, 3: daily average computing power, 4: real-time rejection rate, 5: last submission time
   * @param {INTEGER} workerStatus  -  miners status(default=0), 0 all, 1 valid，2 invalid, 3 failure
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  requestForMinerList(algo :string, userName :string, pageIndex? :INTEGER, sort? :INTEGER, sortColumn? :INTEGER, workerStatus? :INTEGER, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["requestForMinerList"]>;
  
  
  /** Request for Miner List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#request-for-miner-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/worker/list
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.algo  -  Algorithm(sha256)
   * @param {string} options.userName  -  Mining account
   * @param {INTEGER} options.pageIndex  -  Page number，default is first page，start from 1
   * @param {INTEGER} options.sort  -  sort sequence(default=0)0 positive sequence，1 negative sequence
   * @param {INTEGER} options.sortColumn  -  Sort by( default 1): 1: miner name, 2: real-time computing power, 3: daily average computing power, 4: real-time rejection rate, 5: last submission time
   * @param {INTEGER} options.workerStatus  -  miners status(default=0), 0 all, 1 valid，2 invalid, 3 failure
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  requestForMinerList(options : { algo :string, userName :string, pageIndex? :INTEGER, sort? :INTEGER, sortColumn? :INTEGER, workerStatus? :INTEGER, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
       workerDatas: {
           workerId: NumberString,  // example: "1420554439452400131"  //Miner ID
           workerName: string,  // example: "2X73"  //Miner's name
           status: number,  // example: 3  // Status:1 valid, 2 invalid, 3 no longer valid
           hashRate: number,  // example: 0  // Real-time rate
           dayHashRate: number,  // example: 0  //24H Hashrate
           rejectRate: number,  // example: 0  //Real-time Rejection Rate
           lastShareTime: number  // example: 1587712919000  // Last submission time
         }[],
       totalNum: number,  // example: 18530  // Total amount
       pageSize: number  // example: 20  // Rows per page
     }
    }>;
  
  
  requestForMinerList(...args : any) {
      return this._sendRequest("/sapi/v1/mining/worker/list", "GET", "USER_DATA", false, args, ["algo", "userName", "pageIndex", "sort", "sortColumn", "workerStatus", "recvWindow", "timestamp"], "requestForMinerList");
  }
  
  
  /** Earnings List(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#earnings-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/payment/list
   * 
   * Weight(IP): 5
   * 
   * @param {string} algo  -  Transfer algorithm(sha256)
   * @param {string} userName  -  Mining account
   * @param {string} coin  -  Coin name
   * @param {LONG} startDate  -  Search date, millisecond timestamp, while empty query all
   * @param {LONG} endDate  -  Search date, millisecond timestamp, while empty query all
   * @param {INTEGER} pageIndex  -  Page number, empty default first page, starting from 1
   * @param {INTEGER} pageSize  -  Number of pages, minimum 10, maximum 200
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  earningsList(algo :string, userName :string, coin? :string, startDate? :LONG, endDate? :LONG, pageIndex? :INTEGER, pageSize? :INTEGER, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["earningsList"]>;
  
  
  /** Earnings List(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#earnings-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/payment/list
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.algo  -  Transfer algorithm(sha256)
   * @param {string} options.userName  -  Mining account
   * @param {string} options.coin  -  Coin name
   * @param {LONG} options.startDate  -  Search date, millisecond timestamp, while empty query all
   * @param {LONG} options.endDate  -  Search date, millisecond timestamp, while empty query all
   * @param {INTEGER} options.pageIndex  -  Page number, empty default first page, starting from 1
   * @param {INTEGER} options.pageSize  -  Number of pages, minimum 10, maximum 200
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  earningsList(options : { algo :string, userName :string, coin? :string, startDate? :LONG, endDate? :LONG, pageIndex? :INTEGER, pageSize? :INTEGER, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
       accountProfits: (
         {
           time: number,  // example: 1586188800000  // Mining date
           type: number,  // example: 31  // 0:Mining Wallet,5:Mining Address,7:Pool Savings,8:Transferred,31:Income Transfer ,32:Hashrate Resale-Mining Wallet 33:Hashrate Resale-Pool Savings
           hashTransfer: null,  // example: null  // Transferred Hashrate
           transferAmount: null,  // example: null  // Transferred Income
           dayHashRate: number,  // example: 129129903378244  // Daily Hashrate
           profitAmount: number,  // example: 8.6083060304  //Earnings Amount
           coinName: string,  // example: "BTC"  // Coin Type
           status: number  // example: 2  //Status:0:Unpaid, 1:Paying  2:Paid
         } |
         {
           time: number,  // example: 1607529600000
           coinName: string,  // example: "BTC"
           type: number,  // example: 0
           dayHashRate: number,  // example: 9942053925926
           profitAmount: number,  // example: 0.85426469
           hashTransfer: number,  // example: 200000000000
           transferAmount: number,  // example: 0.02180958
           status: number  // example: 2
         }
       )[],
       totalNum: number,  // example: 3  // Total Rows
       pageSize: number  // example: 20  // Rows per page
     }
    }>;
  
  
  earningsList(...args : any) {
      return this._sendRequest("/sapi/v1/mining/payment/list", "GET", "USER_DATA", false, args, ["algo", "userName", "coin", "startDate", "endDate", "pageIndex", "pageSize", "recvWindow", "timestamp"], "earningsList");
  }
  
  
  /** Extra Bonus List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#extra-bonus-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/payment/other
   * 
   * Weight(IP): 5
   * 
   * @param {string} algo  -  Transfer algorithm(sha256)
   * @param {string} userName  -  Mining Account
   * @param {string} coin  -  Coin Name
   * @param {LONG} startDate  -  Search date, millisecond timestamp, while empty query all
   * @param {LONG} endDate  -  Search date, millisecond timestamp, while empty query all
   * @param {INTEGER} pageIndex  -  Page number, empty default first page, starting from 1
   * @param {INTEGER} pageSize  -  Number of pages, minimum 10, maximum 200
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  extraBonusList(algo :string, userName :string, coin? :string, startDate? :LONG, endDate? :LONG, pageIndex? :INTEGER, pageSize? :INTEGER, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["extraBonusList"]>;
  
  
  /** Extra Bonus List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#extra-bonus-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/payment/other
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.algo  -  Transfer algorithm(sha256)
   * @param {string} options.userName  -  Mining Account
   * @param {string} options.coin  -  Coin Name
   * @param {LONG} options.startDate  -  Search date, millisecond timestamp, while empty query all
   * @param {LONG} options.endDate  -  Search date, millisecond timestamp, while empty query all
   * @param {INTEGER} options.pageIndex  -  Page number, empty default first page, starting from 1
   * @param {INTEGER} options.pageSize  -  Number of pages, minimum 10, maximum 200
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  extraBonusList(options : { algo :string, userName :string, coin? :string, startDate? :LONG, endDate? :LONG, pageIndex? :INTEGER, pageSize? :INTEGER, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
       otherProfits: {
           time: number,  // example: 1607443200000  // Mining date
           coinName: string,  // example: "BTC"  // Coin Name
           type: number,  // example: 4  // 1: Merged Mining, 2: Activity Bonus, 3:Rebate 4:Smart Pool 6:Income Transfer 7:Pool Savings
           profitAmount: number,  // example: 0.0011859  //Amount
           status: number  // example: 2  //Status:0:Unpaid, 1:Paying  2:Paid
         }[],
       totalNum: number,  // example: 3  // Total Rows
       pageSize: number  // example: 20  // Rows per page
     }
    }>;
  
  
  extraBonusList(...args : any) {
      return this._sendRequest("/sapi/v1/mining/payment/other", "GET", "USER_DATA", false, args, ["algo", "userName", "coin", "startDate", "endDate", "pageIndex", "pageSize", "recvWindow", "timestamp"], "extraBonusList");
  }
  
  
  /** Hashrate Resale List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#hashrate-resale-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/hash-transfer/config/details/list
   * 
   * Weight(IP): 5
   * 
   * @param {INTEGER} pageIndex  -  Page number, empty default first page, starting from 1
   * @param {INTEGER} pageSize  -  Number of pages, minimum 10, maximum 200
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  hashrateResaleList(pageIndex? :INTEGER, pageSize? :INTEGER, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["hashrateResaleList"]>;
  
  
  /** Hashrate Resale List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#hashrate-resale-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/hash-transfer/config/details/list
   * 
   * Weight(IP): 5
   * 
   * @param {INTEGER} options.pageIndex  -  Page number, empty default first page, starting from 1
   * @param {INTEGER} options.pageSize  -  Number of pages, minimum 10, maximum 200
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  hashrateResaleList(options? : { pageIndex? :INTEGER, pageSize? :INTEGER, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
       configDetails: (
         {
           configId: number,  // example: 168  // Mining ID
           poolUsername: NumberString,  // example: "123"  //Transfer out of subaccount
           toPoolUsername: string,  // example: "user1"  //  Transfer into subaccount
           algoName: string,  // example: "Ethash"  // Transfer algorithm
           hashRate: number,  // example: 5000000  //  Transferred Hashrate quantity
           startDay: number,  // example: 20201210  // Start date
           endDay: number,  // example: 20210405  //End date
           status: number  // example: 1  //Status:0 Processing,1:Cancelled,2:Terminated
         } |
         {
           configId: number,  // example: 166
           poolUsername: string,  // example: "pop"
           toPoolUsername: NumberString,  // example: "111111"
           algoName: string,  // example: "Ethash"
           hashRate: number,  // example: 3320000
           startDay: number,  // example: 20201226
           endDay: number,  // example: 20201227
           status: number  // example: 0
         }
       )[],
       totalNum: number,  // example: 21
       pageSize: number  // example: 200
     }
    }>;
  
  
  hashrateResaleList(...args : any) {
      return this._sendRequest("/sapi/v1/mining/hash-transfer/config/details/list", "GET", "USER_DATA", false, args, ["pageIndex", "pageSize", "recvWindow", "timestamp"], "hashrateResaleList");
  }
  
  
  /** Hashrate Resale Detail (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#hashrate-resale-detail-user_data}
   * 
   * EndPoint: /sapi/v1/mining/hash-transfer/profit/details
   * 
   * Weight(IP): 5
   * 
   * @param {INTEGER} configId  -  Mining ID
   * @param {string} userName  -  Mining Account
   * @param {INTEGER} pageIndex  -  Page number, empty default first page, starting from 1
   * @param {INTEGER} pageSize  -  Number of pages, minimum 10, maximum 200
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  hashrateResaleDetail(configId :INTEGER, userName :string, pageIndex? :INTEGER, pageSize? :INTEGER, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["hashrateResaleDetail"]>;
  
  
  /** Hashrate Resale Detail (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#hashrate-resale-detail-user_data}
   * 
   * EndPoint: /sapi/v1/mining/hash-transfer/profit/details
   * 
   * Weight(IP): 5
   * 
   * @param {INTEGER} options.configId  -  Mining ID
   * @param {string} options.userName  -  Mining Account
   * @param {INTEGER} options.pageIndex  -  Page number, empty default first page, starting from 1
   * @param {INTEGER} options.pageSize  -  Number of pages, minimum 10, maximum 200
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  hashrateResaleDetail(options : { configId :INTEGER, userName :string, pageIndex? :INTEGER, pageSize? :INTEGER, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
       profitTransferDetails: {
           poolUsername: string,  // example: "test4001"  // Transfer out of sub-account
           toPoolUsername: string,  // example: "pop"  // Transfer into subaccount
           algoName: string,  // example: "sha256"  // Transfer algorithm
           hashRate: number,  // example: 200000000000  // Transferred Hashrate quantity
           day: number,  // example: 20201213  // Transfer date
           amount: number,  // example: 0.2256872  // Transferred income
           coinName: string  // example: "BTC"  // Coin Name
         }[],
       totalNum: number,  // example: 8
       pageSize: number  // example: 200
     }
    }>;
  
  
  hashrateResaleDetail(...args : any) {
      return this._sendRequest("/sapi/v1/mining/hash-transfer/profit/details", "GET", "USER_DATA", false, args, ["configId", "userName", "pageIndex", "pageSize", "recvWindow", "timestamp"], "hashrateResaleDetail");
  }
  
  
  /** Hashrate Resale Request (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#hashrate-resale-request-user_data}
   * 
   * EndPoint: /sapi/v1/mining/hash-transfer/config
   * 
   * Weight(IP): 5
   * 
   * @param {string} userName  -  Mining Account
   * @param {string} algo  -  Transfer algorithm(sha256)
   * @param {LONG} endDate  -  Resale End Time (Millisecond timestamp)
   * @param {LONG} startDate  -  Resale Start Time(Millisecond timestamp)
   * @param {string} toPoolUser  -  Mining Account
   * @param {LONG} hashRate  -  Resale hashrate h/s must be transferred (BTC is greater than 500000000000 ETH is greater than 500000)
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  hashrateResaleRequest(userName :string, algo :string, endDate :LONG, startDate :LONG, toPoolUser :string, hashRate :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["hashrateResaleRequest"]>;
  
  
  /** Hashrate Resale Request (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#hashrate-resale-request-user_data}
   * 
   * EndPoint: /sapi/v1/mining/hash-transfer/config
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.userName  -  Mining Account
   * @param {string} options.algo  -  Transfer algorithm(sha256)
   * @param {LONG} options.endDate  -  Resale End Time (Millisecond timestamp)
   * @param {LONG} options.startDate  -  Resale Start Time(Millisecond timestamp)
   * @param {string} options.toPoolUser  -  Mining Account
   * @param {LONG} options.hashRate  -  Resale hashrate h/s must be transferred (BTC is greater than 500000000000 ETH is greater than 500000)
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  hashrateResaleRequest(options : { userName :string, algo :string, endDate :LONG, startDate :LONG, toPoolUser :string, hashRate :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,   // example: ""
     data: number   // example: 171  // Mining Account
    }>;
  
  
  hashrateResaleRequest(...args : any) {
      return this._sendRequest("/sapi/v1/mining/hash-transfer/config", "POST", "USER_DATA", false, args, ["userName", "algo", "endDate", "startDate", "toPoolUser", "hashRate", "recvWindow", "timestamp"], "hashrateResaleRequest");
  }
  
  
  /** Cancel hashrate resale configuration(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-hashrate-resale-configuration-user_data}
   * 
   * EndPoint: /sapi/v1/mining/hash-transfer/config/cancel
   * 
   * Weight(IP): 5
   * 
   * @param {INTEGER} configId  -  Mining ID
   * @param {string} userName  -  Mining Account
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  cancelHashrateResaleConfiguration(configId :INTEGER, userName :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["cancelHashrateResaleConfiguration"]>;
  
  
  /** Cancel hashrate resale configuration(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-hashrate-resale-configuration-user_data}
   * 
   * EndPoint: /sapi/v1/mining/hash-transfer/config/cancel
   * 
   * Weight(IP): 5
   * 
   * @param {INTEGER} options.configId  -  Mining ID
   * @param {string} options.userName  -  Mining Account
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  cancelHashrateResaleConfiguration(options : { configId :INTEGER, userName :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,   // example: ""
     data: boolean  // example: true
    }>;
  
  
  cancelHashrateResaleConfiguration(...args : any) {
      return this._sendRequest("/sapi/v1/mining/hash-transfer/config/cancel", "POST", "USER_DATA", false, args, ["configId", "userName", "recvWindow", "timestamp"], "cancelHashrateResaleConfiguration");
  }
  
  
  /** Statistic List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#statistic-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/statistics/user/status
   * 
   * Weight(IP): 5
   * 
   * @param {string} algo  -  Algorithm(sha256)
   * @param {string} userName  -  Mining account
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  statisticList(algo :string, userName :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["statisticList"]>;
  
  
  /** Statistic List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#statistic-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/statistics/user/status
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.algo  -  Algorithm(sha256)
   * @param {string} options.userName  -  Mining account
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  statisticList(options : { algo :string, userName :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
       fifteenMinHashRate: NumberString,  // example: "457835490067496409.00000000"  // 15 mins hashrate
       dayHashRate: NumberString,  // example: "214289268068874127.65000000"  //  24H Hashrate
       validNum: number,  // example: 0  // Effective quantity
       invalidNum: number,  // example: 17562  // Invalid quantity
       profitToday: {
         BTC: NumberString,  // example: "0.00314332"
         BSV: NumberString,  // example: "56.17055953"
         BCH: NumberString  // example: "106.61586001"
       },
       profitYesterday: {
         BTC: NumberString,  // example: "0.00314332"
         BSV: NumberString,  // example: "56.17055953"
         BCH: NumberString  // example: "106.61586001"
       },
       userName: string,  // example: "test"  // Mining account
       unit: string,  // example: "h/s"  //  Hashrate unit
       algo: string  // example: "sha256"  // Algorithm
     }
    }>;
  
  
  statisticList(...args : any) {
      return this._sendRequest("/sapi/v1/mining/statistics/user/status", "GET", "USER_DATA", false, args, ["algo", "userName", "recvWindow", "timestamp"], "statisticList");
  }
  
  
  /** Account List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/statistics/user/list
   * 
   * Weight(IP): 5
   * 
   * @param {string} algo  -  Algorithm(sha256)
   * @param {string} userName  -  Mining account
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  accountList(algo :string, userName :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["accountList"]>;
  
  
  /** Account List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#account-list-user_data}
   * 
   * EndPoint: /sapi/v1/mining/statistics/user/list
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.algo  -  Algorithm(sha256)
   * @param {string} options.userName  -  Mining account
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  accountList(options : { algo :string, userName :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
         type: string,  // example: "H_hashrate"  //Type of hourly hashrate
         userName: string,  // example: "test"  // Mining account
         list: {
             time: number,  // example: 1585267200000  // Time
             hashrate: NumberString,  // example: "0.00000000"  // Hashrate
             reject: NumberString  // example: "0.00000000"  //Rejection Rate
           }[]
       }[]
    }>;
  
  
  accountList(...args : any) {
      return this._sendRequest("/sapi/v1/mining/statistics/user/list", "GET", "USER_DATA", false, args, ["algo", "userName", "recvWindow", "timestamp"], "accountList");
  }
  
  
  /** Mining Account Earning (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#mining-account-earning-user_data}
   * 
   * EndPoint: /sapi/v1/mining/payment/uid
   * 
   * Weight(IP): 5
   * 
   * @param {string} algo  -  Algorithm(sha256)
   * @param {LONG} startDate  -  Millisecond timestamp
   * @param {LONG} endDate  -  Millisecond timestamp
   * @param {INTEGER} pageIndex  -  Default 1
   * @param {INTEGER} pageSize  -  Min 10,Max 200
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  miningAccountEarning(algo :string, startDate? :LONG, endDate? :LONG, pageIndex? :INTEGER, pageSize? :INTEGER, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["miningAccountEarning"]>;
  
  
  /** Mining Account Earning (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#mining-account-earning-user_data}
   * 
   * EndPoint: /sapi/v1/mining/payment/uid
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.algo  -  Algorithm(sha256)
   * @param {LONG} options.startDate  -  Millisecond timestamp
   * @param {LONG} options.endDate  -  Millisecond timestamp
   * @param {INTEGER} options.pageIndex  -  Default 1
   * @param {INTEGER} options.pageSize  -  Min 10,Max 200
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  miningAccountEarning(options : { algo :string, startDate? :LONG, endDate? :LONG, pageIndex? :INTEGER, pageSize? :INTEGER, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,  // example: ""
     data: {
       accountProfits: {
           time: number,  // example: 1607443200000
           coinName: string,  // example: "BTC"  // Coin
           type: number,  // example: 2  // 0:Referral 1:Refund 2:Rebate
           puid: number,  // example: 59985472  //Sub-account id
           subName: string,  // example: "vdvaghani"  //Mining account
           amount: number  // example: 0.09186957  //Amount
         }[],
       totalNum: number,  // example: 3  // Total records
       pageSize: number  // example: 20  // Size of one page
     }
    }>;
  
  
  miningAccountEarning(...args : any) {
      return this._sendRequest("/sapi/v1/mining/payment/uid", "GET", "USER_DATA", false, args, ["algo", "startDate", "endDate", "pageIndex", "pageSize", "recvWindow", "timestamp"], "miningAccountEarning");
  }
  
  
  
  //***** Futures *****
  
  
  /** New Future Account Transfer (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-future-account-transfer-user_data}
   * 
   * Execute transfer between spot account and futures account.
   * 
   * EndPoint: /sapi/v1/futures/transfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} asset  -  The asset being transferred, e.g., USDT
   * @param {DECIMAL} amount  -  The amount to be transferred
   * @param {INT} type  -  1: transfer from spot account to USDT-Ⓜ futures account. 2: transfer from USDT-Ⓜ futures account to spot account. 3: transfer from spot account to COIN-Ⓜ futures account. 4: transfer from COIN-Ⓜ futures account to spot account.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  newFutureAccountTransfer(asset :string, amount :DECIMAL, type :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["newFutureAccountTransfer"]>;
  
  
  /** New Future Account Transfer (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#new-future-account-transfer-user_data}
   * 
   * Execute transfer between spot account and futures account.
   * 
   * EndPoint: /sapi/v1/futures/transfer
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.asset  -  The asset being transferred, e.g., USDT
   * @param {DECIMAL} options.amount  -  The amount to be transferred
   * @param {INT} options.type  -  1: transfer from spot account to USDT-Ⓜ futures account. 2: transfer from USDT-Ⓜ futures account to spot account. 3: transfer from spot account to COIN-Ⓜ futures account. 4: transfer from COIN-Ⓜ futures account to spot account.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  newFutureAccountTransfer(options : { asset :string, amount :DECIMAL, type :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     tranId: number  // example: 100000001  //transaction id
    }>;
  
  
  newFutureAccountTransfer(...args : any) {
      return this._sendRequest("/sapi/v1/futures/transfer", "POST", "USER_DATA", false, args, ["asset", "amount", "type", "recvWindow", "timestamp"], "newFutureAccountTransfer");
  }
  
  
  /** Get Future Account Transaction History List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-future-account-transaction-history-list-user_data}
   * 
   * EndPoint: /sapi/v1/futures/transfer
   * 
   * Weight(IP): 10
   * 
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10 Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFutureAccountTransactionHistoryList(asset :string|undefined, startTime :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFutureAccountTransactionHistoryList"]>;
  
  
  /** Get Future Account Transaction History List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-future-account-transaction-history-list-user_data}
   * 
   * EndPoint: /sapi/v1/futures/transfer
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFutureAccountTransactionHistoryList(options : { asset? :string, startTime :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         asset: string,  // example: "USDT"
         tranId: number,  // example: 100000001
         amount: NumberString,  // example: "40.84624400"
         type: NumberString,  // example: "1"  // one of 1( from spot to USDT-Ⓜ), 2( from USDT-Ⓜ to spot), 3( from spot to COIN-Ⓜ), and 4( from COIN-Ⓜ to spot)
         timestamp: number,  // example: 1555056425000
         status: string  // example: "CONFIRMED"  //one of PENDING (pending to execution), CONFIRMED (successfully transfered), FAILED (execution failed, nothing happened to your account);
       }[],
     total: number  // example: 1
    }>;
  
  
  getFutureAccountTransactionHistoryList(...args : any) {
      return this._sendRequest("/sapi/v1/futures/transfer", "GET", "USER_DATA", false, args, ["asset", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "getFutureAccountTransactionHistoryList");
  }
  
  
  /** Get Future TickLevel Orderbook Historical Data Download Link (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-future-ticklevel-orderbook-historical-data-download-link-user_data}
   * 
   * EndPoint: /sapi/v1/futures/histDataLink
   * 
   * Weight(IP): 200
   * 
   * @param {string} symbol  -  symbol name, e.g. BTCUSDT or BTCUSD_PERP ｜
   * @param {ENUM} dataType  -  T_DEPTH for ticklevel orderbook data, S_DEPTH for orderbook snapshot data
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFutureTickLevelOrderbookHistoricalDataDownloadLink(symbol :string, dataType :ENUM, startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFutureTickLevelOrderbookHistoricalDataDownloadLink"]>;
  
  
  /** Get Future TickLevel Orderbook Historical Data Download Link (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-future-ticklevel-orderbook-historical-data-download-link-user_data}
   * 
   * EndPoint: /sapi/v1/futures/histDataLink
   * 
   * Weight(IP): 200
   * 
   * @param {string} options.symbol  -  symbol name, e.g. BTCUSDT or BTCUSD_PERP ｜
   * @param {ENUM} options.dataType  -  T_DEPTH for ticklevel orderbook data, S_DEPTH for orderbook snapshot data
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFutureTickLevelOrderbookHistoricalDataDownloadLink(options : { symbol :string, dataType :ENUM, startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     data: {
         day: string,  // example: "2023-06-30"
         url: string   // example: "https://bin-prod-user-rebate-bucket.s3.ap-northeast-1.amazonaws.com/future-data-symbol-update/2023-06-30/BTCUSDT_T_DEPTH_2023-06-30.tar.gz?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20230925T025710Z&X-Amz-SignedHeaders=host&X-Amz-Expires=86399&X-Amz-Credential=AKIAVL364M5ZNFZ74IPP%2F20230925%2Fap-northeast-1%2Fs3%2Faws4_request&X-Amz-Signature=5fffcb390d10f34d71615726f81f99e42d80a11532edeac77b858c51a88cbf59"
       }[]
    }>;
  
  
  getFutureTickLevelOrderbookHistoricalDataDownloadLink(...args : any) {
      return this._sendRequest("/sapi/v1/futures/histDataLink", "GET", "USER_DATA", false, args, ["symbol", "dataType", "startTime", "endTime", "recvWindow", "timestamp"], "getFutureTickLevelOrderbookHistoricalDataDownloadLink");
  }
  
  
  
  //***** Futures Algo Endpoints *****
  
  
  /** Volume Participation(VP) New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#volume-participation-vp-new-order-trade}
   * 
   * Send in a VP new order. 
   * Only support on USDⓈ-M Contracts.
   * 
   * EndPoint: /sapi/v1/algo/futures/newOrderVp
   * 
   * Weight(UID): 3000
   * 
   * @param {string} symbol  -  Trading symbol eg. BTCUSDT
   * @param {OrderSide} side  -  Trading side ( BUY or SELL )
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {DECIMAL} quantity  -  Quantity of base asset; The notional (quantity * mark price(base asset)) must be more than the equivalent of 1,000 USDT and less than the equivalent of 1,000,000 USDT
   * @param {ENUM} urgency  -  Represent the relative speed of the current execution; ENUM: LOW, MEDIUM, HIGH
   * @param {string} clientAlgoId  -  A unique id among Algo orders (length should be 32 characters)， If it is not sent, we will give default value
   * @param {boolean} reduceOnly  -  "true" or "false". Default "false"; Cannot be sent in Hedge Mode; Cannot be sent when you open a position
   * @param {DECIMAL} limitPrice  -  Limit price of the order; If it is not sent, will place order by market price by default
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  volumeParticipationVPNewOrder(symbol :string, side :OrderSide, positionSide :PositionSide|undefined, quantity :DECIMAL, urgency :ENUM, clientAlgoId? :string, reduceOnly? :boolean, limitPrice? :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["volumeParticipationVPNewOrder"]>;
  
  
  /** Volume Participation(VP) New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#volume-participation-vp-new-order-trade}
   * 
   * Send in a VP new order. 
   * Only support on USDⓈ-M Contracts.
   * 
   * EndPoint: /sapi/v1/algo/futures/newOrderVp
   * 
   * Weight(UID): 3000
   * 
   * @param {string} options.symbol  -  Trading symbol eg. BTCUSDT
   * @param {OrderSide} options.side  -  Trading side ( BUY or SELL )
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {DECIMAL} options.quantity  -  Quantity of base asset; The notional (quantity * mark price(base asset)) must be more than the equivalent of 1,000 USDT and less than the equivalent of 1,000,000 USDT
   * @param {ENUM} options.urgency  -  Represent the relative speed of the current execution; ENUM: LOW, MEDIUM, HIGH
   * @param {string} options.clientAlgoId  -  A unique id among Algo orders (length should be 32 characters)， If it is not sent, we will give default value
   * @param {boolean} options.reduceOnly  -  "true" or "false". Default "false"; Cannot be sent in Hedge Mode; Cannot be sent when you open a position
   * @param {DECIMAL} options.limitPrice  -  Limit price of the order; If it is not sent, will place order by market price by default
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  volumeParticipationVPNewOrder(options : { symbol :string, side :OrderSide, positionSide? :PositionSide, quantity :DECIMAL, urgency :ENUM, clientAlgoId? :string, reduceOnly? :boolean, limitPrice? :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     clientAlgoId: string,  // example: "00358ce6a268403398bd34eaa36dffe7"
     success: boolean,  // example: true
     code: number,  // example: 0
     msg: string  // example: "OK"
    }>;
  
  
  volumeParticipationVPNewOrder(...args : any) {
      return this._sendRequest("/sapi/v1/algo/futures/newOrderVp", "POST", "TRADE", false, args, ["symbol", "side", "positionSide", "quantity", "urgency", "clientAlgoId", "reduceOnly", "limitPrice", "recvWindow", "timestamp"], "volumeParticipationVPNewOrder");
  }
  
  
  /** Time-Weighted Average Price(Twap) New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#time-weighted-average-price-twap-new-order-trade}
   * 
   * Send in a Twap new order. 
   * Only support on USDⓈ-M Contracts.
   * 
   * EndPoint: /sapi/v1/algo/futures/newOrderTwap
   * 
   * Weight(UID): 3000
   * 
   * @param {string} symbol  -  Trading symbol eg. BTCUSDT
   * @param {OrderSide} side  -  Trading side ( BUY or SELL )
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {DECIMAL} quantity  -  Quantity of base asset; The notional (quantity * mark price(base asset)) must be more than the equivalent of 1,000 USDT and less than the equivalent of 1,000,000 USDT
   * @param {LONG} duration  -  Duration for TWAP orders in seconds. [300, 86400]
   * @param {string} clientAlgoId  -  A unique id among Algo orders (length should be 32 characters)， If it is not sent, we will give default value
   * @param {boolean} reduceOnly  -  "true" or "false". Default "false"; Cannot be sent in Hedge Mode; Cannot be sent when you open a position
   * @param {DECIMAL} limitPrice  -  Limit price of the order; If it is not sent, will place order by market price by default
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  timeWeightedAveragePriceTwapNewOrder(symbol :string, side :OrderSide, positionSide :PositionSide|undefined, quantity :DECIMAL, duration :LONG, clientAlgoId? :string, reduceOnly? :boolean, limitPrice? :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["timeWeightedAveragePriceTwapNewOrder"]>;
  
  
  /** Time-Weighted Average Price(Twap) New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#time-weighted-average-price-twap-new-order-trade}
   * 
   * Send in a Twap new order. 
   * Only support on USDⓈ-M Contracts.
   * 
   * EndPoint: /sapi/v1/algo/futures/newOrderTwap
   * 
   * Weight(UID): 3000
   * 
   * @param {string} options.symbol  -  Trading symbol eg. BTCUSDT
   * @param {OrderSide} options.side  -  Trading side ( BUY or SELL )
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {DECIMAL} options.quantity  -  Quantity of base asset; The notional (quantity * mark price(base asset)) must be more than the equivalent of 1,000 USDT and less than the equivalent of 1,000,000 USDT
   * @param {LONG} options.duration  -  Duration for TWAP orders in seconds. [300, 86400]
   * @param {string} options.clientAlgoId  -  A unique id among Algo orders (length should be 32 characters)， If it is not sent, we will give default value
   * @param {boolean} options.reduceOnly  -  "true" or "false". Default "false"; Cannot be sent in Hedge Mode; Cannot be sent when you open a position
   * @param {DECIMAL} options.limitPrice  -  Limit price of the order; If it is not sent, will place order by market price by default
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  timeWeightedAveragePriceTwapNewOrder(options : { symbol :string, side :OrderSide, positionSide? :PositionSide, quantity :DECIMAL, duration :LONG, clientAlgoId? :string, reduceOnly? :boolean, limitPrice? :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     clientAlgoId: string,  // example: "65ce1630101a480b85915d7e11fd5078"
     success: boolean,  // example: true
     code: number,  // example: 0
     msg: string  // example: "OK"
    }>;
  
  
  timeWeightedAveragePriceTwapNewOrder(...args : any) {
      return this._sendRequest("/sapi/v1/algo/futures/newOrderTwap", "POST", "TRADE", false, args, ["symbol", "side", "positionSide", "quantity", "duration", "clientAlgoId", "reduceOnly", "limitPrice", "recvWindow", "timestamp"], "timeWeightedAveragePriceTwapNewOrder");
  }
  
  
  /** Cancel Algo Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-algo-order-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /sapi/v1/algo/futures/order
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} algoId  -  eg. 14511
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  cancelAlgoOrderFutures(algoId :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["cancelAlgoOrderFutures"]>;
  
  
  /** Cancel Algo Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-algo-order-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /sapi/v1/algo/futures/order
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.algoId  -  eg. 14511
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  cancelAlgoOrderFutures(options : { algoId :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     algoId: number,  // example: 14511
     success: boolean,  // example: true
     code: number,  // example: 0
     msg: string  // example: "OK"
    }>;
  
  
  cancelAlgoOrderFutures(...args : any) {
      return this._sendRequest("/sapi/v1/algo/futures/order", "DELETE", "TRADE", false, args, ["algoId", "recvWindow", "timestamp"], "cancelAlgoOrderFutures");
  }
  
  
  /** Query Current Algo Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-current-algo-open-orders-user_data}
   * 
   * EndPoint: /sapi/v1/algo/futures/openOrders
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryCurrentAlgoOpenOrdersFutures(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryCurrentAlgoOpenOrdersFutures"]>;
  
  
  /** Query Current Algo Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-current-algo-open-orders-user_data}
   * 
   * EndPoint: /sapi/v1/algo/futures/openOrders
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryCurrentAlgoOpenOrdersFutures(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 1
     orders: {
         algoId: number,  // example: 14517
         symbol: string,  // example: "ETHUSDT"
         side: OrderSide,  // example: "SELL"
         positionSide: PositionSide,  // example: "SHORT"
         totalQty: NumberString,  // example: "5.000"
         executedQty: NumberString,  // example: "0.000"
         executedAmt: NumberString,  // example: "0.00000000"
         avgPrice: NumberString,  // example: "0.00"
         clientAlgoId: string,  // example: "d7096549481642f8a0bb69e9e2e31f2e"
         bookTime: number,  // example: 1649756817004
         endTime: number,  // example: 0
         algoStatus: string,  // example: "WORKING"
         algoType: string,  // example: "VP"
         urgency: string  // example: "LOW"
       }[]
    }>;
  
  
  queryCurrentAlgoOpenOrdersFutures(...args : any) {
      return this._sendRequest("/sapi/v1/algo/futures/openOrders", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryCurrentAlgoOpenOrdersFutures");
  }
  
  
  /** Query Historical Algo Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-historical-algo-orders-user_data}
   * 
   * EndPoint: /sapi/v1/algo/futures/historicalOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol  -  Trading symbol eg. BTCUSDT
   * @param {OrderSide} side  -  BUY or SELL
   * @param {LONG} startTime  -  in milliseconds  eg.1641522717552
   * @param {LONG} endTime  -  in milliseconds  eg.1641522526562
   * @param {INT} page  -  Default is 1
   * @param {INT} pageSize  -  MIN 1, MAX 100; Default 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryHistoricalAlgoOrdersFutures(symbol? :string, side? :OrderSide, startTime? :LONG, endTime? :LONG, page? :INT, pageSize? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryHistoricalAlgoOrdersFutures"]>;
  
  
  /** Query Historical Algo Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-historical-algo-orders-user_data}
   * 
   * EndPoint: /sapi/v1/algo/futures/historicalOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol  -  Trading symbol eg. BTCUSDT
   * @param {OrderSide} options.side  -  BUY or SELL
   * @param {LONG} options.startTime  -  in milliseconds  eg.1641522717552
   * @param {LONG} options.endTime  -  in milliseconds  eg.1641522526562
   * @param {INT} options.page  -  Default is 1
   * @param {INT} options.pageSize  -  MIN 1, MAX 100; Default 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryHistoricalAlgoOrdersFutures(options? : { symbol? :string, side? :OrderSide, startTime? :LONG, endTime? :LONG, page? :INT, pageSize? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 1
     orders: {
         algoId: number,  // example: 14518
         symbol: string,  // example: "BNBUSDT"
         side: OrderSide,  // example: "BUY"
         positionSide: PositionSide,  // example: "BOTH"
         totalQty: NumberString,  // example: "100.00"
         executedQty: NumberString,  // example: "0.00"
         executedAmt: NumberString,  // example: "0.00000000"
         avgPrice: NumberString,  // example: "0.000"
         clientAlgoId: string,  // example: "acacab56b3c44bef9f6a8f8ebd2a8408"
         bookTime: number,  // example: 1649757019503
         endTime: number,  // example: 1649757088101
         algoStatus: string,  // example: "CANCELLED"
         algoType: string,  // example: "VP"
         urgency: string  // example: "LOW"
       }[]
    }>;
  
  
  queryHistoricalAlgoOrdersFutures(...args : any) {
      return this._sendRequest("/sapi/v1/algo/futures/historicalOrders", "GET", "USER_DATA", false, args, ["symbol", "side", "startTime", "endTime", "page", "pageSize", "recvWindow", "timestamp"], "queryHistoricalAlgoOrdersFutures");
  }
  
  
  /** Query Sub Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-orders-user_data}
   * 
   * Get respective sub orders for a specified algoId
   * 
   * EndPoint: /sapi/v1/algo/futures/subOrders
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} algoId
   * @param {INT} page  -  Default is 1
   * @param {INT} pageSize  -  MIN 1, MAX 100; Default 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  querySubOrdersFutures(algoId :LONG, page? :INT, pageSize? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["querySubOrdersFutures"]>;
  
  
  /** Query Sub Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-orders-user_data}
   * 
   * Get respective sub orders for a specified algoId
   * 
   * EndPoint: /sapi/v1/algo/futures/subOrders
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.algoId
   * @param {INT} options.page  -  Default is 1
   * @param {INT} options.pageSize  -  MIN 1, MAX 100; Default 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  querySubOrdersFutures(options : { algoId :LONG, page? :INT, pageSize? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 1
     executedQty: NumberString,  // example: "1.000"
     executedAmt: NumberString,  // example: "3229.44000000"
     subOrders: {
         algoId: number,  // example: 13723
         orderId: number,  // example: 8389765519993909000
         orderStatus: string,  // example: "FILLED"
         executedQty: NumberString,  // example: "1.000"
         executedAmt: NumberString,  // example: "3229.44000000"
         feeAmt: NumberString,  // example: "-1.61471999"
         feeAsset: string,  // example: "USDT"
         bookTime: number,  // example: 1649319001964
         avgPrice: NumberString,  // example: "3229.44"
         side: OrderSide,  // example: "SELL"
         symbol: string,  // example: "ETHUSDT"
         subId: number,  // example: 1
         timeInForce: string,  // example: "IMMEDIATE_OR_CANCEL"
         origQty: NumberString  // example: "1.000"
       }[]
    }>;
  
  
  querySubOrdersFutures(...args : any) {
      return this._sendRequest("/sapi/v1/algo/futures/subOrders", "GET", "USER_DATA", false, args, ["algoId", "page", "pageSize", "recvWindow", "timestamp"], "querySubOrdersFutures");
  }
  
  
  
  //***** Spot Algo Endpoints *****
  
  
  /** Time-Weighted Average Price (Twap) New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#time-weighted-average-price-twap-new-order-trade-2}
   * 
   * Place a new spot TWAP order with Algo service. 
   * 
   * EndPoint: /sapi/v1/algo/spot/newOrderTwap
   * 
   * Weight(UID): 3000
   * 
   * @param {string} symbol  -  Trading symbol eg. BTCUSDT
   * @param {OrderSide} side  -  Trading side ( BUY or SELL )
   * @param {DECIMAL} quantity  -  Quantity of base asset; The notional (quantity * last price(base asset)) must be more than the equivalent of 1,000 USDT and less than the equivalent of 100,000 USDT
   * @param {LONG} duration  -  Duration for TWAP orders in seconds. [300, 86400]
   * @param {string} clientAlgoId  -  A unique id among Algo orders (length should be 32 characters)， If it is not sent, we will give default value
   * @param {DECIMAL} limitPrice  -  Limit price of the order; If it is not sent, will place order by market price by default
   * @param {ENUM} stpMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  timeWeightedAveragePriceNewOrder(symbol :string, side :OrderSide, quantity :DECIMAL, duration :LONG, clientAlgoId? :string, limitPrice? :DECIMAL, stpMode? :ENUM, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["timeWeightedAveragePriceNewOrder"]>;
  
  
  /** Time-Weighted Average Price (Twap) New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#time-weighted-average-price-twap-new-order-trade-2}
   * 
   * Place a new spot TWAP order with Algo service. 
   * 
   * EndPoint: /sapi/v1/algo/spot/newOrderTwap
   * 
   * Weight(UID): 3000
   * 
   * @param {string} options.symbol  -  Trading symbol eg. BTCUSDT
   * @param {OrderSide} options.side  -  Trading side ( BUY or SELL )
   * @param {DECIMAL} options.quantity  -  Quantity of base asset; The notional (quantity * last price(base asset)) must be more than the equivalent of 1,000 USDT and less than the equivalent of 100,000 USDT
   * @param {LONG} options.duration  -  Duration for TWAP orders in seconds. [300, 86400]
   * @param {string} options.clientAlgoId  -  A unique id among Algo orders (length should be 32 characters)， If it is not sent, we will give default value
   * @param {DECIMAL} options.limitPrice  -  Limit price of the order; If it is not sent, will place order by market price by default
   * @param {ENUM} options.stpMode  -  The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  timeWeightedAveragePriceNewOrder(options : { symbol :string, side :OrderSide, quantity :DECIMAL, duration :LONG, clientAlgoId? :string, limitPrice? :DECIMAL, stpMode? :ENUM, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     clientAlgoId: string,  // example: "65ce1630101a480b85915d7e11fd5078"
     success: boolean,  // example: true
     code: number,  // example: 0
     msg: string  // example: "OK"
    }>;
  
  
  timeWeightedAveragePriceNewOrder(...args : any) {
      return this._sendRequest("/sapi/v1/algo/spot/newOrderTwap", "POST", "TRADE", false, args, ["symbol", "side", "quantity", "duration", "clientAlgoId", "limitPrice", "stpMode", "recvWindow", "timestamp"], "timeWeightedAveragePriceNewOrder");
  }
  
  
  /** Cancel Algo Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-algo-order-trade-2}
   * 
   * Cancel an open TWAP order
   * 
   * EndPoint: /sapi/v1/algo/spot/order
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} algoId  -  eg. 14511
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  cancelAlgoOrder(algoId :LONG, recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["cancelAlgoOrder"]>;
  
  
  /** Cancel Algo Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-algo-order-trade-2}
   * 
   * Cancel an open TWAP order
   * 
   * EndPoint: /sapi/v1/algo/spot/order
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.algoId  -  eg. 14511
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  cancelAlgoOrder(options : { algoId :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     algoId: number,  // example: 14511
     success: boolean,  // example: true
     code: number,  // example: 0
     msg: string  // example: "OK"
    }>;
  
  
  cancelAlgoOrder(...args : any) {
      return this._sendRequest("/sapi/v1/algo/spot/order", "DELETE", "TRADE", false, args, ["algoId", "recvWindow", "timestamp"], "cancelAlgoOrder");
  }
  
  
  /** Query Current Algo Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-current-algo-open-orders-user_data-2}
   * 
   * Get all open SPOT TWAP orders
   * 
   * EndPoint: /sapi/v1/algo/spot/openOrders
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryCurrentAlgoOpenOrders(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryCurrentAlgoOpenOrders"]>;
  
  
  /** Query Current Algo Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-current-algo-open-orders-user_data-2}
   * 
   * Get all open SPOT TWAP orders
   * 
   * EndPoint: /sapi/v1/algo/spot/openOrders
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryCurrentAlgoOpenOrders(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 1
     orders: {
         algoId: number,  // example: 14517
         symbol: string,  // example: "ETHUSDT"
         side: OrderSide,  // example: "SELL"
         totalQty: NumberString,  // example: "5.000"
         executedQty: NumberString,  // example: "0.000"
         executedAmt: NumberString,  // example: "0.00000000"
         avgPrice: NumberString,  // example: "0.00"
         clientAlgoId: string,  // example: "d7096549481642f8a0bb69e9e2e31f2e"
         bookTime: number,  // example: 1649756817004
         endTime: number,  // example: 0
         algoStatus: string,  // example: "WORKING"
         algoType: string,  // example: "TWAP"
         urgency: string  // example: "LOW"
       }[]
    }>;
  
  
  queryCurrentAlgoOpenOrders(...args : any) {
      return this._sendRequest("/sapi/v1/algo/spot/openOrders", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryCurrentAlgoOpenOrders");
  }
  
  
  /** Query Historical Algo Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-historical-algo-orders-user_data-2}
   * 
   * Get all historical SPOT TWAP orders
   * 
   * EndPoint: /sapi/v1/algo/spot/historicalOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol  -  Trading symbol eg. BTCUSDT
   * @param {OrderSide} side  -  BUY or SELL
   * @param {LONG} startTime  -  in milliseconds  eg.1641522717552
   * @param {LONG} endTime  -  in milliseconds  eg.1641522526562
   * @param {INT} page  -  Default is 1
   * @param {INT} pageSize  -  MIN 1, MAX 100; Default 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryHistoricalAlgoOrders(symbol? :string, side? :OrderSide, startTime? :LONG, endTime? :LONG, page? :INT, pageSize? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryHistoricalAlgoOrders"]>;
  
  
  /** Query Historical Algo Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-historical-algo-orders-user_data-2}
   * 
   * Get all historical SPOT TWAP orders
   * 
   * EndPoint: /sapi/v1/algo/spot/historicalOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol  -  Trading symbol eg. BTCUSDT
   * @param {OrderSide} options.side  -  BUY or SELL
   * @param {LONG} options.startTime  -  in milliseconds  eg.1641522717552
   * @param {LONG} options.endTime  -  in milliseconds  eg.1641522526562
   * @param {INT} options.page  -  Default is 1
   * @param {INT} options.pageSize  -  MIN 1, MAX 100; Default 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryHistoricalAlgoOrders(options? : { symbol? :string, side? :OrderSide, startTime? :LONG, endTime? :LONG, page? :INT, pageSize? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 1
     orders: {
         algoId: number,  // example: 14518
         symbol: string,  // example: "BNBUSDT"
         side: OrderSide,  // example: "BUY"
         totalQty: NumberString,  // example: "100.00"
         executedQty: NumberString,  // example: "0.00"
         executedAmt: NumberString,  // example: "0.00000000"
         avgPrice: NumberString,  // example: "0.000"
         clientAlgoId: string,  // example: "acacab56b3c44bef9f6a8f8ebd2a8408"
         bookTime: number,  // example: 1649757019503
         endTime: number,  // example: 1649757088101
         algoStatus: string,  // example: "CANCELLED"
         algoType: string,  // example: "VP"
         urgency: string  // example: "LOW"
       }[]
    }>;
  
  
  queryHistoricalAlgoOrders(...args : any) {
      return this._sendRequest("/sapi/v1/algo/spot/historicalOrders", "GET", "USER_DATA", false, args, ["symbol", "side", "startTime", "endTime", "page", "pageSize", "recvWindow", "timestamp"], "queryHistoricalAlgoOrders");
  }
  
  
  /** Query Sub Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-orders-user_data-2}
   * 
   * Get respective sub orders for a specified algoId
   * 
   * EndPoint: /sapi/v1/algo/spot/subOrders
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} algoId
   * @param {INT} page  -  Default is 1
   * @param {INT} pageSize  -  MIN 1, MAX 100; Default 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  querySubOrders(algoId :LONG, page? :INT, pageSize? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["querySubOrders"]>;
  
  
  /** Query Sub Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-sub-orders-user_data-2}
   * 
   * Get respective sub orders for a specified algoId
   * 
   * EndPoint: /sapi/v1/algo/spot/subOrders
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.algoId
   * @param {INT} options.page  -  Default is 1
   * @param {INT} options.pageSize  -  MIN 1, MAX 100; Default 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  querySubOrders(options : { algoId :LONG, page? :INT, pageSize? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 1
     executedQty: NumberString,  // example: "1.000"
     executedAmt: NumberString,  // example: "3229.44000000"
     subOrders: {
         algoId: number,  // example: 13723
         orderId: number,  // example: 8389765519993909000
         orderStatus: string,  // example: "FILLED"
         executedQty: NumberString,  // example: "1.000"
         executedAmt: NumberString,  // example: "3229.44000000"
         feeAmt: NumberString,  // example: "-1.61471999"
         feeAsset: string,  // example: "USDT"
         bookTime: number,  // example: 1649319001964
         avgPrice: NumberString,  // example: "3229.44"
         side: OrderSide,  // example: "SELL"
         symbol: string,  // example: "ETHUSDT"
         subId: number,  // example: 1
         timeInForce: string,  // example: "IMMEDIATE_OR_CANCEL"
         origQty: NumberString  // example: "1.000"
       }[]
    }>;
  
  
  querySubOrders(...args : any) {
      return this._sendRequest("/sapi/v1/algo/spot/subOrders", "GET", "USER_DATA", false, args, ["algoId", "page", "pageSize", "recvWindow", "timestamp"], "querySubOrders");
  }
  
  
  
  //***** Portfolio Margin Pro Endpoints *****
  
  
  /** Get Portfolio Margin Pro Account Info (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-portfolio-margin-pro-account-info-user_data}
   * 
   * EndPoint: /sapi/v1/portfolio/account
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getPortfolioMarginProAccountInfo(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getPortfolioMarginProAccountInfo"]>;
  
  
  /** Get Portfolio Margin Pro Account Info (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-portfolio-margin-pro-account-info-user_data}
   * 
   * EndPoint: /sapi/v1/portfolio/account
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getPortfolioMarginProAccountInfo(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     uniMMR: NumberString,  // example: "5167.92171923"  // Portfolio Margin Pro account maintenance margin rate
     accountEquity: NumberString,  // example: "122607.35137903"  // Account equity, unit:USD
     actualEquity: NumberString,  // example: "142607.35137903"  // Actual equity, unit:USD
     accountMaintMargin: NumberString,  // example: "23.72469206"  // Portfolio Margin Pro account maintenance margin, unit:USD
     accountStatus: string,  // example: "NORMAL"  // Portfolio Margin Pro account status:"NORMAL", "MARGIN_CALL", "SUPPLY_MARGIN", "REDUCE_ONLY", "ACTIVE_LIQUIDATION", "FORCE_LIQUIDATION", "BANKRUPTED"
     accountType: string  // example: "PM_1"  //PM_1 for PM Pro, PM_2 for PM ,PM_3 for PM Pro(SPAN)
    }>;
  
  
  getPortfolioMarginProAccountInfo(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/account", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "getPortfolioMarginProAccountInfo");
  }
  
  
  /** Portfolio Margin Pro Collateral Rate (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#portfolio-margin-pro-collateral-rate-market_data}
   * 
   * Portfolio Margin Pro Collateral Rate
   * 
   * EndPoint: /sapi/v1/portfolio/collateralRate
   * 
   * Weight(IP): 50
   * 
   */
  portfolioMarginProCollateralRate() : Promise<{
       asset: string,  // example: "USDC"
       collateralRate: NumberString  // example: "1.0000"
     }[]> {
      return this._sendRequest("/sapi/v1/portfolio/collateralRate", "GET", "MARKET_DATA", false, [], [], "portfolioMarginProCollateralRate");
  }
  
  
  /** Query Portfolio Margin Pro Bankruptcy Loan Amount (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-portfolio-margin-pro-bankruptcy-loan-amount-user_data}
   * 
   * Query Portfolio Margin Pro Bankruptcy Loan Amount
   * 
   * EndPoint: /sapi/v1/portfolio/pmLoan
   * 
   * Weight(UID): 500
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryPortfolioMarginProBankruptcyLoanAmount(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryPortfolioMarginProBankruptcyLoanAmount"]>;
  
  
  /** Query Portfolio Margin Pro Bankruptcy Loan Amount (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-portfolio-margin-pro-bankruptcy-loan-amount-user_data}
   * 
   * Query Portfolio Margin Pro Bankruptcy Loan Amount
   * 
   * EndPoint: /sapi/v1/portfolio/pmLoan
   * 
   * Weight(UID): 500
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryPortfolioMarginProBankruptcyLoanAmount(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     asset: string,  // example: "BUSD"
     amount: NumberString  // example: "579.45"  // portfolio margin bankruptcy loan amount in BUSD
    }>;
  
  
  queryPortfolioMarginProBankruptcyLoanAmount(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/pmLoan", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryPortfolioMarginProBankruptcyLoanAmount");
  }
  
  
  /** Portfolio Margin Pro Bankruptcy Loan Repay
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#portfolio-margin-pro-bankruptcy-loan-repay}
   * 
   * Repay Portfolio Margin Pro Bankruptcy Loan
   * 
   * EndPoint: /sapi/v1/portfolio/repay
   * 
   * Weight(UID): 3000
   * 
   * @param {string} from  -  SPOT or MARGIN，default SPOT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  portfolioMarginProBankruptcyLoanRepay(from :string|undefined, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["portfolioMarginProBankruptcyLoanRepay"]>;
  
  
  /** Portfolio Margin Pro Bankruptcy Loan Repay
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#portfolio-margin-pro-bankruptcy-loan-repay}
   * 
   * Repay Portfolio Margin Pro Bankruptcy Loan
   * 
   * EndPoint: /sapi/v1/portfolio/repay
   * 
   * Weight(UID): 3000
   * 
   * @param {string} options.from  -  SPOT or MARGIN，default SPOT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  portfolioMarginProBankruptcyLoanRepay(options : { from? :string, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     tranId: number  // example: 58203331886213500
    }>;
  
  
  portfolioMarginProBankruptcyLoanRepay(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/repay", "POST", "", false, args, ["from", "recvWindow", "timestamp"], "portfolioMarginProBankruptcyLoanRepay");
  }
  
  
  /** Query Portfolio Margin Pro Negative Balance Interest History(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-portfolio-margin-pro-negative-balance-interest-history-user_data}
   * 
   * Query interest history of negative balance for portfolio margin.
   * 
   * EndPoint: /sapi/v1/portfolio/interest-history
   * 
   * Weight(IP): 50
   * 
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} size  -  Default:10 Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryPortfolioMarginProNegativeBalanceInterestHistory(asset? :string, startTime? :LONG, endTime? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryPortfolioMarginProNegativeBalanceInterestHistory"]>;
  
  
  /** Query Portfolio Margin Pro Negative Balance Interest History(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-portfolio-margin-pro-negative-balance-interest-history-user_data}
   * 
   * Query interest history of negative balance for portfolio margin.
   * 
   * EndPoint: /sapi/v1/portfolio/interest-history
   * 
   * Weight(IP): 50
   * 
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryPortfolioMarginProNegativeBalanceInterestHistory(options? : { asset? :string, startTime? :LONG, endTime? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       asset: string,  // example: "USDT"
       interest: NumberString,  // example: "24.4440"  //interest amount
       interestAccruedTime: number,  // example: 1670227200000
       interestRate: NumberString,  // example: "0.0001164"  //daily interest rate
       principal: NumberString  // example: "210000"
     }[]>;
  
  
  queryPortfolioMarginProNegativeBalanceInterestHistory(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/interest-history", "GET", "USER_DATA", false, args, ["asset", "startTime", "endTime", "size", "recvWindow", "timestamp"], "queryPortfolioMarginProNegativeBalanceInterestHistory");
  }
  
  
  /** Query Portfolio Margin Asset Index Price (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-portfolio-margin-asset-index-price-market_data}
   * 
   * Query Portfolio Margin Asset Index Price
   * 
   * EndPoint: /sapi/v1/portfolio/asset-index-price
   * 
   * Weight(IP): 1 if send asset or 50 if not send asset
   * 
   * @param {string} asset
   */
  queryPortfolioMarginAssetIndexPrice(asset? :string)
  : ReturnType<MyBinanceClient["queryPortfolioMarginAssetIndexPrice"]>;
  
  
  /** Query Portfolio Margin Asset Index Price (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-portfolio-margin-asset-index-price-market_data}
   * 
   * Query Portfolio Margin Asset Index Price
   * 
   * EndPoint: /sapi/v1/portfolio/asset-index-price
   * 
   * Weight(IP): 1 if send asset or 50 if not send asset
   * 
   * @param {string} options.asset
   */
  queryPortfolioMarginAssetIndexPrice(options? : { asset? :string })
  : Promise<{
       asset: string,  // example: "BTC"
       assetIndexPrice: NumberString,  // example: "28251.9136906"  // in USD
       time: number  // example: 1683518338121
     }[]>;
  
  
  queryPortfolioMarginAssetIndexPrice(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/asset-index-price", "GET", "MARKET_DATA", false, args, ["asset"], "queryPortfolioMarginAssetIndexPrice");
  }
  
  
  /** Fund Auto-collection (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fund-auto-collection-user_data}
   * 
   * Transfers all assets from Futures Account to Margin account
   * 
   * EndPoint: /sapi/v1/portfolio/auto-collection
   * 
   * Weight(IP): 1500
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fundAutoCollection(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["fundAutoCollection"]>;
  
  
  /** Fund Auto-collection (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fund-auto-collection-user_data}
   * 
   * Transfers all assets from Futures Account to Margin account
   * 
   * EndPoint: /sapi/v1/portfolio/auto-collection
   * 
   * Weight(IP): 1500
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fundAutoCollection(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     msg: string  // example: "success"
    }>;
  
  
  fundAutoCollection(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/auto-collection", "POST", "USER_DATA", false, args, ["recvWindow", "timestamp"], "fundAutoCollection");
  }
  
  
  /** Fund Collection by Asset(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fund-collection-by-asset-user_data}
   * 
   * Transfers specific asset from Futures Account to Margin account
   * 
   * EndPoint: /sapi/v1/portfolio/asset-collection
   * 
   * Weight(IP): 60
   * 
   * @param {string} asset
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fundCollectionByAsset(asset :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fundCollectionByAsset"]>;
  
  
  /** Fund Collection by Asset(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fund-collection-by-asset-user_data}
   * 
   * Transfers specific asset from Futures Account to Margin account
   * 
   * EndPoint: /sapi/v1/portfolio/asset-collection
   * 
   * Weight(IP): 60
   * 
   * @param {string} options.asset
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fundCollectionByAsset(options : { asset :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     msg: string  // example: "success"
    }>;
  
  
  fundCollectionByAsset(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/asset-collection", "POST", "USER_DATA", false, args, ["asset", "recvWindow", "timestamp"], "fundCollectionByAsset");
  }
  
  
  /** BNB transfer(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#bnb-transfer-user_data}
   * 
   * BNB transfer can be between Margin Account and USDM Account
   * 
   * EndPoint: /sapi/v1/portfolio/bnb-transfer
   * 
   * Weight(IP): 1500
   * 
   * @param {DECIMAL} amount
   * @param {"TO_UM"|"FROM_UM"} transferSide  -  "TO_UM","FROM_UM"
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  bnBTransfer(amount :DECIMAL, transferSide :"TO_UM"|"FROM_UM", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["bnBTransfer"]>;
  
  
  /** BNB transfer(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#bnb-transfer-user_data}
   * 
   * BNB transfer can be between Margin Account and USDM Account
   * 
   * EndPoint: /sapi/v1/portfolio/bnb-transfer
   * 
   * Weight(IP): 1500
   * 
   * @param {DECIMAL} options.amount
   * @param {"TO_UM"|"FROM_UM"} options.transferSide  -  "TO_UM","FROM_UM"
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  bnBTransfer(options : { amount :DECIMAL, transferSide :"TO_UM"|"FROM_UM", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     tranId: number  // example: 100000001
    }>;
  
  
  bnBTransfer(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/bnb-transfer", "POST", "USER_DATA", false, args, ["amount", "transferSide", "recvWindow", "timestamp"], "bnBTransfer");
  }
  
  
  /** Change Auto-repay-futures Status (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#change-auto-repay-futures-status-trade}
   * 
   * Change Auto-repay-futures Status
   * 
   * EndPoint: /sapi/v1/portfolio/repay-futures-switch
   * 
   * Weight(IP): 1500
   * 
   * @param {string} autoRepay  -  Default: true; false for turn off the auto-repay futures negative balance function
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  changeAutoRepayFuturesStatus(autoRepay :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["changeAutoRepayFuturesStatus"]>;
  
  
  /** Change Auto-repay-futures Status (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#change-auto-repay-futures-status-trade}
   * 
   * Change Auto-repay-futures Status
   * 
   * EndPoint: /sapi/v1/portfolio/repay-futures-switch
   * 
   * Weight(IP): 1500
   * 
   * @param {string} options.autoRepay  -  Default: true; false for turn off the auto-repay futures negative balance function
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  changeAutoRepayFuturesStatus(options : { autoRepay :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     msg: string  // example: "success"
    }>;
  
  
  changeAutoRepayFuturesStatus(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/repay-futures-switch", "POST", "TRADE", false, args, ["autoRepay", "recvWindow", "timestamp"], "changeAutoRepayFuturesStatus");
  }
  
  
  /** Get Auto-repay-futures Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-auto-repay-futures-status-user_data}
   * 
   * Query Auto-repay-futures Status
   * 
   * EndPoint: /sapi/v1/portfolio/repay-futures-switch
   * 
   * Weight(IP): 30
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getAutoRepayFuturesStatus(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getAutoRepayFuturesStatus"]>;
  
  
  /** Get Auto-repay-futures Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-auto-repay-futures-status-user_data}
   * 
   * Query Auto-repay-futures Status
   * 
   * EndPoint: /sapi/v1/portfolio/repay-futures-switch
   * 
   * Weight(IP): 30
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getAutoRepayFuturesStatus(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     autoRepay: boolean  // example: true  //  "true" for turn on the auto-repay futures; "false" for turn off the auto-repay futures
    }>;
  
  
  getAutoRepayFuturesStatus(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/repay-futures-switch", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "getAutoRepayFuturesStatus");
  }
  
  
  /** Repay futures Negative Balance (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#repay-futures-negative-balance-user_data}
   * 
   * Repay futures Negative Balance
   * 
   * EndPoint: /sapi/v1/portfolio/repay-futures-negative-balance
   * 
   * Weight(IP): 1500
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  repayFuturesNegativeBalance(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["repayFuturesNegativeBalance"]>;
  
  
  /** Repay futures Negative Balance (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#repay-futures-negative-balance-user_data}
   * 
   * Repay futures Negative Balance
   * 
   * EndPoint: /sapi/v1/portfolio/repay-futures-negative-balance
   * 
   * Weight(IP): 1500
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  repayFuturesNegativeBalance(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     msg: string  // example: "success"
    }>;
  
  
  repayFuturesNegativeBalance(...args : any) {
      return this._sendRequest("/sapi/v1/portfolio/repay-futures-negative-balance", "POST", "USER_DATA", false, args, ["recvWindow", "timestamp"], "repayFuturesNegativeBalance");
  }
  
  
  /** Get Portfolio Margin Asset Leverage (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-portfolio-margin-asset-leverage-user_data}
   * 
   * 50
   * 
   * EndPoint: /sapi/v1/portfolio/margin-asset-leverage
   * 
   * Weight(IP): 50
   * 
   */
  getPortfolioMarginAssetLeverage() : Promise<{
       asset: string,  // example: "USDC"
       leverage: number  // example: 10
     }[]> {
      return this._sendRequest("/sapi/v1/portfolio/margin-asset-leverage", "GET", "USER_DATA", false, [], [], "getPortfolioMarginAssetLeverage");
  }
  
  
  
  //***** Fiat Endpoints *****
  
  
  /** Get Fiat Deposit/Withdraw History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-fiat-deposit-withdraw-history-user_data}
   * 
   * EndPoint: /sapi/v1/fiat/orders
   * 
   * Weight(UID): 90000
   * 
   * @param {string} transactionType  -  0-deposit,1-withdraw
   * @param {LONG} beginTime
   * @param {LONG} endTime
   * @param {INT} page  -  default 1
   * @param {INT} rows  -  default 100, max 500
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFiatDepositWithdrawHistory(transactionType :string, beginTime? :LONG, endTime? :LONG, page? :INT, rows? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFiatDepositWithdrawHistory"]>;
  
  
  /** Get Fiat Deposit/Withdraw History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-fiat-deposit-withdraw-history-user_data}
   * 
   * EndPoint: /sapi/v1/fiat/orders
   * 
   * Weight(UID): 90000
   * 
   * @param {string} options.transactionType  -  0-deposit,1-withdraw
   * @param {LONG} options.beginTime
   * @param {LONG} options.endTime
   * @param {INT} options.page  -  default 1
   * @param {INT} options.rows  -  default 100, max 500
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFiatDepositWithdrawHistory(options : { transactionType :string, beginTime? :LONG, endTime? :LONG, page? :INT, rows? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
         orderNo: string,  // example: "7d76d611-0568-4f43-afb6-24cac7767365"
         fiatCurrency: string,  // example: "BRL"
         indicatedAmount: NumberString,  // example: "10.00"
         amount: NumberString,  // example: "10.00"
         totalFee: NumberString,  // example: "0.00"  // Trade fee
         method: string,  // example: "BankAccount"  // Trade method
         status: string,  // example: "Expired"  // Processing, Failed, Successful, Finished, Refunding, Refunded, Refund Failed, Order Partial credit Stopped
         createTime: number,  // example: 1626144956000
         updateTime: number  // example: 1626400907000
       }[],
     total: number,  // example: 1
     success: boolean  // example: true
    }>;
  
  
  getFiatDepositWithdrawHistory(...args : any) {
      return this._sendRequest("/sapi/v1/fiat/orders", "GET", "USER_DATA", false, args, ["transactionType", "beginTime", "endTime", "page", "rows", "recvWindow", "timestamp"], "getFiatDepositWithdrawHistory");
  }
  
  
  /** Get Fiat Payments History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-fiat-payments-history-user_data}
   * 
   * EndPoint: /sapi/v1/fiat/payments
   * 
   * Weight(IP): 1
   * 
   * @param {string} transactionType  -  0-buy,1-sell
   * @param {LONG} beginTime
   * @param {LONG} endTime
   * @param {INT} page  -  default 1
   * @param {INT} rows  -  default 100, max 500
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFiatPaymentsHistory(transactionType :string, beginTime? :LONG, endTime? :LONG, page? :INT, rows? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFiatPaymentsHistory"]>;
  
  
  /** Get Fiat Payments History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-fiat-payments-history-user_data}
   * 
   * EndPoint: /sapi/v1/fiat/payments
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.transactionType  -  0-buy,1-sell
   * @param {LONG} options.beginTime
   * @param {LONG} options.endTime
   * @param {INT} options.page  -  default 1
   * @param {INT} options.rows  -  default 100, max 500
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFiatPaymentsHistory(options : { transactionType :string, beginTime? :LONG, endTime? :LONG, page? :INT, rows? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
         orderNo: string,  // example: "353fca443f06466db0c4dc89f94f027a"
         sourceAmount: NumberString,  // example: "20.0"  // Fiat trade amount
         fiatCurrency: string,  // example: "EUR"  // Fiat token
         obtainAmount: NumberString,  // example: "4.462"  // Crypto trade amount
         cryptoCurrency: string,  // example: "LUNA"  // Crypto token
         totalFee: NumberString,  // example: "0.2"  // Trade fee
         price: NumberString,  // example: "4.437472"
         status: string,  // example: "Failed"  // Processing, Completed, Failed, Refunded
         paymentMethod: string,  // example: "Credit Card"
         createTime: number,  // example: 1624529919000
         updateTime: number  // example: 1624529919000
       }[],
     total: number,  // example: 1
     success: boolean  // example: true
    }>;
  
  
  getFiatPaymentsHistory(...args : any) {
      return this._sendRequest("/sapi/v1/fiat/payments", "GET", "USER_DATA", false, args, ["transactionType", "beginTime", "endTime", "page", "rows", "recvWindow", "timestamp"], "getFiatPaymentsHistory");
  }
  
  
  
  //***** C2C Endpoints *****
  
  
  /** Get C2C Trade History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-c2c-trade-history-user_data}
   * 
   * EndPoint: /sapi/v1/c2c/orderMatch/listUserOrderHistory
   * 
   * Weight(IP): 1
   * 
   * @param {string} tradeType  -  BUY, SELL
   * @param {LONG} startTimestamp
   * @param {LONG} endTimestamp
   * @param {INT} page  -  default 1
   * @param {INT} rows  -  default 100, max 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getC2CTradeHistory(tradeType :string, startTimestamp? :LONG, endTimestamp? :LONG, page? :INT, rows? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getC2CTradeHistory"]>;
  
  
  /** Get C2C Trade History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-c2c-trade-history-user_data}
   * 
   * EndPoint: /sapi/v1/c2c/orderMatch/listUserOrderHistory
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.tradeType  -  BUY, SELL
   * @param {LONG} options.startTimestamp
   * @param {LONG} options.endTimestamp
   * @param {INT} options.page  -  default 1
   * @param {INT} options.rows  -  default 100, max 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getC2CTradeHistory(options : { tradeType :string, startTimestamp? :LONG, endTimestamp? :LONG, page? :INT, rows? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
         orderNumber: NumberString,  // example: "20219644646554779648"
         advNo: NumberString,  // example: "11218246497340923904"
         tradeType: string,  // example: "SELL"
         asset: string,  // example: "BUSD"
         fiat: string,  // example: "CNY"
         fiatSymbol: string,  // example: "￥"
         amount: NumberString,  // example: "5000.00000000"  // Quantity (in Crypto)
         totalPrice: NumberString,  // example: "33400.00000000"
         unitPrice: NumberString,  // example: "6.68"  // Unit Price (in Fiat)
         orderStatus: string,  // example: "COMPLETED"  // PENDING, TRADING, BUYER_PAYED, DISTRIBUTING, COMPLETED, IN_APPEAL, CANCELLED, CANCELLED_BY_SYSTEM
         createTime: number,  // example: 1619361369000
         commission: NumberString,  // example: "0"  // Transaction Fee (in Crypto)
         counterPartNickName: string,  // example: "ab***"
         advertisementRole: string  // example: "TAKER"
       }[],
     total: number,  // example: 1
     success: boolean  // example: true
    }>;
  
  
  getC2CTradeHistory(...args : any) {
      return this._sendRequest("/sapi/v1/c2c/orderMatch/listUserOrderHistory", "GET", "USER_DATA", false, args, ["tradeType", "startTimestamp", "endTimestamp", "page", "rows", "recvWindow", "timestamp"], "getC2CTradeHistory");
  }
  
  
  
  //***** VIP Loans Endpoints *****
  
  
  /** Get VIP Loan Ongoing Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-vip-loan-ongoing-orders-user_data}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/ongoing/orders
   * 
   * Weight(IP): 400
   * 
   * @param {LONG} orderId
   * @param {LONG} collateralAccountId
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {LONG} current  -  Currently querying page. Start from 1, Default:1, Max: 1000.
   * @param {LONG} limit  -  Default: 10, Max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getVIPLoanOngoingOrders(orderId? :LONG, collateralAccountId? :LONG, loanCoin? :string, collateralCoin? :string, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getVIPLoanOngoingOrders"]>;
  
  
  /** Get VIP Loan Ongoing Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-vip-loan-ongoing-orders-user_data}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/ongoing/orders
   * 
   * Weight(IP): 400
   * 
   * @param {LONG} options.orderId
   * @param {LONG} options.collateralAccountId
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {LONG} options.current  -  Currently querying page. Start from 1, Default:1, Max: 1000.
   * @param {LONG} options.limit  -  Default: 10, Max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getVIPLoanOngoingOrders(options? : { orderId? :LONG, collateralAccountId? :LONG, loanCoin? :string, collateralCoin? :string, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         orderId: number,  // example: 100000001
         loanCoin: string,  // example: "BUSD"
         totalDebt: NumberString,  // example: "10000"
         loanRate: NumberString,  // example: "0.0123"  // "flexible rate" for flexible rate loan
         residualInterest: NumberString,  // example: "10.27687923"
         collateralAccountId: string,  // example: "12345678,23456789"
         collateralCoin: string,  // example: "BNB,BTC,ETH"
         totalCollateralValueAfterHaircut: NumberString,  // example: "25000.27565492"
         lockedCollateralValue: NumberString,  // example: "25000.27565492"
         currentLTV: NumberString,  // example: "0.57"
         expirationTime: number,  // example: 1575018510000  // 0 means open term
         loanDate: NumberString,  // example: "1676851200000"
         loanTerm: string,  // example: "30days"  //  "open term" for open term loan
         initialLtv: string,  // example: "72%"
         marginCallLtv: string,  // example: "77%"
         liquidationLtv: string  // example: "91%"
       }[],
     total: number  // example: 1
    }>;
  
  
  getVIPLoanOngoingOrders(...args : any) {
      return this._sendRequest("/sapi/v1/loan/vip/ongoing/orders", "GET", "USER_DATA", false, args, ["orderId", "collateralAccountId", "loanCoin", "collateralCoin", "current", "limit", "recvWindow", "timestamp"], "getVIPLoanOngoingOrders");
  }
  
  
  /** VIP Loan Repay (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#vip-loan-repay-trade}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/repay
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} orderId
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  viPLoanRepay(orderId :LONG, amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["viPLoanRepay"]>;
  
  
  /** VIP Loan Repay (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#vip-loan-repay-trade}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/repay
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} options.orderId
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  viPLoanRepay(options : { orderId :LONG, amount :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     loanCoin: string,  // example: "BUSD"
     repayAmount: NumberString,  // example: "200.5"
     remainingPrincipal: NumberString,  // example: "100.5"
     remainingInterest: NumberString,  // example: "0"
     collateralCoin: string,  // example: "BNB,BTC,ETH"
     currentLTV: NumberString,  // example: "0.25"
     repayStatus: string  // example: "Repaid"  // Repaid, Repaying, Failed
    }>;
  
  
  viPLoanRepay(...args : any) {
      return this._sendRequest("/sapi/v1/loan/vip/repay", "POST", "TRADE", false, args, ["orderId", "amount", "recvWindow", "timestamp"], "viPLoanRepay");
  }
  
  
  /** Get VIP Loan Repayment History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-vip-loan-repayment-history-user_data}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/repay/history
   * 
   * Weight(IP): 400
   * 
   * @param {LONG} orderId
   * @param {string} loanCoin
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1, Default:1, Max: 1000
   * @param {LONG} limit  -  Default: 10, Max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getVIPLoanRepaymentHistory(orderId? :LONG, loanCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getVIPLoanRepaymentHistory"]>;
  
  
  /** Get VIP Loan Repayment History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-vip-loan-repayment-history-user_data}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/repay/history
   * 
   * Weight(IP): 400
   * 
   * @param {LONG} options.orderId
   * @param {string} options.loanCoin
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1, Default:1, Max: 1000
   * @param {LONG} options.limit  -  Default: 10, Max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getVIPLoanRepaymentHistory(options? : { orderId? :LONG, loanCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanCoin: string,  // example: "BUSD"
         repayAmount: NumberString,  // example: "10000"
         collateralCoin: string,  // example: "BNB,BTC,ETH"
         repayStatus: string,  // example: "Repaid"  // Repaid, Repaying, Failed
         loanDate: NumberString,  // example: "1676851200000"
         repayTime: NumberString,  // example: "1575018510000"
         orderId: NumberString  // example: "756783308056935434"
       }[],
     total: number  // example: 1
    }>;
  
  
  getVIPLoanRepaymentHistory(...args : any) {
      return this._sendRequest("/sapi/v1/loan/vip/repay/history", "GET", "USER_DATA", false, args, ["orderId", "loanCoin", "startTime", "endTime", "current", "limit", "recvWindow", "timestamp"], "getVIPLoanRepaymentHistory");
  }
  
  
  /** VIP Loan Renew (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#vip-loan-renew-trade}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/renew
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} orderId
   * @param {INT} loanTerm  -  30/60 days
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  viPLoanRenew(orderId :LONG, loanTerm? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["viPLoanRenew"]>;
  
  
  /** VIP Loan Renew (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#vip-loan-renew-trade}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/renew
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} options.orderId
   * @param {INT} options.loanTerm  -  30/60 days
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  viPLoanRenew(options : { orderId :LONG, loanTerm? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     loanAccountId: NumberString,  // example: "12345678"  //loan receiving account
     loanCoin: string,  // example: "BTC"
     loanAmount: NumberString,  // example: "100.55"
     collateralAccountId: string,  // example: "12345677,12345678,12345679"
     collateralCoin: string,  // example: "BUSD,USDT,ETH"
     loanTerm: NumberString  // example: "30"
    }>;
  
  
  viPLoanRenew(...args : any) {
      return this._sendRequest("/sapi/v1/loan/vip/renew", "POST", "TRADE", false, args, ["orderId", "loanTerm", "recvWindow", "timestamp"], "viPLoanRenew");
  }
  
  
  /** Check Locked Value of VIP Collateral Account (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#check-locked-value-of-vip-collateral-account-user_data}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/collateral/account
   * 
   * Weight(IP): 6000
   * 
   * @param {LONG} orderId
   * @param {LONG} collateralAccountId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  checkLockedValueOfVIPCollateralAccount(orderId? :LONG, collateralAccountId? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["checkLockedValueOfVIPCollateralAccount"]>;
  
  
  /** Check Locked Value of VIP Collateral Account (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#check-locked-value-of-vip-collateral-account-user_data}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/collateral/account
   * 
   * Weight(IP): 6000
   * 
   * @param {LONG} options.orderId
   * @param {LONG} options.collateralAccountId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  checkLockedValueOfVIPCollateralAccount(options? : { orderId? :LONG, collateralAccountId? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         collateralAccountId: NumberString,  // example: "12345678"
         collateralCoin: string  // example: "BNB,BTC,ETH"
       }[],
     total: number  // example: 2
    }>;
  
  
  checkLockedValueOfVIPCollateralAccount(...args : any) {
      return this._sendRequest("/sapi/v1/loan/vip/collateral/account", "GET", "USER_DATA", false, args, ["orderId", "collateralAccountId", "recvWindow", "timestamp"], "checkLockedValueOfVIPCollateralAccount");
  }
  
  
  /** VIP Loan Borrow (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#vip-loan-borrow-trade}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/borrow
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} loanAccountId
   * @param {string} loanCoin
   * @param {DECIMAL} loanAmount
   * @param {string} collateralAccountId  -  Multiple split by ,
   * @param {string} collateralCoin  -  Multiple split by ,
   * @param {boolean} isFlexibleRate  -  Default: TRUE. TRUE : flexible rate; FALSE: fixed rate
   * @param {INT} loanTerm  -  Mandatory for fixed rate. Optional for fixed interest rate. Eg: 30/60 days
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  viPLoanBorrow(loanAccountId :LONG, loanCoin :string, loanAmount :DECIMAL, collateralAccountId :string, collateralCoin :string, isFlexibleRate :boolean, loanTerm? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["viPLoanBorrow"]>;
  
  
  /** VIP Loan Borrow (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#vip-loan-borrow-trade}
   * 
   * VIP loan is available for VIP users only.
   * 
   * EndPoint: /sapi/v1/loan/vip/borrow
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} options.loanAccountId
   * @param {string} options.loanCoin
   * @param {DECIMAL} options.loanAmount
   * @param {string} options.collateralAccountId  -  Multiple split by ,
   * @param {string} options.collateralCoin  -  Multiple split by ,
   * @param {boolean} options.isFlexibleRate  -  Default: TRUE. TRUE : flexible rate; FALSE: fixed rate
   * @param {INT} options.loanTerm  -  Mandatory for fixed rate. Optional for fixed interest rate. Eg: 30/60 days
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  viPLoanBorrow(options : { loanAccountId :LONG, loanCoin :string, loanAmount :DECIMAL, collateralAccountId :string, collateralCoin :string, isFlexibleRate :boolean, loanTerm? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     loanAccountId: NumberString,  // example: "12345678"  //loan receiving account
     requestId: NumberString,  // example: "12345678"
     loanCoin: string,  // example: "BTC"
     isFlexibleRate: string,  // example: "No"
     loanAmount: NumberString,  // example: "100.55"
     collateralAccountId: string,  // example: "12345678,12345678,12345678"
     collateralCoin: string,  // example: "BUSD,USDT,ETH"
     loanTerm: NumberString  // example: "30"
    } | {  // or
     loanAccountId: NumberString,  // example: "12345678"  //loan receiving account
     requestId: NumberString,  // example: "12345678"
     loanCoin: string,  // example: "BTC"
     isFlexibleRate: string,  // example: "Yes"
     loanAmount: NumberString,  // example: "100.55"
     collateralAccountId: string,  // example: "12345678,12345678,12345678"
     collateralCoin: string  // example: "BUSD,USDT,ETH"
    }>;
  
  
  viPLoanBorrow(...args : any) {
      return this._sendRequest("/sapi/v1/loan/vip/borrow", "POST", "TRADE", false, args, ["loanAccountId", "loanCoin", "loanAmount", "collateralAccountId", "collateralCoin", "isFlexibleRate", "loanTerm", "recvWindow", "timestamp"], "viPLoanBorrow");
  }
  
  
  /** Get Loanable Assets Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-loanable-assets-data-user_data}
   * 
   * Get interest rate and borrow limit of loanable assets. The borrow limit is shown in USD value.
   * 
   * EndPoint: /sapi/v1/loan/vip/loanable/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} loanCoin
   * @param {INT} vipLevel  -  default:user's vip level
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getLoanableAssetsDataVIP(loanCoin? :string, vipLevel? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getLoanableAssetsDataVIP"]>;
  
  
  /** Get Loanable Assets Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-loanable-assets-data-user_data}
   * 
   * Get interest rate and borrow limit of loanable assets. The borrow limit is shown in USD value.
   * 
   * EndPoint: /sapi/v1/loan/vip/loanable/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} options.loanCoin
   * @param {INT} options.vipLevel  -  default:user's vip level
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getLoanableAssetsDataVIP(options? : { loanCoin? :string, vipLevel? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanCoin: string,  // example: "BUSD"
         _flexibleHourlyInterestRate: NumberString,  // example: "0.000103"
         _flexibleYearlyInterestRate: NumberString,  // example: "0.548595"
         _30dDailyInterestRate: NumberString,  // example: "0.000136"
         _30dYearlyInterestRate: NumberString,  // example: "0.03450"
         _60dDailyInterestRate: NumberString,  // example: "0.000145"
         _60dYearlyInterestRate: NumberString,  // example: "0.04103"
         minLimit: NumberString,  // example: "100"
         maxLimit: NumberString,  // example: "1000000"
         vipLevel: number  // example: 1
       }[],
     total: number  // example: 1
    }>;
  
  
  getLoanableAssetsDataVIP(...args : any) {
      return this._sendRequest("/sapi/v1/loan/vip/loanable/data", "GET", "USER_DATA", false, args, ["loanCoin", "vipLevel", "recvWindow", "timestamp"], "getLoanableAssetsDataVIP");
  }
  
  
  /** Get Collateral Asset Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-collateral-asset-data-user_data}
   * 
   * Get Collateral Asset Data
   * 
   * EndPoint: /sapi/v1/loan/vip/collateral/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} collateralCoin
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getCollateralAssetData(collateralCoin? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getCollateralAssetData"]>;
  
  
  /** Get Collateral Asset Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-collateral-asset-data-user_data}
   * 
   * Get Collateral Asset Data
   * 
   * EndPoint: /sapi/v1/loan/vip/collateral/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} options.collateralCoin
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getCollateralAssetData(options? : { collateralCoin? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         collateralCoin: string,  // example: "BUSD"
         _1stCollateralRatio: string,  // example: "100%"
         _1stCollateralRange: string,  // example: "1-10000000"
         _2ndCollateralRatio: string,  // example: "80%"
         _2ndCollateralRange: string,  // example: "10000000-100000000"
         _3rdCollateralRatio: string,  // example: "60%"
         _3rdCollateralRange: string,  // example: "100000000-1000000000"
         _4thCollateralRatio: string,  // example: "0%"
         _4thCollateralRange: string  // example: ">10000000000"
       }[],
     total: number  // example: 1
    }>;
  
  
  getCollateralAssetData(...args : any) {
      return this._sendRequest("/sapi/v1/loan/vip/collateral/data", "GET", "USER_DATA", false, args, ["collateralCoin", "recvWindow", "timestamp"], "getCollateralAssetData");
  }
  
  
  /** Query Application Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-application-status-user_data}
   * 
   * EndPoint: /sapi/v1/loan/vip/request/data
   * 
   * Weight(UID): 400
   * 
   * @param {LONG} current  -  Currently querying page. Start from 1, Default:1, Max: 1000
   * @param {LONG} limit  -  Default: 10, Max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryApplicationStatus(current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryApplicationStatus"]>;
  
  
  /** Query Application Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-application-status-user_data}
   * 
   * EndPoint: /sapi/v1/loan/vip/request/data
   * 
   * Weight(UID): 400
   * 
   * @param {LONG} options.current  -  Currently querying page. Start from 1, Default:1, Max: 1000
   * @param {LONG} options.limit  -  Default: 10, Max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryApplicationStatus(options? : { current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanAccountId: NumberString,  // example: "12345678"  //loan receiving account
         orderId: NumberString,  // example: "12345678"
         requestId: NumberString,  // example: "12345678"
         loanCoin: string,  // example: "BTC"
         loanAmount: NumberString,  // example: "100.55"
         collateralAccountId: string,  // example: "12345678,12345678,12345678"
         collateralCoin: string,  // example: "BUSD,USDT,ETH"
         loanTerm: NumberString,  // example: "30"
         status: string,  // example: "Repaid"  // Accruing_Interest, Overdue, Liquidating, Repaying, Repaid, Liquidated, Pending, Failed
         loanDate: NumberString  // example: "1676851200000"
       }[],
     total: number  // example: 1
    }>;
  
  
  queryApplicationStatus(...args : any) {
      return this._sendRequest("/sapi/v1/loan/vip/request/data", "GET", "USER_DATA", false, args, ["current", "limit", "recvWindow", "timestamp"], "queryApplicationStatus");
  }
  
  
  /** Get Borrow Interest Rate (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-borrow-interest-rate-user_data}
   * 
   * EndPoint: /sapi/v1/loan/vip/request/interestRate
   * 
   * Weight(UID): 400
   * 
   * @param {string} loanCoin  -  Max 10 assets, Multiple split by ","
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getBorrowInterestRate(loanCoin :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getBorrowInterestRate"]>;
  
  
  /** Get Borrow Interest Rate (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-borrow-interest-rate-user_data}
   * 
   * EndPoint: /sapi/v1/loan/vip/request/interestRate
   * 
   * Weight(UID): 400
   * 
   * @param {string} options.loanCoin  -  Max 10 assets, Multiple split by ","
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getBorrowInterestRate(options : { loanCoin :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       asset: string,  // example: "BUSD"
       flexibleDailyInterestRate: NumberString,  // example: "0.001503"
       flexibleYearlyInterestRate: NumberString,  // example: "0.548595"
       time: number  // example: 1577233578000
     }[]>;
  
  
  getBorrowInterestRate(...args : any) {
      return this._sendRequest("/sapi/v1/loan/vip/request/interestRate", "GET", "USER_DATA", false, args, ["loanCoin", "recvWindow", "timestamp"], "getBorrowInterestRate");
  }
  
  
  
  //***** Crypto Loans Endpoints *****
  
  
  /** Get Crypto Loans Income History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-crypto-loans-income-history-user_data}
   * 
   * EndPoint: /sapi/v1/loan/income
   * 
   * Weight(UID): 6000
   * 
   * @param {string} asset
   * @param {string} type  -  All types will be returned by default. Enum：borrowIn ,collateralSpent, repayAmount, collateralReturn(Collateral return after repayment), addCollateral, removeCollateral, collateralReturnAfterLiquidation
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  default 20, max 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getCryptoLoansIncomeHistory(asset? :string, type? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getCryptoLoansIncomeHistory"]>;
  
  
  /** Get Crypto Loans Income History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-crypto-loans-income-history-user_data}
   * 
   * EndPoint: /sapi/v1/loan/income
   * 
   * Weight(UID): 6000
   * 
   * @param {string} options.asset
   * @param {string} options.type  -  All types will be returned by default. Enum：borrowIn ,collateralSpent, repayAmount, collateralReturn(Collateral return after repayment), addCollateral, removeCollateral, collateralReturnAfterLiquidation
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  default 20, max 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getCryptoLoansIncomeHistory(options? : { asset? :string, type? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       asset: string,  // example: "BUSD"
       type: string,  // example: "borrowIn"
       amount: NumberString,  // example: "100"
       timestamp: number,  // example: 1633771139847
       tranId: NumberString  // example: "80423589583"
     }[]>;
  
  
  getCryptoLoansIncomeHistory(...args : any) {
      return this._sendRequest("/sapi/v1/loan/income", "GET", "USER_DATA", false, args, ["asset", "type", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "getCryptoLoansIncomeHistory");
  }
  
  
  /** Borrow - Crypto Loan Borrow (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-crypto-loan-borrow-trade}
   * 
   * EndPoint: /sapi/v1/loan/borrow
   * 
   * Weight(UID): 36000
   * 
   * @param {string} loanCoin
   * @param {DECIMAL} loanAmount  -  Mandatory when collateralAmount is empty
   * @param {string} collateralCoin
   * @param {DECIMAL} collateralAmount  -  Mandatory when loanAmount is empty
   * @param {INT} loanTerm  -  7/30 days
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  borrowCryptoLoanBorrow(loanCoin :string, loanAmount :DECIMAL|undefined, collateralCoin :string, collateralAmount :DECIMAL|undefined, loanTerm :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["borrowCryptoLoanBorrow"]>;
  
  
  /** Borrow - Crypto Loan Borrow (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-crypto-loan-borrow-trade}
   * 
   * EndPoint: /sapi/v1/loan/borrow
   * 
   * Weight(UID): 36000
   * 
   * @param {string} options.loanCoin
   * @param {DECIMAL} options.loanAmount  -  Mandatory when collateralAmount is empty
   * @param {string} options.collateralCoin
   * @param {DECIMAL} options.collateralAmount  -  Mandatory when loanAmount is empty
   * @param {INT} options.loanTerm  -  7/30 days
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  borrowCryptoLoanBorrow(options : { loanCoin :string, loanAmount? :DECIMAL, collateralCoin :string, collateralAmount? :DECIMAL, loanTerm :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     loanCoin: string,  // example: "BUSD"
     loanAmount: NumberString,  // example: "100.5"
     collateralCoin: string,  // example: "BNB"
     collateralAmount: NumberString,  // example: "50.5"
     hourlyInterestRate: NumberString,  // example: "0.001234"
     orderId: NumberString  // example: "100000001"
    }>;
  
  
  borrowCryptoLoanBorrow(...args : any) {
      return this._sendRequest("/sapi/v1/loan/borrow", "POST", "TRADE", false, args, ["loanCoin", "loanAmount", "collateralCoin", "collateralAmount", "loanTerm", "recvWindow", "timestamp"], "borrowCryptoLoanBorrow");
  }
  
  
  /** Borrow - Get Loan Borrow History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-get-loan-borrow-history-user_data}
   * 
   * EndPoint: /sapi/v1/loan/borrow/history
   * 
   * Weight(IP): 400
   * 
   * @param {LONG} orderId  -  orderId in POST /sapi/v1/loan/borrow
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Current querying page. Start from 1; default: 1; max: 1000.
   * @param {LONG} limit  -  Default: 10; max: 100.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  borrowGetLoanBorrowHistory(orderId? :LONG, loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["borrowGetLoanBorrowHistory"]>;
  
  
  /** Borrow - Get Loan Borrow History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-get-loan-borrow-history-user_data}
   * 
   * EndPoint: /sapi/v1/loan/borrow/history
   * 
   * Weight(IP): 400
   * 
   * @param {LONG} options.orderId  -  orderId in POST /sapi/v1/loan/borrow
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Current querying page. Start from 1; default: 1; max: 1000.
   * @param {LONG} options.limit  -  Default: 10; max: 100.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  borrowGetLoanBorrowHistory(options? : { orderId? :LONG, loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         orderId: number,  // example: 100000001
         loanCoin: string,  // example: "BUSD"
         initialLoanAmount: NumberString,  // example: "10000"
         hourlyInterestRate: NumberString,  // example: "0.000057"
         loanTerm: NumberString,  // example: "7"
         collateralCoin: string,  // example: "BNB"
         initialCollateralAmount: NumberString,  // example: "49.27565492"
         borrowTime: number,  // example: 1575018510000
         status: string  // example: "Repaid"  // Accruing_Interest, Overdue, Liquidating, Repaying, Repaid, Liquidated, Pending, Failed
       }[],
     total: number  // example: 1
    }>;
  
  
  borrowGetLoanBorrowHistory(...args : any) {
      return this._sendRequest("/sapi/v1/loan/borrow/history", "GET", "USER_DATA", false, args, ["orderId", "loanCoin", "collateralCoin", "startTime", "endTime", "current", "limit", "recvWindow", "timestamp"], "borrowGetLoanBorrowHistory");
  }
  
  
  /** Borrow - Get Loan Ongoing Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-get-loan-ongoing-orders-user_data}
   * 
   * EndPoint: /sapi/v1/loan/ongoing/orders
   * 
   * Weight(IP): 300
   * 
   * @param {LONG} orderId  -  orderId in POST /sapi/v1/loan/borrow
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {LONG} current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} limit  -  Default: 10; max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  borrowGetLoanOngoingOrders(orderId? :LONG, loanCoin? :string, collateralCoin? :string, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["borrowGetLoanOngoingOrders"]>;
  
  
  /** Borrow - Get Loan Ongoing Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-get-loan-ongoing-orders-user_data}
   * 
   * EndPoint: /sapi/v1/loan/ongoing/orders
   * 
   * Weight(IP): 300
   * 
   * @param {LONG} options.orderId  -  orderId in POST /sapi/v1/loan/borrow
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {LONG} options.current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} options.limit  -  Default: 10; max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  borrowGetLoanOngoingOrders(options? : { orderId? :LONG, loanCoin? :string, collateralCoin? :string, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         orderId: number,  // example: 100000001
         loanCoin: string,  // example: "BUSD"
         totalDebt: NumberString,  // example: "10000"
         residualInterest: NumberString,  // example: "10.27687923"
         collateralCoin: string,  // example: "BNB"
         collateralAmount: NumberString,  // example: "49.27565492"
         currentLTV: NumberString,  // example: "0.57"
         expirationTime: number  // example: 1575018510000
       }[],
     total: number  // example: 1
    }>;
  
  
  borrowGetLoanOngoingOrders(...args : any) {
      return this._sendRequest("/sapi/v1/loan/ongoing/orders", "GET", "USER_DATA", false, args, ["orderId", "loanCoin", "collateralCoin", "current", "limit", "recvWindow", "timestamp"], "borrowGetLoanOngoingOrders");
  }
  
  
  /** Repay - Crypto Loan Repay (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#repay-crypto-loan-repay-trade}
   * 
   * EndPoint: /sapi/v1/loan/repay
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} orderId
   * @param {DECIMAL} amount
   * @param {INT} type  -  Default: 1. 1 for "repay with borrowed coin"; 2 for "repay with collateral".
   * @param {boolean} collateralReturn  -  Default: TRUE. TRUE: Return extra collateral to spot account; FALSE: Keep extra collateral in the order.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  repayCryptoLoanRepay(orderId :LONG, amount :DECIMAL, type? :INT, collateralReturn? :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["repayCryptoLoanRepay"]>;
  
  
  /** Repay - Crypto Loan Repay (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#repay-crypto-loan-repay-trade}
   * 
   * EndPoint: /sapi/v1/loan/repay
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} options.orderId
   * @param {DECIMAL} options.amount
   * @param {INT} options.type  -  Default: 1. 1 for "repay with borrowed coin"; 2 for "repay with collateral".
   * @param {boolean} options.collateralReturn  -  Default: TRUE. TRUE: Return extra collateral to spot account; FALSE: Keep extra collateral in the order.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  repayCryptoLoanRepay(options : { orderId :LONG, amount :DECIMAL, type? :INT, collateralReturn? :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     loanCoin: string,  // example: "BUSD"
     remainingPrincipal: NumberString,  // example: "100.5"
     remainingInterest: NumberString,  // example: "0"
     collateralCoin: string,  // example: "BNB"
     remainingCollateral: NumberString,  // example: "5.253"
     currentLTV: NumberString,  // example: "0.25"
     repayStatus: string  // example: "Repaid"  // Repaid, Repaying
    } | {
     loanCoin: string,  // example: "BUSD"
     collateralCoin: string,  // example: "BNB"
     repayStatus: string  // example: "Repaying"  // Repaid, Repaying
    }>;
  
  
  repayCryptoLoanRepay(...args : any) {
      return this._sendRequest("/sapi/v1/loan/repay", "POST", "TRADE", false, args, ["orderId", "amount", "type", "collateralReturn", "recvWindow", "timestamp"], "repayCryptoLoanRepay");
  }
  
  
  /** Repay - Get Loan Repayment History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#repay-get-loan-repayment-history-user_data}
   * 
   * EndPoint: /sapi/v1/loan/repay/history
   * 
   * Weight(IP): 400
   * 
   * @param {LONG} orderId
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} limit  -  Default: 10; max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  repayGetLoanRepaymentHistory(orderId? :LONG, loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["repayGetLoanRepaymentHistory"]>;
  
  
  /** Repay - Get Loan Repayment History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#repay-get-loan-repayment-history-user_data}
   * 
   * EndPoint: /sapi/v1/loan/repay/history
   * 
   * Weight(IP): 400
   * 
   * @param {LONG} options.orderId
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} options.limit  -  Default: 10; max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  repayGetLoanRepaymentHistory(options? : { orderId? :LONG, loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanCoin: string,  // example: "BUSD"
         repayAmount: NumberString,  // example: "10000"
         collateralCoin: string,  // example: "BNB"
         collateralUsed: NumberString,  // example: "0"
         collateralReturn: NumberString,  // example: "49.27565492"
         repayType: NumberString,  // example: "1"  // 1 for "repay with borrowed coin", 2 for "repay with collateral"
         repayStatus: string,  // example: "Repaid"  // Repaid, Repaying, Failed
         repayTime: number,  // example: 1575018510000
         orderId: number  // example: 756783308056935400
       }[],
     total: number  // example: 1
    }>;
  
  
  repayGetLoanRepaymentHistory(...args : any) {
      return this._sendRequest("/sapi/v1/loan/repay/history", "GET", "USER_DATA", false, args, ["orderId", "loanCoin", "collateralCoin", "startTime", "endTime", "current", "limit", "recvWindow", "timestamp"], "repayGetLoanRepaymentHistory");
  }
  
  
  /** Adjust LTV - Crypto Loan Adjust LTV (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#adjust-ltv-crypto-loan-adjust-ltv-trade}
   * 
   * EndPoint: /sapi/v1/loan/adjust/ltv
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} orderId
   * @param {DECIMAL} amount
   * @param {"ADDITIONAL"|"REDUCED"} direction  -  "ADDITIONAL", "REDUCED"
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  adjustLTVCryptoLoanAdjustLTV(orderId :LONG, amount :DECIMAL, direction :"ADDITIONAL"|"REDUCED", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["adjustLTVCryptoLoanAdjustLTV"]>;
  
  
  /** Adjust LTV - Crypto Loan Adjust LTV (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#adjust-ltv-crypto-loan-adjust-ltv-trade}
   * 
   * EndPoint: /sapi/v1/loan/adjust/ltv
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} options.orderId
   * @param {DECIMAL} options.amount
   * @param {"ADDITIONAL"|"REDUCED"} options.direction  -  "ADDITIONAL", "REDUCED"
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  adjustLTVCryptoLoanAdjustLTV(options : { orderId :LONG, amount :DECIMAL, direction :"ADDITIONAL"|"REDUCED", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     loanCoin: string,  // example: "BUSD"
     collateralCoin: string,  // example: "BNB"
     direction: string,  // example: "ADDITIONAL"
     amount: NumberString,  // example: "5.235"
     currentLTV: NumberString  // example: "0.52"
    }>;
  
  
  adjustLTVCryptoLoanAdjustLTV(...args : any) {
      return this._sendRequest("/sapi/v1/loan/adjust/ltv", "POST", "TRADE", false, args, ["orderId", "amount", "direction", "recvWindow", "timestamp"], "adjustLTVCryptoLoanAdjustLTV");
  }
  
  
  /** Adjust LTV - Get Loan LTV Adjustment History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#adjust-ltv-get-loan-ltv-adjustment-history-user_data}
   * 
   * EndPoint: /sapi/v1/loan/ltv/adjustment/history
   * 
   * Weight(IP): 400
   * 
   * @param {LONG} orderId
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} limit  -  Default: 10; max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  adjustLTVGetLoanLTVAdjustmentHistory(orderId? :LONG, loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["adjustLTVGetLoanLTVAdjustmentHistory"]>;
  
  
  /** Adjust LTV - Get Loan LTV Adjustment History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#adjust-ltv-get-loan-ltv-adjustment-history-user_data}
   * 
   * EndPoint: /sapi/v1/loan/ltv/adjustment/history
   * 
   * Weight(IP): 400
   * 
   * @param {LONG} options.orderId
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} options.limit  -  Default: 10; max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  adjustLTVGetLoanLTVAdjustmentHistory(options? : { orderId? :LONG, loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanCoin: string,  // example: "BUSD"
         collateralCoin: string,  // example: "BNB"
         direction: string,  // example: "ADDITIONAL"
         amount: NumberString,  // example: "5.235"
         preLTV: NumberString,  // example: "0.78"
         afterLTV: NumberString,  // example: "0.56"
         adjustTime: number,  // example: 1575018510000
         orderId: number  // example: 756783308056935400
       }[],
     total: number  // example: 1
    }>;
  
  
  adjustLTVGetLoanLTVAdjustmentHistory(...args : any) {
      return this._sendRequest("/sapi/v1/loan/ltv/adjustment/history", "GET", "USER_DATA", false, args, ["orderId", "loanCoin", "collateralCoin", "startTime", "endTime", "current", "limit", "recvWindow", "timestamp"], "adjustLTVGetLoanLTVAdjustmentHistory");
  }
  
  
  /** Get Loanable Assets Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-loanable-assets-data-user_data-2}
   * 
   * Get interest rate and borrow limit of loanable assets. The borrow limit is shown in USD value.
   * 
   * EndPoint: /sapi/v1/loan/loanable/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} loanCoin
   * @param {INT} vipLevel  -  Default: user's vip level. Send "-1" to check specified configuration
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getLoanableAssetsData(loanCoin? :string, vipLevel? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getLoanableAssetsData"]>;
  
  
  /** Get Loanable Assets Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-loanable-assets-data-user_data-2}
   * 
   * Get interest rate and borrow limit of loanable assets. The borrow limit is shown in USD value.
   * 
   * EndPoint: /sapi/v1/loan/loanable/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} options.loanCoin
   * @param {INT} options.vipLevel  -  Default: user's vip level. Send "-1" to check specified configuration
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getLoanableAssetsData(options? : { loanCoin? :string, vipLevel? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanCoin: string,  // example: "BUSD"
         _7dHourlyInterestRate: NumberString,  // example: "0.00000491"
         _7dDailyInterestRate: NumberString,  // example: "0.000118"
         _14dHourlyInterestRate: NumberString,  // example: "0.00000491"
         _14dDailyInterestRate: NumberString,  // example: "0.000118"
         _30dHourlyInterestRate: NumberString,  // example: "0.00000567"
         _30dDailyInterestRate: NumberString,  // example: "0.000136"
         _90dHourlyInterestRate: NumberString,  // example: "0.00000596"
         _90dDailyInterestRate: NumberString,  // example: "0.000143"
         _180dHourlyInterestRate: NumberString,  // example: "0.00000631"
         _180dDailyInterestRate: NumberString,  // example: "0.000151"
         minLimit: NumberString,  // example: "100"
         maxLimit: NumberString,  // example: "1000000"
         vipLevel: number  // example: 1
       }[],
     total: number  // example: 1
    }>;
  
  
  getLoanableAssetsData(...args : any) {
      return this._sendRequest("/sapi/v1/loan/loanable/data", "GET", "USER_DATA", false, args, ["loanCoin", "vipLevel", "recvWindow", "timestamp"], "getLoanableAssetsData");
  }
  
  
  /** Get Collateral Assets Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-collateral-assets-data-user_data}
   * 
   * Get LTV information and collateral limit of collateral assets. The collateral limit is shown in USD value.
   * 
   * EndPoint: /sapi/v1/loan/collateral/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} collateralCoin
   * @param {INT} vipLevel  -  Default: user's vip level. Send "-1" to check specified configuration
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getCollateralAssetsData(collateralCoin? :string, vipLevel? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getCollateralAssetsData"]>;
  
  
  /** Get Collateral Assets Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-collateral-assets-data-user_data}
   * 
   * Get LTV information and collateral limit of collateral assets. The collateral limit is shown in USD value.
   * 
   * EndPoint: /sapi/v1/loan/collateral/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} options.collateralCoin
   * @param {INT} options.vipLevel  -  Default: user's vip level. Send "-1" to check specified configuration
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getCollateralAssetsData(options? : { collateralCoin? :string, vipLevel? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         collateralCoin: string,  // example: "BNB"
         initialLTV: NumberString,  // example: "0.65"
         marginCallLTV: NumberString,  // example: "0.75"
         liquidationLTV: NumberString,  // example: "0.83"
         maxLimit: NumberString,  // example: "1000000"
         vipLevel: number  // example: 1
       }[],
     total: number  // example: 1
    }>;
  
  
  getCollateralAssetsData(...args : any) {
      return this._sendRequest("/sapi/v1/loan/collateral/data", "GET", "USER_DATA", false, args, ["collateralCoin", "vipLevel", "recvWindow", "timestamp"], "getCollateralAssetsData");
  }
  
  
  /** Check Collateral Repay Rate (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#check-collateral-repay-rate-user_data}
   * 
   * Get the the rate of collateral coin / loan coin when using collateral repay, the rate will be valid within 8 second.
   * 
   * EndPoint: /sapi/v1/loan/repay/collateral/rate
   * 
   * Weight(IP): 6000
   * 
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {DECIMAL} repayAmount  -  repay amount of loanCoin
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  checkCollateralRepayRate(loanCoin :string, collateralCoin :string, repayAmount :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["checkCollateralRepayRate"]>;
  
  
  /** Check Collateral Repay Rate (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#check-collateral-repay-rate-user_data}
   * 
   * Get the the rate of collateral coin / loan coin when using collateral repay, the rate will be valid within 8 second.
   * 
   * EndPoint: /sapi/v1/loan/repay/collateral/rate
   * 
   * Weight(IP): 6000
   * 
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {DECIMAL} options.repayAmount  -  repay amount of loanCoin
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  checkCollateralRepayRate(options : { loanCoin :string, collateralCoin :string, repayAmount :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     loanlCoin: string,  // example: "BUSD"
     collateralCoin: string,  // example: "BNB"
     repayAmount: NumberString,  // example: "1000"
     rate: NumberString  // example: "300.36781234"  // rate of collateral coin/loan coin
    }>;
  
  
  checkCollateralRepayRate(...args : any) {
      return this._sendRequest("/sapi/v1/loan/repay/collateral/rate", "GET", "USER_DATA", false, args, ["loanCoin", "collateralCoin", "repayAmount", "recvWindow", "timestamp"], "checkCollateralRepayRate");
  }
  
  
  /** Crypto Loan Customize Margin Call (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#crypto-loan-customize-margin-call-trade}
   * 
   * Customize margin call for ongoing orders only.
   * 
   * EndPoint: /sapi/v1/loan/customize/margin_call
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} orderId  -  Mandatory when collateralCoin is empty. Send either orderId or collateralCoin, if both parameters are sent, take orderId only.
   * @param {string} collateralCoin  -  Mandatory when orderID is empty. Send either orderId or collateralCoin, if both parameters are sent, take orderId only.
   * @param {DECIMAL} marginCall
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  cryptoLoanCustomizeMarginCall(orderId :LONG|undefined, collateralCoin :string|undefined, marginCall :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["cryptoLoanCustomizeMarginCall"]>;
  
  
  /** Crypto Loan Customize Margin Call (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#crypto-loan-customize-margin-call-trade}
   * 
   * Customize margin call for ongoing orders only.
   * 
   * EndPoint: /sapi/v1/loan/customize/margin_call
   * 
   * Weight(UID): 6000
   * 
   * @param {LONG} options.orderId  -  Mandatory when collateralCoin is empty. Send either orderId or collateralCoin, if both parameters are sent, take orderId only.
   * @param {string} options.collateralCoin  -  Mandatory when orderID is empty. Send either orderId or collateralCoin, if both parameters are sent, take orderId only.
   * @param {DECIMAL} options.marginCall
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  cryptoLoanCustomizeMarginCall(options : { orderId? :LONG, collateralCoin? :string, marginCall :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         orderId: NumberString,  // example: "100000001"
         collateralCoin: string,  // example: "BNB"
         preMarginCall: NumberString,  // example: "0.8"
         afterMarginCall: NumberString,  // example: "0.7"
         customizeTime: number  // example: 1575018510000
       }[],
     total: number  // example: 1
    }>;
  
  
  cryptoLoanCustomizeMarginCall(...args : any) {
      return this._sendRequest("/sapi/v1/loan/customize/margin_call", "POST", "TRADE", false, args, ["orderId", "collateralCoin", "marginCall", "recvWindow", "timestamp"], "cryptoLoanCustomizeMarginCall");
  }
  
  
  /** Borrow - Flexible Loan Borrow (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-flexible-loan-borrow-trade}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/borrow
   * 
   * Weight(UID): 6000
   * 
   * @param {string} loanCoin
   * @param {DECIMAL} loanAmount  -  Mandatory when collateralAmount is empty
   * @param {string} collateralCoin
   * @param {DECIMAL} collateralAmount  -  Mandatory when loanAmount is empty
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  borrowFlexibleLoanBorrow(loanCoin :string, loanAmount :DECIMAL|undefined, collateralCoin :string, collateralAmount? :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["borrowFlexibleLoanBorrow"]>;
  
  
  /** Borrow - Flexible Loan Borrow (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-flexible-loan-borrow-trade}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/borrow
   * 
   * Weight(UID): 6000
   * 
   * @param {string} options.loanCoin
   * @param {DECIMAL} options.loanAmount  -  Mandatory when collateralAmount is empty
   * @param {string} options.collateralCoin
   * @param {DECIMAL} options.collateralAmount  -  Mandatory when loanAmount is empty
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  borrowFlexibleLoanBorrow(options : { loanCoin :string, loanAmount? :DECIMAL, collateralCoin :string, collateralAmount? :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     loanCoin: string,  // example: "BUSD"
     loanAmount: NumberString,  // example: "100.5"
     collateralCoin: string,  // example: "BNB"
     collateralAmount: NumberString,  // example: "50.5"
     status: string  // example: "Succeeds"  //Succeeds, Failed, Processing
    }>;
  
  
  borrowFlexibleLoanBorrow(...args : any) {
      return this._sendRequest("/sapi/v1/loan/flexible/borrow", "POST", "TRADE", false, args, ["loanCoin", "loanAmount", "collateralCoin", "collateralAmount", "recvWindow", "timestamp"], "borrowFlexibleLoanBorrow");
  }
  
  
  /** Borrow - Get Flexible Loan Ongoing Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-get-flexible-loan-ongoing-orders-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/ongoing/orders
   * 
   * Weight(IP): 300
   * 
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {LONG} current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} limit  -  Default: 10; max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  borrowGetFlexibleLoanOngoingOrders(loanCoin? :string, collateralCoin? :string, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["borrowGetFlexibleLoanOngoingOrders"]>;
  
  
  /** Borrow - Get Flexible Loan Ongoing Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-get-flexible-loan-ongoing-orders-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/ongoing/orders
   * 
   * Weight(IP): 300
   * 
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {LONG} options.current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} options.limit  -  Default: 10; max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  borrowGetFlexibleLoanOngoingOrders(options? : { loanCoin? :string, collateralCoin? :string, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanCoin: string,  // example: "BUSD"
         totalDebt: NumberString,  // example: "10000"
         collateralCoin: string,  // example: "BNB"
         collateralAmount: NumberString,  // example: "49.27565492"
         currentLTV: NumberString  // example: "0.57"
       }[],
     total: number  // example: 1
    }>;
  
  
  borrowGetFlexibleLoanOngoingOrders(...args : any) {
      return this._sendRequest("/sapi/v1/loan/flexible/ongoing/orders", "GET", "USER_DATA", false, args, ["loanCoin", "collateralCoin", "current", "limit", "recvWindow", "timestamp"], "borrowGetFlexibleLoanOngoingOrders");
  }
  
  
  /** Borrow - Get Flexible Loan Borrow History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-get-flexible-loan-borrow-history-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/borrow/history
   * 
   * Weight(IP): 400
   * 
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} limit  -  Default: 10; max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  borrowGetFlexibleLoanBorrowHistory(loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["borrowGetFlexibleLoanBorrowHistory"]>;
  
  
  /** Borrow - Get Flexible Loan Borrow History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#borrow-get-flexible-loan-borrow-history-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/borrow/history
   * 
   * Weight(IP): 400
   * 
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} options.limit  -  Default: 10; max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  borrowGetFlexibleLoanBorrowHistory(options? : { loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanCoin: string,  // example: "BUSD"
         initialLoanAmount: NumberString,  // example: "10000"
         collateralCoin: string,  // example: "BNB"
         initialCollateralAmount: NumberString,  // example: "49.27565492"
         borrowTime: number,  // example: 1575018510000
         status: string  // example: "Succeeds"  //Succeeds, Failed, Processing
       }[],
     total: number  // example: 1
    }>;
  
  
  borrowGetFlexibleLoanBorrowHistory(...args : any) {
      return this._sendRequest("/sapi/v1/loan/flexible/borrow/history", "GET", "USER_DATA", false, args, ["loanCoin", "collateralCoin", "startTime", "endTime", "current", "limit", "recvWindow", "timestamp"], "borrowGetFlexibleLoanBorrowHistory");
  }
  
  
  /** Repay - Flexible Loan Repay (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#repay-flexible-loan-repay-trade}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/repay
   * 
   * Weight(UID): 6000
   * 
   * @param {string} loanCoin
   * @param {DECIMAL} collateralCoin
   * @param {DECIMAL} repayAmount
   * @param {boolean} collateralReturn  -  Default: TRUE. TRUE: Return extra collateral to earn account; FALSE: Keep extra collateral in the order, and lower LTV.
   * @param {boolean} fullRepayment  -  Default: FALSE. TRUE: Full repayment; FALSE: Partial repayment, based on loanAmount
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  repayFlexibleLoanRepay(loanCoin :string, collateralCoin :DECIMAL, repayAmount :DECIMAL, collateralReturn? :boolean, fullRepayment? :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["repayFlexibleLoanRepay"]>;
  
  
  /** Repay - Flexible Loan Repay (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#repay-flexible-loan-repay-trade}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/repay
   * 
   * Weight(UID): 6000
   * 
   * @param {string} options.loanCoin
   * @param {DECIMAL} options.collateralCoin
   * @param {DECIMAL} options.repayAmount
   * @param {boolean} options.collateralReturn  -  Default: TRUE. TRUE: Return extra collateral to earn account; FALSE: Keep extra collateral in the order, and lower LTV.
   * @param {boolean} options.fullRepayment  -  Default: FALSE. TRUE: Full repayment; FALSE: Partial repayment, based on loanAmount
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  repayFlexibleLoanRepay(options : { loanCoin :string, collateralCoin :DECIMAL, repayAmount :DECIMAL, collateralReturn? :boolean, fullRepayment? :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     loanCoin: string,  // example: "BUSD"
     collateralCoin: string,  // example: "BNB"
     remainingDebt: NumberString,  // example: "100.5"
     remainingCollateral: NumberString,  // example: "5.253"
     fullRepayment: boolean,  // example: false
     currentLTV: NumberString,  // example: "0.25"
     repayStatus: string  // example: "Repaid"  // Repaid, Repaying, Failed
    }>;
  
  
  repayFlexibleLoanRepay(...args : any) {
      return this._sendRequest("/sapi/v1/loan/flexible/repay", "POST", "TRADE", false, args, ["loanCoin", "collateralCoin", "repayAmount", "collateralReturn", "fullRepayment", "recvWindow", "timestamp"], "repayFlexibleLoanRepay");
  }
  
  
  /** Repay - Get Flexible Loan Repayment History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#repay-get-flexible-loan-repayment-history-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/repay/history
   * 
   * Weight(IP): 400
   * 
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} limit  -  Default: 10; max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  repayGetFlexibleLoanRepaymentHistory(loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["repayGetFlexibleLoanRepaymentHistory"]>;
  
  
  /** Repay - Get Flexible Loan Repayment History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#repay-get-flexible-loan-repayment-history-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/repay/history
   * 
   * Weight(IP): 400
   * 
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} options.limit  -  Default: 10; max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  repayGetFlexibleLoanRepaymentHistory(options? : { loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanCoin: string,  // example: "BUSD"
         repayAmount: NumberString,  // example: "10000"
         collateralCoin: string,  // example: "BNB"
         collateralReturn: NumberString,  // example: "49.27565492"
         repayStatus: string,  // example: "Repaid"  // Repaid, Repaying, Failed
         repayTime: number  // example: 1575018510000
       }[],
     total: number  // example: 1
    }>;
  
  
  repayGetFlexibleLoanRepaymentHistory(...args : any) {
      return this._sendRequest("/sapi/v1/loan/flexible/repay/history", "GET", "USER_DATA", false, args, ["loanCoin", "collateralCoin", "startTime", "endTime", "current", "limit", "recvWindow", "timestamp"], "repayGetFlexibleLoanRepaymentHistory");
  }
  
  
  /** Adjust LTV - Flexible Loan Adjust LTV (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#adjust-ltv-flexible-loan-adjust-ltv-trade}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/adjust/ltv
   * 
   * Weight(UID): 6000
   * 
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {DECIMAL} adjustmentAmount
   * @param {"ADDITIONAL"|"REDUCED"} direction  -  "ADDITIONAL", "REDUCED"
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  adjustLTVFlexibleLoanAdjustLTV(loanCoin :string, collateralCoin :string, adjustmentAmount :DECIMAL, direction :"ADDITIONAL"|"REDUCED", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["adjustLTVFlexibleLoanAdjustLTV"]>;
  
  
  /** Adjust LTV - Flexible Loan Adjust LTV (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#adjust-ltv-flexible-loan-adjust-ltv-trade}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/adjust/ltv
   * 
   * Weight(UID): 6000
   * 
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {DECIMAL} options.adjustmentAmount
   * @param {"ADDITIONAL"|"REDUCED"} options.direction  -  "ADDITIONAL", "REDUCED"
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  adjustLTVFlexibleLoanAdjustLTV(options : { loanCoin :string, collateralCoin :string, adjustmentAmount :DECIMAL, direction :"ADDITIONAL"|"REDUCED", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     loanCoin: string,  // example: "BUSD"
     collateralCoin: string,  // example: "BNB"
     direction: string,  // example: "ADDITIONAL"
     adjustmentAmount: NumberString,  // example: "5.235"
     currentLTV: NumberString  // example: "0.52"
    }>;
  
  
  adjustLTVFlexibleLoanAdjustLTV(...args : any) {
      return this._sendRequest("/sapi/v1/loan/flexible/adjust/ltv", "POST", "TRADE", false, args, ["loanCoin", "collateralCoin", "adjustmentAmount", "direction", "recvWindow", "timestamp"], "adjustLTVFlexibleLoanAdjustLTV");
  }
  
  
  /** Adjust LTV - Get Flexible Loan LTV Adjustment History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#adjust-ltv-get-flexible-loan-ltv-adjustment-history-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/ltv/adjustment/history
   * 
   * Weight(IP): 400
   * 
   * @param {string} loanCoin
   * @param {string} collateralCoin
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} limit  -  Default: 10; max: 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  adjustLTVGetFlexibleLoanLTVAdjustmentHistory(loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["adjustLTVGetFlexibleLoanLTVAdjustmentHistory"]>;
  
  
  /** Adjust LTV - Get Flexible Loan LTV Adjustment History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#adjust-ltv-get-flexible-loan-ltv-adjustment-history-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/ltv/adjustment/history
   * 
   * Weight(IP): 400
   * 
   * @param {string} options.loanCoin
   * @param {string} options.collateralCoin
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Current querying page. Start from 1; default: 1; max: 1000
   * @param {LONG} options.limit  -  Default: 10; max: 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  adjustLTVGetFlexibleLoanLTVAdjustmentHistory(options? : { loanCoin? :string, collateralCoin? :string, startTime? :LONG, endTime? :LONG, current? :LONG, limit? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanCoin: string,  // example: "BUSD"
         collateralCoin: string,  // example: "BNB"
         direction: string,  // example: "ADDITIONAL"
         collateralAmount: NumberString,  // example: "5.235"
         preLTV: NumberString,  // example: "0.78"
         afterLTV: NumberString,  // example: "0.56"
         adjustTime: number  // example: 1575018510000
       }[],
     total: number  // example: 1
    }>;
  
  
  adjustLTVGetFlexibleLoanLTVAdjustmentHistory(...args : any) {
      return this._sendRequest("/sapi/v1/loan/flexible/ltv/adjustment/history", "GET", "USER_DATA", false, args, ["loanCoin", "collateralCoin", "startTime", "endTime", "current", "limit", "recvWindow", "timestamp"], "adjustLTVGetFlexibleLoanLTVAdjustmentHistory");
  }
  
  
  /** Get Flexible Loan Assets Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-loan-assets-data-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/loanable/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} loanCoin
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFlexibleLoanAssetsData(loanCoin? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFlexibleLoanAssetsData"]>;
  
  
  /** Get Flexible Loan Assets Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-loan-assets-data-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/loanable/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} options.loanCoin
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFlexibleLoanAssetsData(options? : { loanCoin? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         loanCoin: string,  // example: "BUSD"
         flexibleInterestRate: NumberString,  // example: "0.00000491"
         flexibleMinLimit: NumberString,  // example: "100"
         flexibleMaxLimit: NumberString  // example: "1000000"
       }[],
     total: number  // example: 1
    }>;
  
  
  getFlexibleLoanAssetsData(...args : any) {
      return this._sendRequest("/sapi/v1/loan/flexible/loanable/data", "GET", "USER_DATA", false, args, ["loanCoin", "recvWindow", "timestamp"], "getFlexibleLoanAssetsData");
  }
  
  
  /** Get Flexible Loan Collateral Assets Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-loan-collateral-assets-data-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/collateral/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} collateralCoin
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFlexibleLoanCollateralAssetsData(collateralCoin? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFlexibleLoanCollateralAssetsData"]>;
  
  
  /** Get Flexible Loan Collateral Assets Data (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-flexible-loan-collateral-assets-data-user_data}
   * 
   * Please switch to:
   * 
   * EndPoint: /sapi/v1/loan/flexible/collateral/data
   * 
   * Weight(IP): 400
   * 
   * @param {string} options.collateralCoin
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFlexibleLoanCollateralAssetsData(options? : { collateralCoin? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         collateralCoin: string,  // example: "BNB"
         initialLTV: NumberString,  // example: "0.65"
         marginCallLTV: NumberString,  // example: "0.75"
         liquidationLTV: NumberString,  // example: "0.83"
         maxLimit: NumberString  // example: "1000000"
       }[],
     total: number  // example: 1
    }>;
  
  
  getFlexibleLoanCollateralAssetsData(...args : any) {
      return this._sendRequest("/sapi/v1/loan/flexible/collateral/data", "GET", "USER_DATA", false, args, ["collateralCoin", "recvWindow", "timestamp"], "getFlexibleLoanCollateralAssetsData");
  }
  
  
  
  //***** Copy Trading Endpoints *****
  
  
  /** Get Futures Lead Trader Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-futures-lead-trader-status-user_data}
   * 
   * EndPoint: /sapi/v1/copyTrading/futures/userStatus
   * 
   * Weight(UID): 20
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFuturesLeadTraderStatus(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFuturesLeadTraderStatus"]>;
  
  
  /** Get Futures Lead Trader Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-futures-lead-trader-status-user_data}
   * 
   * EndPoint: /sapi/v1/copyTrading/futures/userStatus
   * 
   * Weight(UID): 20
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFuturesLeadTraderStatus(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
       isLeadTrader: boolean,  // example: true
       time: number  // example: 1717382310843
     },
     success: boolean  // example: true
    }>;
  
  
  getFuturesLeadTraderStatus(...args : any) {
      return this._sendRequest("/sapi/v1/copyTrading/futures/userStatus", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "getFuturesLeadTraderStatus");
  }
  
  
  /** Get Futures Lead Trading Symbol Whitelist(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-futures-lead-trading-symbol-whitelist-user_data}
   * 
   * EndPoint: /sapi/v1/copyTrading/futures/leadSymbol
   * 
   * Weight(UID): 20
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getFuturesLeadTradingSymbolWhitelist(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getFuturesLeadTradingSymbolWhitelist"]>;
  
  
  /** Get Futures Lead Trading Symbol Whitelist(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-futures-lead-trading-symbol-whitelist-user_data}
   * 
   * EndPoint: /sapi/v1/copyTrading/futures/leadSymbol
   * 
   * Weight(UID): 20
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getFuturesLeadTradingSymbolWhitelist(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
         symbol: string,  // example: "BTCUSDT"
         baseAsset: string,  // example: "BTC"
         quoteAsset: string  // example: "USDT"
       }[]
    }>;
  
  
  getFuturesLeadTradingSymbolWhitelist(...args : any) {
      return this._sendRequest("/sapi/v1/copyTrading/futures/leadSymbol", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "getFuturesLeadTradingSymbolWhitelist");
  }
  
  
  
  //***** Pay Endpoints *****
  
  
  /** Get Pay Trade History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-pay-trade-history-user_data}
   * 
   * EndPoint: /sapi/v1/pay/transactions
   * 
   * Weight(UID): 3000
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  default 100, max 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getPayTradeHistory(startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getPayTradeHistory"]>;
  
  
  /** Get Pay Trade History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-pay-trade-history-user_data}
   * 
   * EndPoint: /sapi/v1/pay/transactions
   * 
   * Weight(UID): 3000
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  default 100, max 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getPayTradeHistory(options? : { startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
         orderType: string,  // example: "C2C"  // Enum:PAY(C2B Merchant Acquiring Payment), PAY_REFUND(C2B Merchant Acquiring Payment,refund), C2C(C2C Transfer Payment),CRYPTO_BOX(Crypto box), CRYPTO_BOX_RF(Crypto Box, refund), C2C_HOLDING(Transfer to new Binance user), C2C_HOLDING_RF(Transfer to new Binance user,refund), PAYOUT(B2C Disbursement Payment), REMITTANCE（Send cash)
         transactionId: string,  // example: "M_P_71505104267788288"
         transactionTime: number,  // example: 1610090460133  //trade timestamp
         amount: NumberString,  // example: "23.72469206"  //order amount(up to 8 decimal places), positive is income, negative is expenditure
         currency: string,  // example: "BNB"
         walletType: number,  // example: 1  //main wallet type, 1 for funding wallet, 2 for spot wallet, 3 for fiat wallet, 4 or 6 for card payment, 5 for earn wallet
         walletTypes: number[]  // example: 1,  // array format,there are multiple values when using combination payment
         fundsDetail: {
             currency: string,  // example: "USDT"  //asset
             amount: NumberString,  // example: "1.2"
             walletAssetCost: (
               {
                 "1": NumberString
               } |
               {
                 "2": NumberString
               }
             )[]
           }[],
         payerInfo: {
           name: string,  // example: "Jack"  //nickname or merchant name
           type: string,  // example: "USER"  //account type,USER for personal,MERCHANT for merchant
           binanceId: NumberString,  // example: "12345678"  //binance uid
           accountId: NumberString  // example: "67736251"  //binance pay id
         },
         receiverInfo: {
           name: string,  // example: "Alan"  //nickname or merchant name
           type: string,  // example: "MERCHANT"  //account type,USER for personal,MERCHANT for merchant
           email: string,  // example: "alan@binance.com"  //email
           binanceId: NumberString,  // example: "34355667"  //binance uid
           accountId: NumberString,  // example: "21326891"  //binance pay id
           countryCode: NumberString,  // example: "1"  //International area code
           phoneNumber: NumberString,  // example: "8057651210"
           mobileCode: string,  // example: "US"  //country code
           extend: {
             institutionName: string,  // example: ""
             cardNumber: string,  // example: ""
             digitalWalletId: string  // example: ""
           }
         }
       }[],
     success: boolean  // example: true
    }>;
  
  
  getPayTradeHistory(...args : any) {
      return this._sendRequest("/sapi/v1/pay/transactions", "GET", "USER_DATA", false, args, ["startTime", "endTime", "limit", "recvWindow", "timestamp"], "getPayTradeHistory");
  }
  
  
  
  //***** Convert Endpoints *****
  
  
  /** List All Convert Pairs
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#list-all-convert-pairs}
   * 
   * Query for all convertible token pairs and the tokens’ respective upper/lower limits
   * 
   * EndPoint: /sapi/v1/convert/exchangeInfo
   * 
   * Weight(IP): 20
   * 
   * @param {string} fromAsset  -  User spends coin
   * @param {string} toAsset  -  User receives coin
   */
  listAllConvertPairs(fromAsset? :string, toAsset? :string)  : ReturnType<MyBinanceClient["listAllConvertPairs"]>;
  
  
  /** List All Convert Pairs
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#list-all-convert-pairs}
   * 
   * Query for all convertible token pairs and the tokens’ respective upper/lower limits
   * 
   * EndPoint: /sapi/v1/convert/exchangeInfo
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.fromAsset  -  User spends coin
   * @param {string} options.toAsset  -  User receives coin
   */
  listAllConvertPairs(options? : { fromAsset? :string, toAsset? :string })
  : Promise<{
       fromAsset: string,  // example: "BTC"
       toAsset: string,  // example: "USDT"
       fromAssetMinAmount: NumberString,  // example: "0.0004"
       fromAssetMaxAmount: NumberString,  // example: "50"
       toAssetMinAmount: NumberString,  // example: "20"
       toAssetMaxAmount: NumberString,  // example: "2500000"
       fromIsBase: string  // example: "True"
     }[]>;
  
  
  listAllConvertPairs(...args : any) {
      return this._sendRequest("/sapi/v1/convert/exchangeInfo", "GET", "", false, args, ["fromAsset", "toAsset"], "listAllConvertPairs");
  }
  
  
  /** Query order quantity precision per asset (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-order-quantity-precision-per-asset-user_data}
   * 
   * Query for supported asset’s precision information
   * 
   * EndPoint: /sapi/v1/convert/assetInfo
   * 
   * Weight(IP): 100
   * 
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  queryOrderQuantityPrecisionPerAsset(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["queryOrderQuantityPrecisionPerAsset"]>;
  
  
  /** Query order quantity precision per asset (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-order-quantity-precision-per-asset-user_data}
   * 
   * Query for supported asset’s precision information
   * 
   * EndPoint: /sapi/v1/convert/assetInfo
   * 
   * Weight(IP): 100
   * 
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  queryOrderQuantityPrecisionPerAsset(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       asset: string,  // example: "BTC"
       fraction: number  // example: 8
     }[]>;
  
  
  queryOrderQuantityPrecisionPerAsset(...args : any) {
      return this._sendRequest("/sapi/v1/convert/assetInfo", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryOrderQuantityPrecisionPerAsset");
  }
  
  
  /** Send quote request (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#send-quote-request-user_data}
   * 
   * Request a quote for the requested token pairs
   * 
   * EndPoint: /sapi/v1/convert/getQuote
   * 
   * Weight(UID): 200
   * 
   * @param {string} fromAsset
   * @param {string} toAsset
   * @param {DECIMAL} fromAmount  -  When specified, it is the amount you will be debited after the conversion
   * @param {DECIMAL} toAmount  -  When specified, it is the amount you will be credited after the conversion
   * @param {"SPOT"|"FUNDING"} walletType  -  SPOT or FUNDING. Default is SPOT
   * @param {"10s"|"30s"|"1m"|"2m"} validTime  -  10s, 30s, 1m, 2m, default 10s
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  sendQuoteRequest(fromAsset :string, toAsset :string, fromAmount :DECIMAL, toAmount :DECIMAL, walletType? :"SPOT"|"FUNDING", validTime? :"10s"|"30s"|"1m"|"2m", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["sendQuoteRequest"]>;
  
  
  /** Send quote request (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#send-quote-request-user_data}
   * 
   * Request a quote for the requested token pairs
   * 
   * EndPoint: /sapi/v1/convert/getQuote
   * 
   * Weight(UID): 200
   * 
   * @param {string} options.fromAsset
   * @param {string} options.toAsset
   * @param {DECIMAL} options.fromAmount  -  When specified, it is the amount you will be debited after the conversion
   * @param {DECIMAL} options.toAmount  -  When specified, it is the amount you will be credited after the conversion
   * @param {"SPOT"|"FUNDING"} options.walletType  -  SPOT or FUNDING. Default is SPOT
   * @param {"10s"|"30s"|"1m"|"2m"} options.validTime  -  10s, 30s, 1m, 2m, default 10s
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  sendQuoteRequest(options : { fromAsset :string, toAsset :string, fromAmount :DECIMAL, toAmount :DECIMAL, walletType? :"SPOT"|"FUNDING", validTime? :"10s"|"30s"|"1m"|"2m", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     quoteId: NumberString,  // example: "12415572564"
     ratio: NumberString,  // example: "38163.7"
     inverseRatio: NumberString,  // example: "0.0000262"
     validTimestamp: number,  // example: 1623319461670
     toAmount: NumberString,  // example: "3816.37"
     fromAmount: NumberString  // example: "0.1"
    }>;
  
  
  sendQuoteRequest(...args : any) {
      return this._sendRequest("/sapi/v1/convert/getQuote", "POST", "USER_DATA", false, args, ["fromAsset", "toAsset", "fromAmount", "toAmount", "walletType", "validTime", "recvWindow", "timestamp"], "sendQuoteRequest");
  }
  
  
  /** Accept Quote (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#accept-quote-trade}
   * 
   * Accept the offered quote by quote ID.
   * 
   * EndPoint: /sapi/v1/convert/acceptQuote
   * 
   * Weight(UID): 500
   * 
   * @param {string} quoteId
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  acceptQuote(quoteId :string, recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["acceptQuote"]>;
  
  
  /** Accept Quote (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#accept-quote-trade}
   * 
   * Accept the offered quote by quote ID.
   * 
   * EndPoint: /sapi/v1/convert/acceptQuote
   * 
   * Weight(UID): 500
   * 
   * @param {string} options.quoteId
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  acceptQuote(options : { quoteId :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderId: NumberString,  // example: "933256278426274426"
     createTime: number,  // example: 1623381330472
     orderStatus: string  // example: "PROCESS"  //PROCESS/ACCEPT_SUCCESS/SUCCESS/FAIL
    }>;
  
  
  acceptQuote(...args : any) {
      return this._sendRequest("/sapi/v1/convert/acceptQuote", "POST", "TRADE", false, args, ["quoteId", "recvWindow", "timestamp"], "acceptQuote");
  }
  
  
  /** Order status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#order-status-user_data}
   * 
   * Query order status by order ID.
   * 
   * EndPoint: /sapi/v1/convert/orderStatus
   * 
   * Weight(UID): 100
   * 
   * @param {string} orderId  -  Either orderId or quoteId is required
   * @param {string} quoteId  -  Either orderId or quoteId is required
   */
  orderStatus(orderId? :string, quoteId? :string)  : ReturnType<MyBinanceClient["orderStatus"]>;
  
  
  /** Order status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#order-status-user_data}
   * 
   * Query order status by order ID.
   * 
   * EndPoint: /sapi/v1/convert/orderStatus
   * 
   * Weight(UID): 100
   * 
   * @param {string} options.orderId  -  Either orderId or quoteId is required
   * @param {string} options.quoteId  -  Either orderId or quoteId is required
   */
  orderStatus(options? : { orderId? :string, quoteId? :string })
  : Promise<{
     orderId: number,  // example: 933256278426274400
     orderStatus: string,  // example: "SUCCESS"
     fromAsset: string,  // example: "BTC"
     fromAmount: NumberString,  // example: "0.00054414"
     toAsset: string,  // example: "USDT"
     toAmount: NumberString,  // example: "20"
     ratio: NumberString,  // example: "36755"
     inverseRatio: NumberString,  // example: "0.00002721"
     createTime: number  // example: 1623381330472
    }>;
  
  
  orderStatus(...args : any) {
      return this._sendRequest("/sapi/v1/convert/orderStatus", "GET", "USER_DATA", false, args, ["orderId", "quoteId"], "orderStatus");
  }
  
  
  /** Place limit order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#place-limit-order-user_data}
   * 
   * Enable users to place a limit order
   * 
   * EndPoint: /sapi/v1/convert/limit/placeOrder
   * 
   * Weight(UID): 500
   * 
   * @param {string} baseAsset  -  base asset (use the response fromIsBase from GET /sapi/v1/convert/exchangeInfo api to check which one is baseAsset )
   * @param {string} quoteAsset  -  quote asset
   * @param {DECIMAL} limitPrice  -  Symbol limit price (from baseAsset to quoteAsset)
   * @param {DECIMAL} baseAmount  -  Base asset amount.  (One of baseAmount or quoteAmount is required)
   * @param {DECIMAL} quoteAmount  -  Quote asset amount.  (One of baseAmount or quoteAmount is required)
   * @param {OrderSide} side  -  BUY or SELL
   * @param {ENUM} walletType  -  SPOT or FUNDING or SPOT_FUNDING.  It is to use which type of assets. Default is SPOT.
   * @param {ENUM} expiredType  -  1_D, 3_D, 7_D, 30_D  (D means day)
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  placeLimitOrder(baseAsset :string, quoteAsset :string, limitPrice :DECIMAL, baseAmount :DECIMAL|undefined, quoteAmount :DECIMAL|undefined, side :OrderSide, walletType :ENUM|undefined, expiredType :ENUM, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["placeLimitOrder"]>;
  
  
  /** Place limit order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#place-limit-order-user_data}
   * 
   * Enable users to place a limit order
   * 
   * EndPoint: /sapi/v1/convert/limit/placeOrder
   * 
   * Weight(UID): 500
   * 
   * @param {string} options.baseAsset  -  base asset (use the response fromIsBase from GET /sapi/v1/convert/exchangeInfo api to check which one is baseAsset )
   * @param {string} options.quoteAsset  -  quote asset
   * @param {DECIMAL} options.limitPrice  -  Symbol limit price (from baseAsset to quoteAsset)
   * @param {DECIMAL} options.baseAmount  -  Base asset amount.  (One of baseAmount or quoteAmount is required)
   * @param {DECIMAL} options.quoteAmount  -  Quote asset amount.  (One of baseAmount or quoteAmount is required)
   * @param {OrderSide} options.side  -  BUY or SELL
   * @param {ENUM} options.walletType  -  SPOT or FUNDING or SPOT_FUNDING.  It is to use which type of assets. Default is SPOT.
   * @param {ENUM} options.expiredType  -  1_D, 3_D, 7_D, 30_D  (D means day)
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  placeLimitOrder(options : { baseAsset :string, quoteAsset :string, limitPrice :DECIMAL, baseAmount? :DECIMAL, quoteAmount? :DECIMAL, side :OrderSide, walletType? :ENUM, expiredType :ENUM, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderId: number,  // example: 1603680255057330400
     status: string  // example: "PROCESS"
    }>;
  
  
  placeLimitOrder(...args : any) {
      return this._sendRequest("/sapi/v1/convert/limit/placeOrder", "POST", "USER_DATA", false, args, ["baseAsset", "quoteAsset", "limitPrice", "baseAmount", "quoteAmount", "side", "walletType", "expiredType", "recvWindow", "timestamp"], "placeLimitOrder");
  }
  
  
  /** Cancel limit order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-limit-order-user_data}
   * 
   * Enable users to cancel a limit order
   * 
   * EndPoint: /sapi/v1/convert/limit/cancelOrder
   * 
   * Weight(UID): 200
   * 
   * @param {LONG} orderId  -  The orderId from placeOrder api
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  cancelLimitOrder(orderId :LONG, recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["cancelLimitOrder"]>;
  
  
  /** Cancel limit order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#cancel-limit-order-user_data}
   * 
   * Enable users to cancel a limit order
   * 
   * EndPoint: /sapi/v1/convert/limit/cancelOrder
   * 
   * Weight(UID): 200
   * 
   * @param {LONG} options.orderId  -  The orderId from placeOrder api
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  cancelLimitOrder(options : { orderId :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderId: number,  // example: 1603680255057330400
     status: string  // example: "CANCELED"
    }>;
  
  
  cancelLimitOrder(...args : any) {
      return this._sendRequest("/sapi/v1/convert/limit/cancelOrder", "POST", "USER_DATA", false, args, ["orderId", "recvWindow", "timestamp"], "cancelLimitOrder");
  }
  
  
  /** Query limit open orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-limit-open-orders-user_data}
   * 
   * Enable users to query for all existing limit orders
   * 
   * EndPoint: /sapi/v1/convert/limit/queryOpenOrders
   * 
   * Weight(UID): 3000
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  queryLimitOpenOrders(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["queryLimitOpenOrders"]>;
  
  
  /** Query limit open orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#query-limit-open-orders-user_data}
   * 
   * Enable users to query for all existing limit orders
   * 
   * EndPoint: /sapi/v1/convert/limit/queryOpenOrders
   * 
   * Weight(UID): 3000
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  queryLimitOpenOrders(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     list: {
         quoteId: string,  // example: "18sdf87kh9df"
         orderId: number,  // example: 1150901289839
         orderStatus: string,  // example: "SUCCESS"
         fromAsset: string,  // example: "BNB"
         fromAmount: NumberString,  // example: "10"
         toAsset: string,  // example: "USDT"
         toAmount: NumberString,  // example: "2317.89"
         ratio: NumberString,  // example: "231.789"
         inverseRatio: NumberString,  // example: "0.00431427"
         createTime: number,  // example: 1614089498000
         expiredTimestamp: number  // example: 1614099498000
       }[]
    }>;
  
  
  queryLimitOpenOrders(...args : any) {
      return this._sendRequest("/sapi/v1/convert/limit/queryOpenOrders", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "queryLimitOpenOrders");
  }
  
  
  /** Get Convert Trade History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-convert-trade-history-user_data}
   * 
   * EndPoint: /sapi/v1/convert/tradeFlow
   * 
   * Weight(UID): 3000
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 100, Max 1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getConvertTradeHistory(startTime :LONG, endTime :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getConvertTradeHistory"]>;
  
  
  /** Get Convert Trade History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-convert-trade-history-user_data}
   * 
   * EndPoint: /sapi/v1/convert/tradeFlow
   * 
   * Weight(UID): 3000
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 100, Max 1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getConvertTradeHistory(options : { startTime :LONG, endTime :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     list: {
         quoteId: string,  // example: "f3b91c525b2644c7bc1e1cd31b6e1aa6"
         orderId: number,  // example: 940708407462087200
         orderStatus: string,  // example: "SUCCESS"  // order status
         fromAsset: string,  // example: "USDT"  // from asset
         fromAmount: NumberString,  // example: "20"  // from amount
         toAsset: string,  // example: "BNB"  // to asset
         toAmount: NumberString,  // example: "0.06154036"  // to amount
         ratio: NumberString,  // example: "0.00307702"  // price ratio
         inverseRatio: NumberString,  // example: "324.99"  // inverse price
         createTime: number  // example: 1624248872184
       }[],
     startTime: number,  // example: 1623824139000
     endTime: number,  // example: 1626416139000
     limit: number,  // example: 100
     moreData: boolean  // example: false
    }>;
  
  
  getConvertTradeHistory(...args : any) {
      return this._sendRequest("/sapi/v1/convert/tradeFlow", "GET", "USER_DATA", false, args, ["startTime", "endTime", "limit", "recvWindow", "timestamp"], "getConvertTradeHistory");
  }
  
  
  
  //***** Rebate Endpoints *****
  
  
  /** Get Spot Rebate History Records (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-spot-rebate-history-records-user_data}
   * 
   * EndPoint: /sapi/v1/rebate/taxQuery
   * 
   * Weight(UID): 12000
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} page  -  Default 1
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getSpotRebateHistoryRecords(startTime? :LONG, endTime? :LONG, page? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getSpotRebateHistoryRecords"]>;
  
  
  /** Get Spot Rebate History Records (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-spot-rebate-history-records-user_data}
   * 
   * EndPoint: /sapi/v1/rebate/taxQuery
   * 
   * Weight(UID): 12000
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.page  -  Default 1
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getSpotRebateHistoryRecords(options? : { startTime? :LONG, endTime? :LONG, page? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     status: string,  // example: "OK"
     type: string,  // example: "GENERAL"
     code: NumberString,  // example: "000000000"
     data: {
       page: number,  // example: 1  // current page
       totalRecords: number,  // example: 2  // total records
       totalPageNum: number,  // example: 1  // total pages
       data: {
           asset: string,  // example: "USDT"  // rebate asset
           type: number,  // example: 1  // rebate type:1 is commission rebate,2 is referral kickback
           amount: NumberString,  // example: "0.0001126"
           updateTime: number  // example: 1637651320000
         }[]
     }
    }>;
  
  
  getSpotRebateHistoryRecords(...args : any) {
      return this._sendRequest("/sapi/v1/rebate/taxQuery", "GET", "USER_DATA", false, args, ["startTime", "endTime", "page", "recvWindow", "timestamp"], "getSpotRebateHistoryRecords");
  }
  
  
  
  //***** NFT Endpoints *****
  
  
  /** Get NFT Transaction History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-nft-transaction-history-user_data}
   * 
   * EndPoint: /sapi/v1/nft/history/transactions
   * 
   * Weight(UID): 3000
   * 
   * @param {INT} orderType  -  0: purchase order, 1: sell order, 2: royalty income, 3: primary market order, 4: mint fee
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 50, Max 50
   * @param {INT} page  -  Default 1
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getNFTTransactionHistory(orderType :INT, startTime? :LONG, endTime? :LONG, limit? :INT, page? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getNFTTransactionHistory"]>;
  
  
  /** Get NFT Transaction History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-nft-transaction-history-user_data}
   * 
   * EndPoint: /sapi/v1/nft/history/transactions
   * 
   * Weight(UID): 3000
   * 
   * @param {INT} options.orderType  -  0: purchase order, 1: sell order, 2: royalty income, 3: primary market order, 4: mint fee
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 50, Max 50
   * @param {INT} options.page  -  Default 1
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getNFTTransactionHistory(options : { orderType :INT, startTime? :LONG, endTime? :LONG, limit? :INT, page? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 2  //total records
     list: (
       {
         orderNo: string,  // example: "1_470502070600699904"  // 0: purchase order, 1: sell order, 2: royalty income, 3: primary market order, 4: mint fee
         tokens: {
             network: string,  // example: "BSC"  // NFT Network
             tokenId: NumberString,  // example: "216000000496"  // NFT Token ID
             contractAddress: string  // example: "MYSTERY_BOX0000087"  // NFT Contract Address
           }[],
         tradeTime: number,  // example: 1626941236000
         tradeAmount: NumberString,  // example: "19.60000000"
         tradeCurrency: string  // example: "BNB"
       } |
       {
         orderNo: string,  // example: "1_488306442479116288"
         tokens: {
             network: string,  // example: "BSC"
             tokenId: NumberString,  // example: "132900000007"
             contractAddress: NumberString  // example: "0xAf12111a592e408DAbC740849fcd5e68629D9fb6"
           }[],
         tradeTime: number,  // example: 1631186130000
         tradeAmount: NumberString,  // example: "192.00000000"
         tradeCurrency: string  // example: "BNB"
       }
     )[]
    }>;
  
  
  getNFTTransactionHistory(...args : any) {
      return this._sendRequest("/sapi/v1/nft/history/transactions", "GET", "USER_DATA", false, args, ["orderType", "startTime", "endTime", "limit", "page", "recvWindow", "timestamp"], "getNFTTransactionHistory");
  }
  
  
  /** Get NFT Deposit History(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-nft-deposit-history-user_data}
   * 
   * EndPoint: /sapi/v1/nft/history/deposit
   * 
   * Weight(UID): 3000
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 50, Max 50
   * @param {INT} page  -  Default 1
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getNFTDepositHistory(startTime? :LONG, endTime? :LONG, limit? :INT, page? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getNFTDepositHistory"]>;
  
  
  /** Get NFT Deposit History(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-nft-deposit-history-user_data}
   * 
   * EndPoint: /sapi/v1/nft/history/deposit
   * 
   * Weight(UID): 3000
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 50, Max 50
   * @param {INT} options.page  -  Default 1
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getNFTDepositHistory(options? : { startTime? :LONG, endTime? :LONG, limit? :INT, page? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 2
     list: {
         network: string,  // example: "ETH"  // NFT Network
         txID: null,  // example: null  // Transaction ID
         contractAdrress: NumberString,  // example: "0xe507c961ee127d4439977a61af39c34eafee0dc6"  // NFT Contract Address
         tokenId: NumberString,  // example: "10014"  // NFT Token ID
         timestamp: number  // example: 1629986047000
       }[]
    }>;
  
  
  getNFTDepositHistory(...args : any) {
      return this._sendRequest("/sapi/v1/nft/history/deposit", "GET", "USER_DATA", false, args, ["startTime", "endTime", "limit", "page", "recvWindow", "timestamp"], "getNFTDepositHistory");
  }
  
  
  /** Get NFT Withdraw History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-nft-withdraw-history-user_data}
   * 
   * EndPoint: /sapi/v1/nft/history/withdraw
   * 
   * Weight(UID): 3000
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 50, Max 50
   * @param {INT} page  -  Default 1
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getNFTWithdrawHistory(startTime? :LONG, endTime? :LONG, limit? :INT, page? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["getNFTWithdrawHistory"]>;
  
  
  /** Get NFT Withdraw History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-nft-withdraw-history-user_data}
   * 
   * EndPoint: /sapi/v1/nft/history/withdraw
   * 
   * Weight(UID): 3000
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 50, Max 50
   * @param {INT} options.page  -  Default 1
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getNFTWithdrawHistory(options? : { startTime? :LONG, endTime? :LONG, limit? :INT, page? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 178
     list: {
         network: string,  // example: "ETH"
         txID: NumberString,  // example: "0x2be5eed31d787fdb4880bc631c8e76bdfb6150e137f5cf1732e0416ea206f57f"
         contractAdrress: NumberString,  // example: "0xe507c961ee127d4439977a61af39c34eafee0dc6"  // NFT Contract Address
         tokenId: NumberString,  // example: "1000001247"  // NFT Token ID
         timestamp: number,  // example: 1633674433000
         fee: number,  // example: 0.1  // Withdraw Fee
         feeAsset: string  // example: "ETH"  // Asset
       }[]
    }>;
  
  
  getNFTWithdrawHistory(...args : any) {
      return this._sendRequest("/sapi/v1/nft/history/withdraw", "GET", "USER_DATA", false, args, ["startTime", "endTime", "limit", "page", "recvWindow", "timestamp"], "getNFTWithdrawHistory");
  }
  
  
  /** Get NFT Asset (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-nft-asset-user_data}
   * 
   * EndPoint: /sapi/v1/nft/user/getAsset
   * 
   * Weight(UID): 3000
   * 
   * @param {INT} limit  -  Default 50, Max 50
   * @param {INT} page  -  Default 1
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  getNFTAsset(limit? :INT, page? :INT, recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["getNFTAsset"]>;
  
  
  /** Get NFT Asset (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#get-nft-asset-user_data}
   * 
   * EndPoint: /sapi/v1/nft/user/getAsset
   * 
   * Weight(UID): 3000
   * 
   * @param {INT} options.limit  -  Default 50, Max 50
   * @param {INT} options.page  -  Default 1
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  getNFTAsset(options? : { limit? :INT, page? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     total: number,  // example: 347
     list: {
         network: string,  // example: "BSC"  // NFT Network
         contractAddress: string,  // example: "REGULAR11234567891779"  // NFT Contract Address
         tokenId: NumberString  // example: "100900000017"  // NFT Token ID
       }[]
    }>;
  
  
  getNFTAsset(...args : any) {
      return this._sendRequest("/sapi/v1/nft/user/getAsset", "GET", "USER_DATA", false, args, ["limit", "page", "recvWindow", "timestamp"], "getNFTAsset");
  }
  
  
  
  //***** Binance Gift Card Endpoints *****
  
  
  /** Create a single-token gift card (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#create-a-single-token-gift-card-user_data}
   * 
   * This API is for creating a Binance Gift Card.
   * 
   * EndPoint: /sapi/v1/giftcard/createCode
   * 
   * Weight(IP): 1
   * 
   * @param {string} token  -  The token type contained in the Binance Gift Card
   * @param {DOUBLE} amount  -  The amount of the token contained in the Binance Gift Card
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  createASingleTokenGiftCard(token :string, amount :DOUBLE, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["createASingleTokenGiftCard"]>;
  
  
  /** Create a single-token gift card (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#create-a-single-token-gift-card-user_data}
   * 
   * This API is for creating a Binance Gift Card.
   * 
   * EndPoint: /sapi/v1/giftcard/createCode
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.token  -  The token type contained in the Binance Gift Card
   * @param {DOUBLE} options.amount  -  The amount of the token contained in the Binance Gift Card
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  createASingleTokenGiftCard(options : { token :string, amount :DOUBLE, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
       referenceNo: NumberString,  // example: "0033002144060553"
       code: string,  // example: "6H9EKF5ECCWFBHGE"
       expiredTime: number  // example: 1727417154000
     },
     success: boolean  // example: true
    }>;
  
  
  createASingleTokenGiftCard(...args : any) {
      return this._sendRequest("/sapi/v1/giftcard/createCode", "POST", "USER_DATA", false, args, ["token", "amount", "recvWindow", "timestamp"], "createASingleTokenGiftCard");
  }
  
  
  /** Create a dual-token gift card (fixed value, discount feature) (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#create-a-dual-token-gift-card-fixed-value-discount-feature-trade}
   * 
   * EndPoint: /sapi/v1/giftcard/buyCode
   * 
   * Weight(IP): 1
   * 
   * @param {string} baseToken  -  The token you want to pay, example: BUSD
   * @param {string} faceToken  -  The token you want to buy, example: BNB. If faceToken = baseToken, it's the same as createCode endpoint.
   * @param {DOUBLE} baseTokenAmount  -  The base token asset quantity, example : 1.002
   * @param {DOUBLE} discount  -  Stablecoin-denominated card discount percentage, Example: 1 for 1% discount. Scale should be less than 6.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  createADualTokenGiftCardFixedValueDiscountFeature(baseToken :string, faceToken :string, baseTokenAmount :DOUBLE, discount? :DOUBLE, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["createADualTokenGiftCardFixedValueDiscountFeature"]>;
  
  
  /** Create a dual-token gift card (fixed value, discount feature) (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#create-a-dual-token-gift-card-fixed-value-discount-feature-trade}
   * 
   * EndPoint: /sapi/v1/giftcard/buyCode
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.baseToken  -  The token you want to pay, example: BUSD
   * @param {string} options.faceToken  -  The token you want to buy, example: BNB. If faceToken = baseToken, it's the same as createCode endpoint.
   * @param {DOUBLE} options.baseTokenAmount  -  The base token asset quantity, example : 1.002
   * @param {DOUBLE} options.discount  -  Stablecoin-denominated card discount percentage, Example: 1 for 1% discount. Scale should be less than 6.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  createADualTokenGiftCardFixedValueDiscountFeature(options : { baseToken :string, faceToken :string, baseTokenAmount :DOUBLE, discount? :DOUBLE, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
       referenceNo: NumberString,  // example: "0033002144060553"
       code: string,  // example: "6H9EKF5ECCWFBHGE"
       expiredTime: number  // example: 1727417154000
     },
     success: boolean  // example: true
    }>;
  
  
  createADualTokenGiftCardFixedValueDiscountFeature(...args : any) {
      return this._sendRequest("/sapi/v1/giftcard/buyCode", "POST", "TRADE", false, args, ["baseToken", "faceToken", "baseTokenAmount", "discount", "recvWindow", "timestamp"], "createADualTokenGiftCardFixedValueDiscountFeature");
  }
  
  
  /** Redeem a Binance Gift Card (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#redeem-a-binance-gift-card-user_data}
   * 
   * This API is for redeeming a Binance Gift Card
   * 
   * EndPoint: /sapi/v1/giftcard/redeemCode
   * 
   * Weight(IP): 1
   * 
   * @param {string} code  -  Redemption code of Binance Gift Card to be redeemed, supports both Plaintext & Encrypted code.
   * @param {string} externalUid  -  Each external unique ID represents a unique user on the partner platform. The function helps you to identify the redemption behavior of different users, such as redemption frequency and amount. It also helps risk and limit control of a single account, such as daily limit on redemption volume, frequency, and incorrect number of entries. This will also prevent a single user account reach the partner's daily redemption limits. We strongly recommend you to use this feature and transfer us the User ID of your users if you have different users redeeming Binance Gift Cards on your platform. To protect user data privacy, you may choose to transfer the user id in any desired format (max. 400 characters).
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  redeemABinanceGiftCard(code :string, externalUid? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["redeemABinanceGiftCard"]>;
  
  
  /** Redeem a Binance Gift Card (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#redeem-a-binance-gift-card-user_data}
   * 
   * This API is for redeeming a Binance Gift Card
   * 
   * EndPoint: /sapi/v1/giftcard/redeemCode
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.code  -  Redemption code of Binance Gift Card to be redeemed, supports both Plaintext & Encrypted code.
   * @param {string} options.externalUid  -  Each external unique ID represents a unique user on the partner platform. The function helps you to identify the redemption behavior of different users, such as redemption frequency and amount. It also helps risk and limit control of a single account, such as daily limit on redemption volume, frequency, and incorrect number of entries. This will also prevent a single user account reach the partner's daily redemption limits. We strongly recommend you to use this feature and transfer us the User ID of your users if you have different users redeeming Binance Gift Cards on your platform. To protect user data privacy, you may choose to transfer the user id in any desired format (max. 400 characters).
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  redeemABinanceGiftCard(options : { code :string, externalUid? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
       referenceNo: NumberString,  // example: "0033002328060227"
       identityNo: NumberString,  // example: "10317392647411060736"
       token: string,  // example: "BNB"
       amount: NumberString  // example: "0.00000001"
     },
     success: boolean  // example: true
    }>;
  
  
  redeemABinanceGiftCard(...args : any) {
      return this._sendRequest("/sapi/v1/giftcard/redeemCode", "POST", "USER_DATA", false, args, ["code", "externalUid", "recvWindow", "timestamp"], "redeemABinanceGiftCard");
  }
  
  
  /** Verify Binance Gift Card by Gift Card Number (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#verify-binance-gift-card-by-gift-card-number-user_data}
   * 
   * This API is for verifying whether the Binance Gift Card is valid or not by entering Gift Card Number.
   * 
   * EndPoint: /sapi/v1/giftcard/verify
   * 
   * Weight(IP): 1
   * 
   * @param {string} referenceNo  -  Enter the Gift Card Number
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  verifyBinanceGiftCardByGiftCardNumber(referenceNo :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["verifyBinanceGiftCardByGiftCardNumber"]>;
  
  
  /** Verify Binance Gift Card by Gift Card Number (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#verify-binance-gift-card-by-gift-card-number-user_data}
   * 
   * This API is for verifying whether the Binance Gift Card is valid or not by entering Gift Card Number.
   * 
   * EndPoint: /sapi/v1/giftcard/verify
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.referenceNo  -  Enter the Gift Card Number
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  verifyBinanceGiftCardByGiftCardNumber(options : { referenceNo :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
       valid: boolean,  // example: true
       token: string,  // example: "BNB"  // coin
       amount: NumberString  // example: "0.00000001"  // amount
     },
     success: boolean  // example: true
    }>;
  
  
  verifyBinanceGiftCardByGiftCardNumber(...args : any) {
      return this._sendRequest("/sapi/v1/giftcard/verify", "GET", "USER_DATA", false, args, ["referenceNo", "recvWindow", "timestamp"], "verifyBinanceGiftCardByGiftCardNumber");
  }
  
  
  /** Fetch RSA Public Key (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fetch-rsa-public-key-user_data}
   * 
   * This API is for fetching the RSA Public Key.
   * This RSA Public key will be used to encrypt the card code.
   * 
   * EndPoint: /sapi/v1/giftcard/cryptography/rsa-public-key
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fetchRSAPublicKey(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["fetchRSAPublicKey"]>;
  
  
  /** Fetch RSA Public Key (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fetch-rsa-public-key-user_data}
   * 
   * This API is for fetching the RSA Public Key.
   * This RSA Public key will be used to encrypt the card code.
   * 
   * EndPoint: /sapi/v1/giftcard/cryptography/rsa-public-key
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fetchRSAPublicKey(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: string,  // example: "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCXBBVKLAc1GQ5FsIFFqOHrPTox5noBONIKr+IAedTR9FkVxq6e65updEbfdhRNkMOeYIO2i0UylrjGC0X8YSoIszmrVHeV0l06Zh1oJuZos1+7N+WLuz9JvlPaawof3GUakTxYWWCa9+8KIbLKsoKMdfS96VT+8iOXO3quMGKUmQIDAQAB"
     success: boolean  // example: true
    }>;
  
  
  fetchRSAPublicKey(...args : any) {
      return this._sendRequest("/sapi/v1/giftcard/cryptography/rsa-public-key", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "fetchRSAPublicKey");
  }
  
  
  /** Fetch Token Limit (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fetch-token-limit-user_data}
   * 
   * This API is to help you verify which tokens are available for you to create Stablecoin-Denominated gift cards as mentioned in section 2 and its’ limitation.
   * 
   * EndPoint: /sapi/v1/giftcard/buyCode/token-limit
   * 
   * Weight(IP): 1
   * 
   * @param {string} baseToken  -  The token you want to pay, example: BUSD
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fetchTokenLimit(baseToken :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fetchTokenLimit"]>;
  
  
  /** Fetch Token Limit (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/spot/en#fetch-token-limit-user_data}
   * 
   * This API is to help you verify which tokens are available for you to create Stablecoin-Denominated gift cards as mentioned in section 2 and its’ limitation.
   * 
   * EndPoint: /sapi/v1/giftcard/buyCode/token-limit
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.baseToken  -  The token you want to pay, example: BUSD
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fetchTokenLimit(options : { baseToken :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "000000"
     message: string,  // example: "success"
     data: {
         coin: string,  // example: "BNB"
         fromMin: NumberString,  // example: "0.01"
         fromMax: NumberString  // example: "1"
       }[],
     success: boolean  // example: true
    }>;
  
  
  fetchTokenLimit(...args : any) {
      return this._sendRequest("/sapi/v1/giftcard/buyCode/token-limit", "GET", "USER_DATA", false, args, ["baseToken", "recvWindow", "timestamp"], "fetchTokenLimit");
  }
  
  
  
  //======== USD FUTURES ========
  
  
  //***** Market Data Endpoints *****
  
  
  /** Test Connectivity
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#test-connectivity}
   * 
   * Test connectivity to the Rest API.
   * 
   * EndPoint: /fapi/v1/ping
   * 
   * Weight(IP): 1
   * 
   */
  fapi_testConnectivity() : Promise<{
    }> {
      return this._sendRequest("/fapi/v1/ping", "GET", "MARKET_DATA", false, [], [], "fapi_testConnectivity");
  }
  
  
  /** Check Server Time
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#check-server-time}
   * 
   * Test connectivity to the Rest API and get the current server time.
   * 
   * EndPoint: /fapi/v1/time
   * 
   * Weight(IP): 1
   * 
   */
  fapi_checkServerTime() : Promise<{
     serverTime: number  // example: 1499827319559
    }> {
      return this._sendRequest("/fapi/v1/time", "GET", "MARKET_DATA", false, [], [], "fapi_checkServerTime");
  }
  
  
  /** Exchange Information
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#exchange-information}
   * 
   * Current exchange trading rules and symbol information
   * 
   * EndPoint: /fapi/v1/exchangeInfo
   * 
   * Weight(IP): 1
   * 
   */
  fapi_exchangeInformation() : Promise<{
     exchangeFilters: unknown[],
     rateLimits: {
         interval: RateLimitInterval,  // example: "MINUTE"
         intervalNum: number,  // example: 1
         limit: number,  // example: 2400
         rateLimitType: RateLimitType  // example: "REQUEST_WEIGHT"
       }[],
     serverTime: number,  // example: 1565613908500  // Ignore please. If you want to check current server time, please check via "GET /fapi/v1/time"
     assets: (
       {
         asset: string,  // example: "BUSD"
         marginAvailable: boolean,  // example: true  // whether the asset can be used as margin in Multi-Assets mode
         autoAssetExchange: number  // example: 0  // only valid for vip2-9 users
       } |
       {
         asset: string,  // example: "BNB"
         marginAvailable: boolean,  // example: false
         autoAssetExchange: null  // example: null
       }
     )[],
     symbols: {
         symbol: string,  // example: "BLZUSDT"
         pair: string,  // example: "BLZUSDT"
         contractType: string,  // example: "PERPETUAL"
         deliveryDate: number,  // example: 4133404800000
         onboardDate: number,  // example: 1598252400000
         status: string,  // example: "TRADING"
         maintMarginPercent: NumberString,  // example: "2.5000"  // ignore
         requiredMarginPercent: NumberString,  // example: "5.0000"  // ignore
         baseAsset: string,  // example: "BLZ"
         quoteAsset: string,  // example: "USDT"
         marginAsset: string,  // example: "USDT"
         pricePrecision: number,  // example: 5  // please do not use it as tickSize
         quantityPrecision: number,  // example: 0  // please do not use it as stepSize
         baseAssetPrecision: number,  // example: 8
         quotePrecision: number,  // example: 8
         underlyingType: string,  // example: "COIN"
         underlyingSubType: string[]  // example: "STORAGE",
         settlePlan: number,  // example: 0
         triggerProtect: NumberString,  // example: "0.15"  // threshold for algo order with "priceProtect"
         filters: (
           {
             filterType: "PRICE_FILTER",  // example: "PRICE_FILTER"
             maxPrice: NumberString,  // example: "300"
             minPrice: NumberString,  // example: "0.0001"
             tickSize: NumberString  // example: "0.0001"
           } |
           {
             filterType: "LOT_SIZE",  // example: "LOT_SIZE"
             maxQty: NumberString,  // example: "10000000"
             minQty: NumberString,  // example: "1"
             stepSize: NumberString  // example: "1"
           } |
           {
             filterType: "MARKET_LOT_SIZE",  // example: "MARKET_LOT_SIZE"
             maxQty: NumberString,  // example: "590119"
             minQty: NumberString,  // example: "1"
             stepSize: NumberString  // example: "1"
           } |
           {
             filterType: "MAX_NUM_ORDERS",  // example: "MAX_NUM_ORDERS"
             limit: number  // example: 200
           } |
           {
             filterType: "MAX_NUM_ALGO_ORDERS",  // example: "MAX_NUM_ALGO_ORDERS"
             limit: number  // example: 100
           } |
           {
             filterType: "MIN_NOTIONAL",  // example: "MIN_NOTIONAL"
             notional: NumberString  // example: "5.0"
           } |
           {
             filterType: "PERCENT_PRICE",  // example: "PERCENT_PRICE"
             multiplierUp: NumberString,  // example: "1.1500"
             multiplierDown: NumberString,  // example: "0.8500"
             multiplierDecimal: number  // example: 4
           }
         )[],
         OrderType: string[]  // example: "LIMIT",
         timeInForce: TimeInForce[]  // example: "GTC",
         liquidationFee: NumberString,  // example: "0.010000"  // liquidation fee rate
         marketTakeBound: NumberString  // example: "0.30"  // the max price difference rate( from mark price) a market order can make
       }[],
     timezone: string  // example: "UTC"
    }> {
      return this._sendRequest("/fapi/v1/exchangeInfo", "GET", "MARKET_DATA", false, [], [], "fapi_exchangeInformation");
  }
  
  
  /** Order Book
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#order-book}
   * 
   * Adjusted based on the limit:
   * 
   * EndPoint: /fapi/v1/depth
   * 
   * Weight(IP): Adjusted based on the limit:
   *   Limit         Weight
   *   5, 10, 20, 50 2     
   *   100           5     
   *   500           10    
   *   1000          20    
   * 
   * @param {string} symbol
   * @param {INT} limit  -  Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
   */
  fapi_orderBook(symbol :string, limit? :INT)  : ReturnType<MyBinanceClient["fapi_orderBook"]>;
  
  
  /** Order Book
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#order-book}
   * 
   * Adjusted based on the limit:
   * 
   * EndPoint: /fapi/v1/depth
   * 
   * Weight(IP): Adjusted based on the limit:
   *   Limit         Weight
   *   5, 10, 20, 50 2     
   *   100           5     
   *   500           10    
   *   1000          20    
   * 
   * @param {string} options.symbol
   * @param {INT} options.limit  -  Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
   */
  fapi_orderBook(options : { symbol :string, limit? :INT })
  : Promise<{
     lastUpdateId: number,  // example: 1027024
     E: number,  // example: 1589436922972  // Message output time
     T: number,  // example: 1589436922959  // Transaction time
     bids: NumberString[]  // example: "4.00000000"  // PRICE[],
     asks: NumberString[]  // example: "4.00000200"[]
    }>;
  
  
  fapi_orderBook(...args : any) {
      return this._sendRequest("/fapi/v1/depth", "GET", "MARKET_DATA", false, args, ["symbol", "limit"], "fapi_orderBook");
  }
  
  
  /** Recent Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#recent-trades-list}
   * 
   * Get recent market trades
   * 
   * EndPoint: /fapi/v1/trades
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {INT} limit  -  Default 500; max 1000.
   */
  fapi_recentTradesList(symbol :string, limit? :INT)  : ReturnType<MyBinanceClient["fapi_recentTradesList"]>;
  
  
  /** Recent Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#recent-trades-list}
   * 
   * Get recent market trades
   * 
   * EndPoint: /fapi/v1/trades
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {INT} options.limit  -  Default 500; max 1000.
   */
  fapi_recentTradesList(options : { symbol :string, limit? :INT })
  : Promise<{
       id: number,  // example: 28457
       price: NumberString,  // example: "4.00000100"
       qty: NumberString,  // example: "12.00000000"
       quoteQty: NumberString,  // example: "48.00"
       time: number,  // example: 1499865549590
       isBuyerMaker: boolean  // example: true
     }[]>;
  
  
  fapi_recentTradesList(...args : any) {
      return this._sendRequest("/fapi/v1/trades", "GET", "MARKET_DATA", false, args, ["symbol", "limit"], "fapi_recentTradesList");
  }
  
  
  /** Old Trades Lookup (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#old-trades-lookup-market_data}
   * 
   * Get older market historical trades.
   * 
   * EndPoint: /fapi/v1/historicalTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} fromId  -  TradeId to fetch from. Default gets most recent trades.
   */
  fapi_oldTradesLookup(symbol :string, limit? :INT, fromId? :LONG)  : ReturnType<MyBinanceClient["fapi_oldTradesLookup"]>;
  
  
  /** Old Trades Lookup (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#old-trades-lookup-market_data}
   * 
   * Get older market historical trades.
   * 
   * EndPoint: /fapi/v1/historicalTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.fromId  -  TradeId to fetch from. Default gets most recent trades.
   */
  fapi_oldTradesLookup(options : { symbol :string, limit? :INT, fromId? :LONG })
  : Promise<{
       id: number,  // example: 28457
       price: NumberString,  // example: "4.00000100"
       qty: NumberString,  // example: "12.00000000"
       quoteQty: NumberString,  // example: "8000.00"
       time: number,  // example: 1499865549590
       isBuyerMaker: boolean  // example: true
     }[]>;
  
  
  fapi_oldTradesLookup(...args : any) {
      return this._sendRequest("/fapi/v1/historicalTrades", "GET", "MARKET_DATA", false, args, ["symbol", "limit", "fromId"], "fapi_oldTradesLookup");
  }
  
  
  /** Compressed/Aggregate Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#compressed-aggregate-trades-list}
   * 
   * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
   * 
   * EndPoint: /fapi/v1/aggTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol
   * @param {LONG} fromId  -  ID to get aggregate trades from INCLUSIVE.
   * @param {LONG} startTime  -  Timestamp in ms to get aggregate trades from INCLUSIVE.
   * @param {LONG} endTime  -  Timestamp in ms to get aggregate trades until INCLUSIVE.
   * @param {INT} limit  -  Default 500; max 1000.
   */
  fapi_compressedAggregateTradesList(symbol :string, fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["fapi_compressedAggregateTradesList"]>;
  
  
  /** Compressed/Aggregate Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#compressed-aggregate-trades-list}
   * 
   * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
   * 
   * EndPoint: /fapi/v1/aggTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol
   * @param {LONG} options.fromId  -  ID to get aggregate trades from INCLUSIVE.
   * @param {LONG} options.startTime  -  Timestamp in ms to get aggregate trades from INCLUSIVE.
   * @param {LONG} options.endTime  -  Timestamp in ms to get aggregate trades until INCLUSIVE.
   * @param {INT} options.limit  -  Default 500; max 1000.
   */
  fapi_compressedAggregateTradesList(options : { symbol :string, fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<{
       a: number,  // example: 26129  // Aggregate tradeId
       p: NumberString,  // example: "0.01633102"  // Price
       q: NumberString,  // example: "4.70443515"  // Quantity
       f: number,  // example: 27781  // First tradeId
       l: number,  // example: 27781  // Last tradeId
       T: number,  // example: 1498793709153  // Timestamp
       m: boolean  // example: true  // Was the buyer the maker?
     }[]>;
  
  
  fapi_compressedAggregateTradesList(...args : any) {
      return this._sendRequest("/fapi/v1/aggTrades", "GET", "MARKET_DATA", false, args, ["symbol", "fromId", "startTime", "endTime", "limit"], "fapi_compressedAggregateTradesList");
  }
  
  
  /** Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#kline-candlestick-data}
   * 
   * Kline/candlestick bars for a symbol.
   * Klines are uniquely identified by their open time.
   * 
   * EndPoint: /fapi/v1/klines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} symbol
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1500.
   */
  fapi_klineCandlestickData(symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["fapi_klineCandlestickData"]>;
  
  
  /** Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#kline-candlestick-data}
   * 
   * Kline/candlestick bars for a symbol.
   * Klines are uniquely identified by their open time.
   * 
   * EndPoint: /fapi/v1/klines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} options.symbol
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1500.
   */
  fapi_klineCandlestickData(options : { symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<[
       number,        // example: 1499040000000  // Open time
       NumberString,  // example: "0.01634790"  // Open
       NumberString,  // example: "0.80000000"  // High
       NumberString,  // example: "0.01575800"  // Low
       NumberString,  // example: "0.01577100"  // Close
       NumberString,  // example: "148976.11427815"  // Volume
       number,        // example: 1499644799999  // Close time
       NumberString,  // example: "2434.19055334"  // Quote asset volume
       number,        // example: 308  // Number of trades
       NumberString,  // example: "1756.87402397"  // Taker buy base asset volume
       NumberString,  // example: "28.46694368"  // Taker buy quote asset volume
       NumberString   // example: "17928899.62484339"  // Ignore.
     ][]>;
  
  
  fapi_klineCandlestickData(...args : any) {
      return this._sendRequest("/fapi/v1/klines", "GET", "MARKET_DATA", false, args, ["symbol", "interval", "startTime", "endTime", "limit"], "fapi_klineCandlestickData");
  }
  
  
  /** Continuous Contract Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#continuous-contract-kline-candlestick-data}
   * 
   * Kline/candlestick bars for a specific contract type.
   * 
   * EndPoint: /fapi/v1/continuousKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} pair
   * @param {ENUM} contractType
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1500.
   */
  fapi_continuousContractKlineCandlestickData(pair :string, contractType :ENUM, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["fapi_continuousContractKlineCandlestickData"]>;
  
  
  /** Continuous Contract Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#continuous-contract-kline-candlestick-data}
   * 
   * Kline/candlestick bars for a specific contract type.
   * 
   * EndPoint: /fapi/v1/continuousKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} options.pair
   * @param {ENUM} options.contractType
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1500.
   */
  fapi_continuousContractKlineCandlestickData(options : { pair :string, contractType :ENUM, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<[
       number,        // example: 1607444700000  // Open time
       NumberString,  // example: "18879.99"  // Open
       NumberString,  // example: "18900.00"  // High
       NumberString,  // example: "18878.98"  // Low
       NumberString,  // example: "18896.13"  // Close (or latest price)
       NumberString,  // example: "492.363"  // Volume
       number,        // example: 1607444759999  // Close time
       NumberString,  // example: "9302145.66080"  // Quote asset volume
       number,        // example: 1874  // Number of trades
       NumberString,  // example: "385.983"  // Taker buy volume
       NumberString,  // example: "7292402.33267"  // Taker buy quote asset volume
       NumberString   // example: "0"  // Ignore.
     ][]>;
  
  
  fapi_continuousContractKlineCandlestickData(...args : any) {
      return this._sendRequest("/fapi/v1/continuousKlines", "GET", "MARKET_DATA", false, args, ["pair", "contractType", "interval", "startTime", "endTime", "limit"], "fapi_continuousContractKlineCandlestickData");
  }
  
  
  /** Index Price Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#index-price-kline-candlestick-data}
   * 
   * Kline/candlestick bars for the index price of a pair.
   * 
   * EndPoint: /fapi/v1/indexPriceKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} pair
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1500.
   */
  fapi_indexPriceKlineCandlestickData(pair :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["fapi_indexPriceKlineCandlestickData"]>;
  
  
  /** Index Price Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#index-price-kline-candlestick-data}
   * 
   * Kline/candlestick bars for the index price of a pair.
   * 
   * EndPoint: /fapi/v1/indexPriceKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} options.pair
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1500.
   */
  fapi_indexPriceKlineCandlestickData(options : { pair :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<[
       number,        // example: 1591256400000  // Open time
       NumberString,  // example: "9653.69440000"  // Open
       NumberString,  // example: "9653.69640000"  // High
       NumberString,  // example: "9651.38600000"  // Low
       NumberString,  // example: "9651.55200000"  // Close (or latest price)
       NumberString,  // example: "0  "  // Ignore
       number,        // example: 1591256459999  // Close time
       NumberString,  // example: "0"  // Ignore
       number,        // example: 60  // Ignore
       NumberString,  // example: "0"  // Ignore
       NumberString,  // example: "0"  // Ignore
       NumberString   // example: "0"  // Ignore
     ][]>;
  
  
  fapi_indexPriceKlineCandlestickData(...args : any) {
      return this._sendRequest("/fapi/v1/indexPriceKlines", "GET", "MARKET_DATA", false, args, ["pair", "interval", "startTime", "endTime", "limit"], "fapi_indexPriceKlineCandlestickData");
  }
  
  
  /** Mark Price Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#mark-price-kline-candlestick-data}
   * 
   * Kline/candlestick bars for the mark price of a symbol.
   * 
   * EndPoint: /fapi/v1/markPriceKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} symbol
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1500.
   */
  fapi_markPriceKlineCandlestickData(symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["fapi_markPriceKlineCandlestickData"]>;
  
  
  /** Mark Price Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#mark-price-kline-candlestick-data}
   * 
   * Kline/candlestick bars for the mark price of a symbol.
   * 
   * EndPoint: /fapi/v1/markPriceKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} options.symbol
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1500.
   */
  fapi_markPriceKlineCandlestickData(options : { symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<[
       number,        // example: 1591256460000  // Open time
       NumberString,  // example: "9653.29201333"  // Open
       NumberString,  // example: "9654.56401333"  // High
       NumberString,  // example: "9653.07367333"  // Low
       NumberString,  // example: "9653.07367333"  // Close (or latest price)
       NumberString,  // example: "0  "  // Ignore
       number,        // example: 1591256519999  // Close time
       NumberString,  // example: "0"  // Ignore
       number,        // example: 60  // Ignore
       NumberString,  // example: "0"  // Ignore
       NumberString,  // example: "0"  // Ignore
       NumberString   // example: "0"  // Ignore
     ][]>;
  
  
  fapi_markPriceKlineCandlestickData(...args : any) {
      return this._sendRequest("/fapi/v1/markPriceKlines", "GET", "MARKET_DATA", false, args, ["symbol", "interval", "startTime", "endTime", "limit"], "fapi_markPriceKlineCandlestickData");
  }
  
  
  /** Premium index Kline Data
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#premium-index-kline-data}
   * 
   * Premium index kline bars of a symbol.
   * 
   * EndPoint: /fapi/v1/premiumIndexKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} symbol
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1500.
   */
  fapi_premiumIndexKlineData(symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["fapi_premiumIndexKlineData"]>;
  
  
  /** Premium index Kline Data
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#premium-index-kline-data}
   * 
   * Premium index kline bars of a symbol.
   * 
   * EndPoint: /fapi/v1/premiumIndexKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} options.symbol
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1500.
   */
  fapi_premiumIndexKlineData(options : { symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<[
       number,        // example: 1691603820000  // Open time
       NumberString,  // example: "-0.00042931"  // Open
       NumberString,  // example: "-0.00023641"  // High
       NumberString,  // example: "-0.00059406"  // Low
       NumberString,  // example: "-0.00043659"  // Close
       NumberString,  // example: "0"  // Ignore
       number,        // example: 1691603879999  // Close time
       NumberString,  // example: "0"  // Ignore
       number,        // example: 12  // Ignore
       NumberString,  // example: "0"  // Ignore
       NumberString,  // example: "0"  // Ignore
       NumberString   // example: "0"  // Ignore
     ][]>;
  
  
  fapi_premiumIndexKlineData(...args : any) {
      return this._sendRequest("/fapi/v1/premiumIndexKlines", "GET", "MARKET_DATA", false, args, ["symbol", "interval", "startTime", "endTime", "limit"], "fapi_premiumIndexKlineData");
  }
  
  
  /** Mark Price
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#mark-price}
   * 
   * Mark Price and Funding Rate
   * 
   * EndPoint: /fapi/v1/premiumIndex
   * 
   * Weight(IP): 1 with symbol; 10 without symbol
   * 
   * @param {string} symbol
   */
  fapi_markPrice(symbol? :string)  : ReturnType<MyBinanceClient["fapi_markPrice"]>;
  
  
  /** Mark Price
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#mark-price}
   * 
   * Mark Price and Funding Rate
   * 
   * EndPoint: /fapi/v1/premiumIndex
   * 
   * Weight(IP): 1 with symbol; 10 without symbol
   * 
   * @param {string} options.symbol
   */
  fapi_markPrice(options? : { symbol? :string })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     markPrice: NumberString,  // example: "11793.63104562"  // mark price
     indexPrice: NumberString,  // example: "11781.80495970"  // index price
     estimatedSettlePrice: NumberString,  // example: "11781.16138815"  // Estimated Settle Price, only useful in the last hour before the settlement starts.
     lastFundingRate: NumberString,  // example: "0.00038246"  // This is the Latest funding rate
     nextFundingTime: number,  // example: 1597392000000
     interestRate: NumberString,  // example: "0.00010000"
     time: number  // example: 1597370495002
    } | {  // (when symbol not sent)
       symbol: string,  // example: "BTCUSDT"
       markPrice: NumberString,  // example: "11793.63104562"  // mark price
       indexPrice: NumberString,  // example: "11781.80495970"  // index price
       estimatedSettlePrice: NumberString,  // example: "11781.16138815"  // Estimated Settle Price, only useful in the last hour before the settlement starts.
       lastFundingRate: NumberString,  // example: "0.00038246"  // This is the lastest estimated funding rate
       nextFundingTime: number,  // example: 1597392000000
       interestRate: NumberString,  // example: "0.00010000"
       time: number  // example: 1597370495002
     }[]>;
  
  
  fapi_markPrice(...args : any) {
      return this._sendRequest("/fapi/v1/premiumIndex", "GET", "MARKET_DATA", false, args, ["symbol"], "fapi_markPrice");
  }
  
  
  /** Get Funding Rate History
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-funding-rate-history}
   * 
   * EndPoint: /fapi/v1/fundingRate
   * 
   * Rate Limit: 500/5min per IP
   * 
   * @param {string} symbol
   * @param {LONG} startTime  -  Timestamp in ms to get funding rate from INCLUSIVE.
   * @param {LONG} endTime  -  Timestamp in ms to get funding rate  until INCLUSIVE.
   * @param {INT} limit  -  Default 100; max 1000
   */
  fapi_getFundingRateHistory(symbol? :string, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["fapi_getFundingRateHistory"]>;
  
  
  /** Get Funding Rate History
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-funding-rate-history}
   * 
   * EndPoint: /fapi/v1/fundingRate
   * 
   * Rate Limit: 500/5min per IP
   * 
   * @param {string} options.symbol
   * @param {LONG} options.startTime  -  Timestamp in ms to get funding rate from INCLUSIVE.
   * @param {LONG} options.endTime  -  Timestamp in ms to get funding rate  until INCLUSIVE.
   * @param {INT} options.limit  -  Default 100; max 1000
   */
  fapi_getFundingRateHistory(options? : { symbol? :string, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       fundingTime: number,  // example: 1698768000000
       fundingRate: NumberString,  // example: "0.00010000"
       markPrice: NumberString  // example: "34287.54619963"  // mark price associated with a particular funding fee charge
     }[]>;
  
  
  fapi_getFundingRateHistory(...args : any) {
      return this._sendRequest("/fapi/v1/fundingRate", "GET", "MARKET_DATA", false, args, ["symbol", "startTime", "endTime", "limit"], "fapi_getFundingRateHistory");
  }
  
  
  /** Get Funding Rate Info
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-funding-rate-info}
   * 
   * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
   * 
   * EndPoint: /fapi/v1/fundingInfo
   * 
   * Rate Limit: 500/5min per IP
   * 
   */
  fapi_getFundingRateInfo() : Promise<{
       symbol: string,  // example: "BLZUSDT"
       adjustedFundingRateCap: NumberString,  // example: "0.02500000"
       adjustedFundingRateFloor: NumberString,  // example: "-0.02500000"
       fundingIntervalHours: number,  // example: 8
       disclaimer: boolean  // example: false  // ingore
     }[]> {
      return this._sendRequest("/fapi/v1/fundingInfo", "GET", "MARKET_DATA", false, [], [], "fapi_getFundingRateInfo");
  }
  
  
  /** 24hr Ticker Price Change Statistics
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#24hr-ticker-price-change-statistics}
   * 
   * EndPoint: /fapi/v1/ticker/24hr
   * 
   * Weight(IP): 
   *   1 for a single symbol;
   *   40 when the symbol parameter is omitted
   * 
   * @param {string} symbol
   */
  fapi_tickerPriceChangeStatistics24hr(symbol? :string)
  : ReturnType<MyBinanceClient["fapi_tickerPriceChangeStatistics24hr"]>;
  
  
  /** 24hr Ticker Price Change Statistics
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#24hr-ticker-price-change-statistics}
   * 
   * EndPoint: /fapi/v1/ticker/24hr
   * 
   * Weight(IP): 
   *   1 for a single symbol;
   *   40 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol
   */
  fapi_tickerPriceChangeStatistics24hr(options? : { symbol? :string })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     priceChange: NumberString,  // example: "-94.99999800"
     priceChangePercent: NumberString,  // example: "-95.960"
     weightedAvgPrice: NumberString,  // example: "0.29628482"
     lastPrice: NumberString,  // example: "4.00000200"
     lastQty: NumberString,  // example: "200.00000000"
     openPrice: NumberString,  // example: "99.00000000"
     highPrice: NumberString,  // example: "100.00000000"
     lowPrice: NumberString,  // example: "0.10000000"
     volume: NumberString,  // example: "8913.30000000"
     quoteVolume: NumberString,  // example: "15.30000000"
     openTime: number,  // example: 1499783499040
     closeTime: number,  // example: 1499869899040
     firstId: number,  // example: 28385  // First tradeId
     lastId: number,  // example: 28460  // Last tradeId
     count: number  // example: 76  // Trade count
    } | {
       symbol: string,  // example: "BTCUSDT"
       priceChange: NumberString,  // example: "-94.99999800"
       priceChangePercent: NumberString,  // example: "-95.960"
       weightedAvgPrice: NumberString,  // example: "0.29628482"
       lastPrice: NumberString,  // example: "4.00000200"
       lastQty: NumberString,  // example: "200.00000000"
       openPrice: NumberString,  // example: "99.00000000"
       highPrice: NumberString,  // example: "100.00000000"
       lowPrice: NumberString,  // example: "0.10000000"
       volume: NumberString,  // example: "8913.30000000"
       quoteVolume: NumberString,  // example: "15.30000000"
       openTime: number,  // example: 1499783499040
       closeTime: number,  // example: 1499869899040
       firstId: number,  // example: 28385  // First tradeId
       lastId: number,  // example: 28460  // Last tradeId
       count: number  // example: 76  // Trade count
     }[]>;
  
  
  fapi_tickerPriceChangeStatistics24hr(...args : any) {
      return this._sendRequest("/fapi/v1/ticker/24hr", "GET", "MARKET_DATA", false, args, ["symbol"], "fapi_tickerPriceChangeStatistics24hr");
  }
  
  
  /** Symbol Price Ticker
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#symbol-price-ticker}
   * 
   * Latest price for a symbol or symbols.
   * 
   * EndPoint: /fapi/v1/ticker/price
   * 
   * Weight(IP): 
   *   1 for a single symbol;
   *   2 when the symbol parameter is omitted
   * 
   * @param {string} symbol
   */
  fapi_symbolPriceTicker(symbol? :string)  : ReturnType<MyBinanceClient["fapi_symbolPriceTicker"]>;
  
  
  /** Symbol Price Ticker
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#symbol-price-ticker}
   * 
   * Latest price for a symbol or symbols.
   * 
   * EndPoint: /fapi/v1/ticker/price
   * 
   * Weight(IP): 
   *   1 for a single symbol;
   *   2 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol
   */
  fapi_symbolPriceTicker(options? : { symbol? :string })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     price: NumberString,  // example: "6000.01"
     time: number  // example: 1589437530011  // Transaction time
    } | {
       symbol: string,  // example: "BTCUSDT"
       price: NumberString,  // example: "6000.01"
       time: number  // example: 1589437530011
     }[]>;
  
  
  fapi_symbolPriceTicker(...args : any) {
      return this._sendRequest("/fapi/v1/ticker/price", "GET", "MARKET_DATA", false, args, ["symbol"], "fapi_symbolPriceTicker");
  }
  
  
  /** Symbol Price Ticker V2
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#symbol-price-ticker-v2}
   * 
   * Latest price for a symbol or symbols.
   * 
   * EndPoint: /fapi/v2/ticker/price
   * 
   * Weight(IP): 
   *   with symbol 1
   *   no symbol 2
   * 
   * @param {string} symbol
   */
  fapi_symbolPriceTickerV2(symbol? :string)  : ReturnType<MyBinanceClient["fapi_symbolPriceTickerV2"]>;
  
  
  /** Symbol Price Ticker V2
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#symbol-price-ticker-v2}
   * 
   * Latest price for a symbol or symbols.
   * 
   * EndPoint: /fapi/v2/ticker/price
   * 
   * Weight(IP): 
   *   with symbol 1
   *   no symbol 2
   * 
   * @param {string} options.symbol
   */
  fapi_symbolPriceTickerV2(options? : { symbol? :string })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     price: NumberString,  // example: "6000.01"
     time: number  // example: 1589437530011  // Transaction time
    } | {
       symbol: string,  // example: "BTCUSDT"
       price: NumberString,  // example: "6000.01"
       time: number  // example: 1589437530011
     }[]>;
  
  
  fapi_symbolPriceTickerV2(...args : any) {
      return this._sendRequest("/fapi/v2/ticker/price", "GET", "MARKET_DATA", false, args, ["symbol"], "fapi_symbolPriceTickerV2");
  }
  
  
  /** Symbol Order Book Ticker
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#symbol-order-book-ticker}
   * 
   * Best price/qty on the order book for a symbol or symbols.
   * 
   * EndPoint: /fapi/v1/ticker/bookTicker
   * 
   * Weight(IP): 
   *   2 for a single symbol;
   *   5 when the symbol parameter is omitted
   * 
   * @param {string} symbol
   */
  fapi_symbolOrderBookTicker(symbol? :string)  : ReturnType<MyBinanceClient["fapi_symbolOrderBookTicker"]>;
  
  
  /** Symbol Order Book Ticker
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#symbol-order-book-ticker}
   * 
   * Best price/qty on the order book for a symbol or symbols.
   * 
   * EndPoint: /fapi/v1/ticker/bookTicker
   * 
   * Weight(IP): 
   *   2 for a single symbol;
   *   5 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol
   */
  fapi_symbolOrderBookTicker(options? : { symbol? :string })
  : Promise<{
     lastUpdateId: number,  // example: 1027024
     symbol: string,  // example: "BTCUSDT"
     bidPrice: NumberString,  // example: "4.00000000"
     bidQty: NumberString,  // example: "431.00000000"
     askPrice: NumberString,  // example: "4.00000200"
     askQty: NumberString,  // example: "9.00000000"
     time: number  // example: 1589437530011  // Transaction time
    } | {
       lastUpdateId: number,  // example: 1027024
       symbol: string,  // example: "BTCUSDT"
       bidPrice: NumberString,  // example: "4.00000000"
       bidQty: NumberString,  // example: "431.00000000"
       askPrice: NumberString,  // example: "4.00000200"
       askQty: NumberString,  // example: "9.00000000"
       time: number  // example: 1589437530011
     }[]>;
  
  
  fapi_symbolOrderBookTicker(...args : any) {
      return this._sendRequest("/fapi/v1/ticker/bookTicker", "GET", "MARKET_DATA", false, args, ["symbol"], "fapi_symbolOrderBookTicker");
  }
  
  
  /** Open Interest
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#open-interest}
   * 
   * Get present open interest of a specific symbol.
   * 
   * EndPoint: /fapi/v1/openInterest
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   */
  fapi_openInterest(symbol :string)  : ReturnType<MyBinanceClient["fapi_openInterest"]>;
  
  
  /** Open Interest
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#open-interest}
   * 
   * Get present open interest of a specific symbol.
   * 
   * EndPoint: /fapi/v1/openInterest
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   */
  fapi_openInterest(options : { symbol :string })
  : Promise<{
     openInterest: NumberString,  // example: "10659.509"
     symbol: string,  // example: "BTCUSDT"
     time: number  // example: 1589437530011  // Transaction time
    }>;
  
  
  fapi_openInterest(...args : any) {
      return this._sendRequest("/fapi/v1/openInterest", "GET", "MARKET_DATA", false, args, ["symbol"], "fapi_openInterest");
  }
  
  
  /** Quarterly Contract Settlement Price
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#quarterly-contract-settlement-price}
   * 
   * EndPoint: /futures/data/delivery-price
   * 
   * @param {string} pair  -  e.g BTCUSDT
   */
  fapi_quarterlyContractSettlementPrice(pair :string)
  : ReturnType<MyBinanceClient["fapi_quarterlyContractSettlementPrice"]>;
  
  
  /** Quarterly Contract Settlement Price
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#quarterly-contract-settlement-price}
   * 
   * EndPoint: /futures/data/delivery-price
   * 
   * @param {string} options.pair  -  e.g BTCUSDT
   */
  fapi_quarterlyContractSettlementPrice(options : { pair :string })
  : Promise<{
       deliveryTime: number,  // example: 1695945600000
       deliveryPrice: number  // example: 27103
     }[]>;
  
  
  fapi_quarterlyContractSettlementPrice(...args : any) {
      return this._sendRequest("/futures/data/delivery-price", "GET", "MARKET_DATA", false, args, ["pair"], "fapi_quarterlyContractSettlementPrice");
  }
  
  
  /** Open Interest Statistics
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#open-interest-statistics}
   * 
   * EndPoint: /futures/data/openInterestHist
   * 
   * Rate Limit: 1000/5min per IP
   * 
   * @param {string} symbol
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  default 30, max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  fapi_openInterestStatistics(symbol :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["fapi_openInterestStatistics"]>;
  
  
  /** Open Interest Statistics
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#open-interest-statistics}
   * 
   * EndPoint: /futures/data/openInterestHist
   * 
   * Rate Limit: 1000/5min per IP
   * 
   * @param {string} options.symbol
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  default 30, max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  fapi_openInterestStatistics(options : { symbol :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       sumOpenInterest: NumberString,  // example: "20403.63700000"  // total open interest
       sumOpenInterestValue: NumberString,  // example: "150570784.07809979"  // total open interest value
       timestamp: NumberString  // example: "1583127900000"
     }[]>;
  
  
  fapi_openInterestStatistics(...args : any) {
      return this._sendRequest("/futures/data/openInterestHist", "GET", "MARKET_DATA", false, args, ["symbol", "period", "limit", "startTime", "endTime"], "fapi_openInterestStatistics");
  }
  
  
  /** Top Trader Long/Short Ratio (Accounts)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#top-trader-long-short-ratio-accounts}
   * 
   * EndPoint: /futures/data/topLongShortAccountRatio
   * 
   * Rate Limit: 1000/5min per IP
   * 
   * @param {string} symbol
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  default 30, max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  fapi_topTraderLongShortAccountRatio(symbol :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["fapi_topTraderLongShortAccountRatio"]>;
  
  
  /** Top Trader Long/Short Ratio (Accounts)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#top-trader-long-short-ratio-accounts}
   * 
   * EndPoint: /futures/data/topLongShortAccountRatio
   * 
   * Rate Limit: 1000/5min per IP
   * 
   * @param {string} options.symbol
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  default 30, max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  fapi_topTraderLongShortAccountRatio(options : { symbol :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       longShortRatio: NumberString,  // example: "1.8105"  // long/short account num ratio of top traders
       longAccount: NumberString,  // example: "0.6442"  // long account num ratio of top traders
       shortAccount: NumberString,  // example: "0.3558"  // long account num ratio of top traders
       timestamp: NumberString  // example: "1583139600000"
     }[]>;
  
  
  fapi_topTraderLongShortAccountRatio(...args : any) {
      return this._sendRequest("/futures/data/topLongShortAccountRatio", "GET", "MARKET_DATA", false, args, ["symbol", "period", "limit", "startTime", "endTime"], "fapi_topTraderLongShortAccountRatio");
  }
  
  
  /** Top Trader Long/Short Ratio (Positions)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#top-trader-long-short-ratio-positions}
   * 
   * EndPoint: /futures/data/topLongShortPositionRatio
   * 
   * Rate Limit: 1000/5min per IP
   * 
   * @param {string} symbol
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  default 30, max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  fapi_topTraderLongShortPositionRatio(symbol :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["fapi_topTraderLongShortPositionRatio"]>;
  
  
  /** Top Trader Long/Short Ratio (Positions)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#top-trader-long-short-ratio-positions}
   * 
   * EndPoint: /futures/data/topLongShortPositionRatio
   * 
   * Rate Limit: 1000/5min per IP
   * 
   * @param {string} options.symbol
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  default 30, max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  fapi_topTraderLongShortPositionRatio(options : { symbol :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       longShortRatio: NumberString,  // example: "1.4342"  // long/short position ratio of top traders
       longAccount: NumberString,  // example: "0.5891"  // long positions ratio of top traders
       shortAccount: NumberString,  // example: "0.4656"  // short positions ratio of top traders
       timestamp: NumberString  // example: "1583139600000"
     }[]>;
  
  
  fapi_topTraderLongShortPositionRatio(...args : any) {
      return this._sendRequest("/futures/data/topLongShortPositionRatio", "GET", "MARKET_DATA", false, args, ["symbol", "period", "limit", "startTime", "endTime"], "fapi_topTraderLongShortPositionRatio");
  }
  
  
  /** Long/Short Ratio
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#long-short-ratio}
   * 
   * EndPoint: /futures/data/globalLongShortAccountRatio
   * 
   * Rate Limit: 1000/5min per IP
   * 
   * @param {string} symbol
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  default 30, max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  fapi_longShortRatio(symbol :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["fapi_longShortRatio"]>;
  
  
  /** Long/Short Ratio
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#long-short-ratio}
   * 
   * EndPoint: /futures/data/globalLongShortAccountRatio
   * 
   * Rate Limit: 1000/5min per IP
   * 
   * @param {string} options.symbol
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  default 30, max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  fapi_longShortRatio(options : { symbol :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"  // long/short account num ratio of all traders
       longShortRatio: NumberString,  // example: "0.1960"  //long account num ratio of all traders
       longAccount: NumberString,  // example: "0.6622"  // short account num ratio of all traders
       shortAccount: NumberString,  // example: "0.3378"
       timestamp: NumberString  // example: "1583139600000"
     }[]>;
  
  
  fapi_longShortRatio(...args : any) {
      return this._sendRequest("/futures/data/globalLongShortAccountRatio", "GET", "MARKET_DATA", false, args, ["symbol", "period", "limit", "startTime", "endTime"], "fapi_longShortRatio");
  }
  
  
  /** Taker Buy/Sell Volume
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#taker-buy-sell-volume}
   * 
   * EndPoint: /futures/data/takerlongshortRatio
   * 
   * Rate Limit: 1000/5min per IP
   * 
   * @param {string} symbol
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  default 30, max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  fapi_takerBuySellVolume(symbol :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["fapi_takerBuySellVolume"]>;
  
  
  /** Taker Buy/Sell Volume
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#taker-buy-sell-volume}
   * 
   * EndPoint: /futures/data/takerlongshortRatio
   * 
   * Rate Limit: 1000/5min per IP
   * 
   * @param {string} options.symbol
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  default 30, max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  fapi_takerBuySellVolume(options : { symbol :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       buySellRatio: NumberString,  // example: "1.5586"
       buyVol: NumberString,  // example: "387.3300"
       sellVol: NumberString,  // example: "248.5030"
       timestamp: NumberString  // example: "1585614900000"
     }[]>;
  
  
  fapi_takerBuySellVolume(...args : any) {
      return this._sendRequest("/futures/data/takerlongshortRatio", "GET", "MARKET_DATA", false, args, ["symbol", "period", "limit", "startTime", "endTime"], "fapi_takerBuySellVolume");
  }
  
  
  /** Basis
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#basis}
   * 
   * EndPoint: /futures/data/basis
   * 
   * @param {string} pair  -  BTCUSDT
   * @param {"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL"} contractType  -  CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  Default 30,Max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  fapi_basis(pair :string, contractType :"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL", period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["fapi_basis"]>;
  
  
  /** Basis
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#basis}
   * 
   * EndPoint: /futures/data/basis
   * 
   * @param {string} options.pair  -  BTCUSDT
   * @param {"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL"} options.contractType  -  CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  Default 30,Max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  fapi_basis(options : { pair :string, contractType :"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL", period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       indexPrice: NumberString,  // example: "34400.15945055"
       contractType: string,  // example: "PERPETUAL"
       basisRate: NumberString,  // example: "0.0004"
       futuresPrice: NumberString,  // example: "34414.10"
       annualizedBasisRate: string,  // example: ""
       basis: NumberString,  // example: "13.94054945"
       pair: string,  // example: "BTCUSDT"
       timestamp: number  // example: 1698742800000
     }[]>;
  
  
  fapi_basis(...args : any) {
      return this._sendRequest("/futures/data/basis", "GET", "MARKET_DATA", false, args, ["pair", "contractType", "period", "limit", "startTime", "endTime"], "fapi_basis");
  }
  
  
  /** Composite Index Symbol Information
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#composite-index-symbol-information}
   * 
   * EndPoint: /fapi/v1/indexInfo
   * 
   * Weight(IP): with symbol 1; without symbol 10
   * 
   * @param {string} symbol
   */
  fapi_compositeIndexSymbolInformation(symbol? :string)
  : ReturnType<MyBinanceClient["fapi_compositeIndexSymbolInformation"]>;
  
  
  /** Composite Index Symbol Information
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#composite-index-symbol-information}
   * 
   * EndPoint: /fapi/v1/indexInfo
   * 
   * Weight(IP): with symbol 1; without symbol 10
   * 
   * @param {string} options.symbol
   */
  fapi_compositeIndexSymbolInformation(options? : { symbol? :string })
  : Promise<{
       symbol: string,  // example: "DEFIUSDT"
       time: number,  // example: 1589437530011  // Current time
       component: string,  // example: "baseAsset"  //Component asset
       baseAssetList: {
           baseAsset: string,  // example: "BAL"
           quoteAsset: string,  // example: "USDT"
           weightInQuantity: NumberString,  // example: "1.04406228"
           weightInPercentage: NumberString  // example: "0.02783900"
         }[]
     }[]>;
  
  
  fapi_compositeIndexSymbolInformation(...args : any) {
      return this._sendRequest("/fapi/v1/indexInfo", "GET", "MARKET_DATA", false, args, ["symbol"], "fapi_compositeIndexSymbolInformation");
  }
  
  
  /** Multi-Assets Mode Asset Index
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#multi-assets-mode-asset-index}
   * 
   * asset index for Multi-Assets mode
   * 
   * EndPoint: /fapi/v1/assetIndex
   * 
   * Weight(IP): 1 for a single symbol; 10 when the symbol parameter is omitted
   * 
   * @param {string} symbol  -  Asset pair
   */
  fapi_multiAssetsModeAssetIndex(symbol? :string)  : ReturnType<MyBinanceClient["fapi_multiAssetsModeAssetIndex"]>;
  
  
  /** Multi-Assets Mode Asset Index
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#multi-assets-mode-asset-index}
   * 
   * asset index for Multi-Assets mode
   * 
   * EndPoint: /fapi/v1/assetIndex
   * 
   * Weight(IP): 1 for a single symbol; 10 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol  -  Asset pair
   */
  fapi_multiAssetsModeAssetIndex(options? : { symbol? :string })
  : Promise<{
     symbol: string,  // example: "ADAUSD"
     time: number,  // example: 1635740268004
     index: NumberString,  // example: "1.92957370"
     bidBuffer: NumberString,  // example: "0.10000000"
     askBuffer: NumberString,  // example: "0.10000000"
     bidRate: NumberString,  // example: "1.73661633"
     askRate: NumberString,  // example: "2.12253107"
     autoExchangeBidBuffer: NumberString,  // example: "0.05000000"
     autoExchangeAskBuffer: NumberString,  // example: "0.05000000"
     autoExchangeBidRate: NumberString,  // example: "1.83309501"
     autoExchangeAskRate: NumberString  // example: "2.02605238"
    } | {  // Or(without symbol)
       symbol: string,  // example: "ADAUSD"
       time: number,  // example: 1635740268004
       index: NumberString,  // example: "1.92957370"
       bidBuffer: NumberString,  // example: "0.10000000"
       askBuffer: NumberString,  // example: "0.10000000"
       bidRate: NumberString,  // example: "1.73661633"
       askRate: NumberString,  // example: "2.12253107"
       autoExchangeBidBuffer: NumberString,  // example: "0.05000000"
       autoExchangeAskBuffer: NumberString,  // example: "0.05000000"
       autoExchangeBidRate: NumberString,  // example: "1.83309501"
       autoExchangeAskRate: NumberString  // example: "2.02605238"
     }[]>;
  
  
  fapi_multiAssetsModeAssetIndex(...args : any) {
      return this._sendRequest("/fapi/v1/assetIndex", "GET", "MARKET_DATA", false, args, ["symbol"], "fapi_multiAssetsModeAssetIndex");
  }
  
  
  /** Query Index Price Constituents
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#query-index-price-constituents}
   * 
   * Query index price constituents 
   * 
   * EndPoint: /fapi/v1/constituents
   * 
   * Weight(IP): 2
   * 
   * @param {string} symbol  -  symbol
   */
  fapi_queryIndexPriceConstituents(symbol :string)  : ReturnType<MyBinanceClient["fapi_queryIndexPriceConstituents"]>;
  
  
  /** Query Index Price Constituents
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#query-index-price-constituents}
   * 
   * Query index price constituents 
   * 
   * EndPoint: /fapi/v1/constituents
   * 
   * Weight(IP): 2
   * 
   * @param {string} options.symbol  -  symbol
   */
  fapi_queryIndexPriceConstituents(options : { symbol :string })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     time: number,  // example: 1697421272043
     constituents: {
         exchange: string,  // example: "binance"
         symbol: string  // example: "BTCUSDT"
       }[]
    }>;
  
  
  fapi_queryIndexPriceConstituents(...args : any) {
      return this._sendRequest("/fapi/v1/constituents", "GET", "MARKET_DATA", false, args, ["symbol"], "fapi_queryIndexPriceConstituents");
  }
  
  
  
  //***** Account/Trades Endpoints *****
  
  
  /** Change Position Mode(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#change-position-mode-trade}
   * 
   * EndPoint: /fapi/v1/positionSide/dual
   * 
   * Weight(IP): 1
   * 
   * @param {string} dualSidePosition  -  "true": Hedge Mode; "false": One-way Mode
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_changePositionMode(dualSidePosition :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_changePositionMode"]>;
  
  
  /** Change Position Mode(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#change-position-mode-trade}
   * 
   * EndPoint: /fapi/v1/positionSide/dual
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.dualSidePosition  -  "true": Hedge Mode; "false": One-way Mode
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_changePositionMode(options : { dualSidePosition :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "success"
    }>;
  
  
  fapi_changePositionMode(...args : any) {
      return this._sendRequest("/fapi/v1/positionSide/dual", "POST", "TRADE", false, args, ["dualSidePosition", "recvWindow", "timestamp"], "fapi_changePositionMode");
  }
  
  
  /** Get Current Position Mode(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-current-position-mode-user_data}
   * 
   * EndPoint: /fapi/v1/positionSide/dual
   * 
   * Weight(IP): 30
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getCurrentPositionMode(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getCurrentPositionMode"]>;
  
  
  /** Get Current Position Mode(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-current-position-mode-user_data}
   * 
   * EndPoint: /fapi/v1/positionSide/dual
   * 
   * Weight(IP): 30
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getCurrentPositionMode(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     dualSidePosition: boolean  // example: true  // "true": Hedge Mode; "false": One-way Mode
    }>;
  
  
  fapi_getCurrentPositionMode(...args : any) {
      return this._sendRequest("/fapi/v1/positionSide/dual", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "fapi_getCurrentPositionMode");
  }
  
  
  /** Change Multi-Assets Mode (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#change-multi-assets-mode-trade}
   * 
   * EndPoint: /fapi/v1/multiAssetsMargin
   * 
   * Weight(IP): 1
   * 
   * @param {string} multiAssetsMargin  -  "true": Multi-Assets Mode; "false": Single-Asset Mode
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_changeMultiAssetsMode(multiAssetsMargin :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_changeMultiAssetsMode"]>;
  
  
  /** Change Multi-Assets Mode (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#change-multi-assets-mode-trade}
   * 
   * EndPoint: /fapi/v1/multiAssetsMargin
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.multiAssetsMargin  -  "true": Multi-Assets Mode; "false": Single-Asset Mode
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_changeMultiAssetsMode(options : { multiAssetsMargin :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "success"
    }>;
  
  
  fapi_changeMultiAssetsMode(...args : any) {
      return this._sendRequest("/fapi/v1/multiAssetsMargin", "POST", "TRADE", false, args, ["multiAssetsMargin", "recvWindow", "timestamp"], "fapi_changeMultiAssetsMode");
  }
  
  
  /** Get Current Multi-Assets Mode (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-current-multi-assets-mode-user_data}
   * 
   * EndPoint: /fapi/v1/multiAssetsMargin
   * 
   * Weight(IP): 30
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getCurrentMultiAssetsMode(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getCurrentMultiAssetsMode"]>;
  
  
  /** Get Current Multi-Assets Mode (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-current-multi-assets-mode-user_data}
   * 
   * EndPoint: /fapi/v1/multiAssetsMargin
   * 
   * Weight(IP): 30
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getCurrentMultiAssetsMode(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     multiAssetsMargin: boolean  // example: true  // "true": Multi-Assets Mode; "false": Single-Asset Mode
    }>;
  
  
  fapi_getCurrentMultiAssetsMode(...args : any) {
      return this._sendRequest("/fapi/v1/multiAssetsMargin", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "fapi_getCurrentMultiAssetsMode");
  }
  
  
  /** Toggle BNB Burn On Futures Trade (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#toggle-bnb-burn-on-futures-trade-trade}
   * 
   * EndPoint: /fapi/v1/feeBurn
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} feeBurn  -  "true": Fee Discount On; "false": Fee Discount Off
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_toggleBNBBurnOnFuturesTrade(feeBurn :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_toggleBNBBurnOnFuturesTrade"]>;
  
  
  /** Toggle BNB Burn On Futures Trade (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#toggle-bnb-burn-on-futures-trade-trade}
   * 
   * EndPoint: /fapi/v1/feeBurn
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.feeBurn  -  "true": Fee Discount On; "false": Fee Discount Off
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_toggleBNBBurnOnFuturesTrade(options : { feeBurn :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "success"
    }>;
  
  
  fapi_toggleBNBBurnOnFuturesTrade(...args : any) {
      return this._sendRequest("/fapi/v1/feeBurn", "POST", "TRADE", true, args, ["feeBurn", "recvWindow", "timestamp"], "fapi_toggleBNBBurnOnFuturesTrade");
  }
  
  
  /** Get BNB Burn Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-bnb-burn-status-user_data}
   * 
   * EndPoint: /fapi/v1/feeBurn
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getBNBBurnStatus(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["fapi_getBNBBurnStatus"]>;
  
  
  /** Get BNB Burn Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-bnb-burn-status-user_data}
   * 
   * EndPoint: /fapi/v1/feeBurn
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getBNBBurnStatus(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     feeBurn: boolean  // example: true  // "true": Fee Discount On; "false": Fee Discount Off
    }>;
  
  
  fapi_getBNBBurnStatus(...args : any) {
      return this._sendRequest("/fapi/v1/feeBurn", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "fapi_getBNBBurnStatus");
  }
  
  
  /** New Order  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#new-order-trade}
   * 
   * Send in a new order.
   * 
   * EndPoint: /fapi/v1/order
   * 
   * Weight(IP): 0
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {OrderType} type
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity  -  Cannot be sent with closePosition=true(Close-All)
   * @param {"true"|"false"} reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with closePosition=true
   * @param {DECIMAL} price
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,36}$
   * @param {DECIMAL} stopPrice  -  Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {string} closePosition  -  true, false；Close-All，used with STOP_MARKET or TAKE_PROFIT_MARKET.
   * @param {DECIMAL} activationPrice  -  Used with TRAILING_STOP_MARKET orders, default as the latest price(supporting different workingType)
   * @param {DECIMAL} callbackRate  -  Used with TRAILING_STOP_MARKET orders, min 0.1, max 10, where 1 for 1%
   * @param {WorkingType} workingType  -  stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
   * @param {"TRUE"|"FALSE"} priceProtect  -  "TRUE" or "FALSE", default "FALSE". Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {OrderResponseType} newOrderRespType  -  "ACK", "RESULT", default "ACK"
   * @param {PriceMatch} priceMatch  -  only avaliable for LIMIT/STOP/TAKE_PROFIT order; can be set to OPPONENT/ OPPONENT_5/ OPPONENT_10/ OPPONENT_20: /QUEUE/ QUEUE_5/ QUEUE_10/ QUEUE_20; Can't be passed together with price
   * @param {ENUM} selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire maker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers; default NONE
   * @param {LONG} goodTillDate  -  order cancel time for timeInForce GTD, mandatory when timeInforce set to GTD; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_newOrder(symbol :string, side :OrderSide, positionSide :PositionSide|undefined, type :OrderType, timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, stopPrice? :DECIMAL, closePosition? :string, activationPrice? :DECIMAL, callbackRate? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newOrderRespType? :OrderResponseType, priceMatch? :PriceMatch, selfTradePreventionMode? :ENUM, goodTillDate? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_newOrder"]>;
  
  
  /** New Order  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#new-order-trade}
   * 
   * Send in a new order.
   * 
   * EndPoint: /fapi/v1/order
   * 
   * Weight(IP): 0
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {OrderType} options.type
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity  -  Cannot be sent with closePosition=true(Close-All)
   * @param {"true"|"false"} options.reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with closePosition=true
   * @param {DECIMAL} options.price
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,36}$
   * @param {DECIMAL} options.stopPrice  -  Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {string} options.closePosition  -  true, false；Close-All，used with STOP_MARKET or TAKE_PROFIT_MARKET.
   * @param {DECIMAL} options.activationPrice  -  Used with TRAILING_STOP_MARKET orders, default as the latest price(supporting different workingType)
   * @param {DECIMAL} options.callbackRate  -  Used with TRAILING_STOP_MARKET orders, min 0.1, max 10, where 1 for 1%
   * @param {WorkingType} options.workingType  -  stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
   * @param {"TRUE"|"FALSE"} options.priceProtect  -  "TRUE" or "FALSE", default "FALSE". Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {OrderResponseType} options.newOrderRespType  -  "ACK", "RESULT", default "ACK"
   * @param {PriceMatch} options.priceMatch  -  only avaliable for LIMIT/STOP/TAKE_PROFIT order; can be set to OPPONENT/ OPPONENT_5/ OPPONENT_10/ OPPONENT_20: /QUEUE/ QUEUE_5/ QUEUE_10/ QUEUE_20; Can't be passed together with price
   * @param {ENUM} options.selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire maker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers; default NONE
   * @param {LONG} options.goodTillDate  -  order cancel time for timeInForce GTD, mandatory when timeInforce set to GTD; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_newOrder(options : { symbol :string, side :OrderSide, positionSide? :PositionSide, type :OrderType, timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, stopPrice? :DECIMAL, closePosition? :string, activationPrice? :DECIMAL, callbackRate? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newOrderRespType? :OrderResponseType, priceMatch? :PriceMatch, selfTradePreventionMode? :ENUM, goodTillDate? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     clientOrderId: string,  // example: "testOrder"
     cumQty: NumberString,  // example: "0"
     cumQuote: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 22542179
     avgPrice: NumberString,  // example: "0.00000"
     origQty: NumberString,  // example: "10"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "NEW"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     closePosition: boolean,  // example: false  // if Close-All
     symbol: string,  // example: "BTCUSDT"
     timeInForce: string,  // example: "GTD"
     type: string,  // example: "TRAILING_STOP_MARKET"
     origType: string,  // example: "TRAILING_STOP_MARKET"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     updateTime: number,  // example: 1566818724722
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean,  // example: false  // if conditional order trigger is protected
     priceMatch: PriceMatch,  // example: "NONE"  //price match mode
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 1693207680000  //order pre-set auot cancel time for TIF GTD order
    }>;
  
  
  fapi_newOrder(...args : any) {
      return this._sendRequest("/fapi/v1/order", "POST", "TRADE", false, args, ["symbol", "side", "positionSide", "type", "timeInForce", "quantity", "reduceOnly", "price", "newClientOrderId", "stopPrice", "closePosition", "activationPrice", "callbackRate", "workingType", "priceProtect", "newOrderRespType", "priceMatch", "selfTradePreventionMode", "goodTillDate", "recvWindow", "timestamp"], "fapi_newOrder");
  }
  
  
  /** Test Order(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#test-order-trade}
   * 
   * Testing order request, this order will not be submitted to matching engine
   * 
   * EndPoint: /fapi/v1/order/test
   * 
   * Weight(IP): 0
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {OrderType} type
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity  -  Cannot be sent with closePosition=true(Close-All)
   * @param {"true"|"false"} reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with closePosition=true
   * @param {DECIMAL} price
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,36}$
   * @param {DECIMAL} stopPrice  -  Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {string} closePosition  -  true, false；Close-All，used with STOP_MARKET or TAKE_PROFIT_MARKET.
   * @param {DECIMAL} activationPrice  -  Used with TRAILING_STOP_MARKET orders, default as the latest price(supporting different workingType)
   * @param {DECIMAL} callbackRate  -  Used with TRAILING_STOP_MARKET orders, min 0.1, max 10, where 1 for 1%
   * @param {WorkingType} workingType  -  stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
   * @param {"TRUE"|"FALSE"} priceProtect  -  "TRUE" or "FALSE", default "FALSE". Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {OrderResponseType} newOrderRespType  -  "ACK", "RESULT", default "ACK"
   * @param {PriceMatch} priceMatch  -  only avaliable for LIMIT/STOP/TAKE_PROFIT order; can be set to OPPONENT/ OPPONENT_5/ OPPONENT_10/ OPPONENT_20: /QUEUE/ QUEUE_5/ QUEUE_10/ QUEUE_20; Can't be passed together with price
   * @param {ENUM} selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire maker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers; default NONE
   * @param {LONG} goodTillDate  -  order cancel time for timeInForce GTD, mandatory when timeInforce set to GTD; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_testOrder(symbol :string, side :OrderSide, positionSide :PositionSide|undefined, type :OrderType, timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, stopPrice? :DECIMAL, closePosition? :string, activationPrice? :DECIMAL, callbackRate? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newOrderRespType? :OrderResponseType, priceMatch? :PriceMatch, selfTradePreventionMode? :ENUM, goodTillDate? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : Promise<unknown>;
  
  
  /** Test Order(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#test-order-trade}
   * 
   * Testing order request, this order will not be submitted to matching engine
   * 
   * EndPoint: /fapi/v1/order/test
   * 
   * Weight(IP): 0
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {OrderType} options.type
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity  -  Cannot be sent with closePosition=true(Close-All)
   * @param {"true"|"false"} options.reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with closePosition=true
   * @param {DECIMAL} options.price
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,36}$
   * @param {DECIMAL} options.stopPrice  -  Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {string} options.closePosition  -  true, false；Close-All，used with STOP_MARKET or TAKE_PROFIT_MARKET.
   * @param {DECIMAL} options.activationPrice  -  Used with TRAILING_STOP_MARKET orders, default as the latest price(supporting different workingType)
   * @param {DECIMAL} options.callbackRate  -  Used with TRAILING_STOP_MARKET orders, min 0.1, max 10, where 1 for 1%
   * @param {WorkingType} options.workingType  -  stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
   * @param {"TRUE"|"FALSE"} options.priceProtect  -  "TRUE" or "FALSE", default "FALSE". Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {OrderResponseType} options.newOrderRespType  -  "ACK", "RESULT", default "ACK"
   * @param {PriceMatch} options.priceMatch  -  only avaliable for LIMIT/STOP/TAKE_PROFIT order; can be set to OPPONENT/ OPPONENT_5/ OPPONENT_10/ OPPONENT_20: /QUEUE/ QUEUE_5/ QUEUE_10/ QUEUE_20; Can't be passed together with price
   * @param {ENUM} options.selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire maker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers; default NONE
   * @param {LONG} options.goodTillDate  -  order cancel time for timeInForce GTD, mandatory when timeInforce set to GTD; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_testOrder(options : { symbol :string, side :OrderSide, positionSide? :PositionSide, type :OrderType, timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, stopPrice? :DECIMAL, closePosition? :string, activationPrice? :DECIMAL, callbackRate? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newOrderRespType? :OrderResponseType, priceMatch? :PriceMatch, selfTradePreventionMode? :ENUM, goodTillDate? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<unknown>;
  
  
  fapi_testOrder(...args : any) {
      return this._sendRequest("/fapi/v1/order/test", "POST", "TRADE", false, args, ["symbol", "side", "positionSide", "type", "timeInForce", "quantity", "reduceOnly", "price", "newClientOrderId", "stopPrice", "closePosition", "activationPrice", "callbackRate", "workingType", "priceProtect", "newOrderRespType", "priceMatch", "selfTradePreventionMode", "goodTillDate", "recvWindow", "timestamp"], "fapi_testOrder");
  }
  
  
  /** Modify Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#modify-order-trade}
   * 
   * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
   * 
   * EndPoint: /fapi/v1/order
   * 
   * Weight(IP): 
   *   1 on IP rate limit(x-mbx-used-weight-1m)
   * Weight(orders): 
   *   1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
   *   
   *   1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M)
   * 
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {string} symbol
   * @param {"SELL"|"BUY"} side  -  SELL, BUY; side needs to be same as origin order
   * @param {DECIMAL} quantity  -  Order quantity, cannot be sent with closePosition=true
   * @param {DECIMAL} price
   * @param {PriceMatch} priceMatch  -  only avaliable for LIMIT/STOP/TAKE_PROFIT order; can be set to OPPONENT/ OPPONENT_5/ OPPONENT_10/ OPPONENT_20: /QUEUE/ QUEUE_5/ QUEUE_10/ QUEUE_20; Can't be passed together with price
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_modifyOrder(orderId :LONG|undefined, origClientOrderId :string|undefined, symbol :string, side :"SELL"|"BUY", quantity :DECIMAL, price :DECIMAL, priceMatch? :PriceMatch, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_modifyOrder"]>;
  
  
  /** Modify Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#modify-order-trade}
   * 
   * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
   * 
   * EndPoint: /fapi/v1/order
   * 
   * Weight(IP): 
   *   1 on IP rate limit(x-mbx-used-weight-1m)
   * Weight(orders): 
   *   1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
   *   
   *   1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M)
   * 
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {string} options.symbol
   * @param {"SELL"|"BUY"} options.side  -  SELL, BUY; side needs to be same as origin order
   * @param {DECIMAL} options.quantity  -  Order quantity, cannot be sent with closePosition=true
   * @param {DECIMAL} options.price
   * @param {PriceMatch} options.priceMatch  -  only avaliable for LIMIT/STOP/TAKE_PROFIT order; can be set to OPPONENT/ OPPONENT_5/ OPPONENT_10/ OPPONENT_20: /QUEUE/ QUEUE_5/ QUEUE_10/ QUEUE_20; Can't be passed together with price
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_modifyOrder(options : { orderId? :LONG, origClientOrderId? :string, symbol :string, side :"SELL"|"BUY", quantity :DECIMAL, price :DECIMAL, priceMatch? :PriceMatch, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderId: number,  // example: 20072994037
     symbol: string,  // example: "BTCUSDT"
     pair: string,  // example: "BTCUSDT"
     status: string,  // example: "NEW"
     clientOrderId: string,  // example: "LJ9R4QZDihCaS8UAOOLpgW"
     price: NumberString,  // example: "30005"
     avgPrice: NumberString,  // example: "0.0"
     origQty: NumberString,  // example: "1"
     executedQty: NumberString,  // example: "0"
     cumQty: NumberString,  // example: "0"
     cumBase: NumberString,  // example: "0"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     reduceOnly: boolean,  // example: false
     closePosition: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "LONG"
     stopPrice: NumberString,  // example: "0"
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean,  // example: false
     origType: string,  // example: "LIMIT"
     priceMatch: PriceMatch,  // example: "NONE"  //price match mode
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number,  // example: 0  //order pre-set auot cancel time for TIF GTD order
     updateTime: number  // example: 1629182711600
    }>;
  
  
  fapi_modifyOrder(...args : any) {
      return this._sendRequest("/fapi/v1/order", "PUT", "TRADE", false, args, ["orderId", "origClientOrderId", "symbol", "side", "quantity", "price", "priceMatch", "recvWindow", "timestamp"], "fapi_modifyOrder");
  }
  
  
  /** Place Multiple Orders  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#place-multiple-orders-trade}
   * 
   * EndPoint: /fapi/v1/batchOrders
   * 
   * Weight(IP): 
   *   5 on IP rate limit(x-mbx-used-weight-1m)
   * Weight(orders): 
   *   5 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
   *   
   *   1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M)
   * 
   * @param {object[]} batchOrders  -  order list. Max 5 orders
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_placeMultipleOrders(batchOrders :{symbol :string, side :OrderSide, positionSide? :PositionSide, type :OrderType, timeInForce? :TimeInForce, quantity :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, stopPrice? :DECIMAL, activationPrice? :DECIMAL, callbackRate? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newOrderRespType? :OrderResponseType, priceMatch? :PriceMatch, selfTradePreventionMode? :ENUM, goodTillDate? :LONG}[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_placeMultipleOrders"]>;
  
  
  /** Place Multiple Orders  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#place-multiple-orders-trade}
   * 
   * EndPoint: /fapi/v1/batchOrders
   * 
   * Weight(IP): 
   *   5 on IP rate limit(x-mbx-used-weight-1m)
   * Weight(orders): 
   *   5 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
   *   
   *   1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M)
   * 
   * @param {object[]} options.batchOrders  -  order list. Max 5 orders
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_placeMultipleOrders(options : { batchOrders :{symbol :string, side :OrderSide, positionSide? :PositionSide, type :OrderType, timeInForce? :TimeInForce, quantity :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, stopPrice? :DECIMAL, activationPrice? :DECIMAL, callbackRate? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newOrderRespType? :OrderResponseType, priceMatch? :PriceMatch, selfTradePreventionMode? :ENUM, goodTillDate? :LONG}[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       clientOrderId: string,  // example: "testOrder"
       cumQty: NumberString,  // example: "0"
       cumQuote: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 22542179
       avgPrice: NumberString,  // example: "0.00000"
       origQty: NumberString,  // example: "10"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       symbol: string,  // example: "BTCUSDT"
       timeInForce: TimeInForce,  // example: "GTC"
       type: string,  // example: "TRAILING_STOP_MARKET"
       origType: string,  // example: "TRAILING_STOP_MARKET"
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
       updateTime: number,  // example: 1566818724722
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean,  // example: false  // if conditional order trigger is protected
       priceMatch: PriceMatch,  // example: "NONE"  //price match mode
       selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
       goodTillDate: number  // example: 0  //order pre-set auot cancel time for TIF GTD order
     } |
     {
       code: number,  // example: -2022
       msg: string    // example: "ReduceOnly Order is rejected."
     }
    )[]>;
  
  
  fapi_placeMultipleOrders(...args : any) {
      return this._sendRequest("/fapi/v1/batchOrders", "POST", "TRADE", false, args, ["batchOrders", "recvWindow", "timestamp"], "fapi_placeMultipleOrders");
  }
  
  
  /** Modify Multiple Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#modify-multiple-orders-trade}
   * 
   * EndPoint: /fapi/v1/batchOrders
   * 
   * Weight(IP): 5
   * 
   * @param {object[]} batchOrders  -  order list. Max 5 orders
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_modifyMultipleOrders(batchOrders :{orderId? :LONG, origClientOrderId? :string, symbol :string, side :"SELL"|"BUY", quantity :DECIMAL, price :DECIMAL, priceMatch? :PriceMatch, recvWindow? :LONG, timestamp :LONG}[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_modifyMultipleOrders"]>;
  
  
  /** Modify Multiple Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#modify-multiple-orders-trade}
   * 
   * EndPoint: /fapi/v1/batchOrders
   * 
   * Weight(IP): 5
   * 
   * @param {object[]} options.batchOrders  -  order list. Max 5 orders
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_modifyMultipleOrders(options : { batchOrders :{orderId? :LONG, origClientOrderId? :string, symbol :string, side :"SELL"|"BUY", quantity :DECIMAL, price :DECIMAL, priceMatch? :PriceMatch, recvWindow? :LONG, timestamp :LONG}[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       orderId: number,  // example: 20072994037
       symbol: string,  // example: "BTCUSDT"
       pair: string,  // example: "BTCUSDT"
       status: string,  // example: "NEW"
       clientOrderId: string,  // example: "LJ9R4QZDihCaS8UAOOLpgW"
       price: NumberString,  // example: "30005"
       avgPrice: NumberString,  // example: "0.0"
       origQty: NumberString,  // example: "1"
       executedQty: NumberString,  // example: "0"
       cumQty: NumberString,  // example: "0"
       cumBase: NumberString,  // example: "0"
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       reduceOnly: boolean,  // example: false
       closePosition: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "LONG"
       stopPrice: NumberString,  // example: "0"
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean,  // example: false
       origType: string,  // example: "LIMIT"
       priceMatch: PriceMatch,  // example: "NONE"  //price match mode
       selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
       goodTillDate: number,  // example: 0  //order pre-set auot cancel time for TIF GTD order
       updateTime: number  // example: 1629182711600
     } |
     {
       code: number,  // example: -2022
       msg: string    // example: "ReduceOnly Order is rejected."
     }
    )[]>;
  
  
  fapi_modifyMultipleOrders(...args : any) {
      return this._sendRequest("/fapi/v1/batchOrders", "PUT", "TRADE", false, args, ["batchOrders", "recvWindow", "timestamp"], "fapi_modifyMultipleOrders");
  }
  
  
  /** Get Order Modify History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-order-modify-history-user_data}
   * 
   * Get order modification history
   * 
   * EndPoint: /fapi/v1/orderAmendment
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} startTime  -  Timestamp in ms to get modification history from INCLUSIVE
   * @param {LONG} endTime  -  Timestamp in ms to get modification history until INCLUSIVE
   * @param {INT} limit  -  Default 1000; max 1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getOrderModifyHistory(symbol :string, orderId? :LONG, origClientOrderId? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getOrderModifyHistory"]>;
  
  
  /** Get Order Modify History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-order-modify-history-user_data}
   * 
   * Get order modification history
   * 
   * EndPoint: /fapi/v1/orderAmendment
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.startTime  -  Timestamp in ms to get modification history from INCLUSIVE
   * @param {LONG} options.endTime  -  Timestamp in ms to get modification history until INCLUSIVE
   * @param {INT} options.limit  -  Default 1000; max 1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getOrderModifyHistory(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       amendmentId: number,  // example: 5363  // Order modification ID
       symbol: string,  // example: "BTCUSDT"
       pair: string,  // example: "BTCUSDT"
       orderId: number,  // example: 20072994037
       clientOrderId: string,  // example: "LJ9R4QZDihCaS8UAOOLpgW"
       time: number,  // example: 1629184560899  // Order modification time
       amendment: {
         price: {
           before: NumberString,  // example: "30004"
           after: NumberString  // example: "30003.2"
         },
         origQty: {
           before: NumberString,  // example: "1"
           after: NumberString  // example: "1"
         },
         count: number  // example: 3  // Order modification count, representing the number of times the order has been modified
       },
       priceMatch: PriceMatch  // example: "QUEUE_20"
     }[]>;
  
  
  fapi_getOrderModifyHistory(...args : any) {
      return this._sendRequest("/fapi/v1/orderAmendment", "GET", "USER_DATA", false, args, ["symbol", "orderId", "origClientOrderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "fapi_getOrderModifyHistory");
  }
  
  
  /** Query Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#query-order-user_data}
   * 
   * Check an order's status.
   * 
   * EndPoint: /fapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_queryOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_queryOrder"]>;
  
  
  /** Query Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#query-order-user_data}
   * 
   * Check an order's status.
   * 
   * EndPoint: /fapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_queryOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.00000"
     clientOrderId: string,  // example: "abc"
     cumQuote: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 1917641
     origQty: NumberString,  // example: "0.40"
     origType: string,  // example: "TRAILING_STOP_MARKET"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "NEW"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     closePosition: boolean,  // example: false  // if Close-All
     symbol: string,  // example: "BTCUSDT"
     time: number,  // example: 1579276756075  // order time
     timeInForce: TimeInForce,  // example: "GTC"
     type: string,  // example: "TRAILING_STOP_MARKET"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     updateTime: number,  // example: 1579276756075  // update time
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean,  // example: false  // if conditional order trigger is protected
     priceMatch: PriceMatch,  // example: "NONE"  //price match mode
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 0  //order pre-set auot cancel time for TIF GTD order
    }>;
  
  
  fapi_queryOrder(...args : any) {
      return this._sendRequest("/fapi/v1/order", "GET", "USER_DATA", false, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "fapi_queryOrder");
  }
  
  
  /** Cancel Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#cancel-order-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /fapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_cancelOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_cancelOrder"]>;
  
  
  /** Cancel Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#cancel-order-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /fapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_cancelOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     clientOrderId: string,  // example: "myOrder1"
     cumQty: NumberString,  // example: "0"
     cumQuote: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 283194212
     origQty: NumberString,  // example: "11"
     origType: string,  // example: "TRAILING_STOP_MARKET"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "CANCELED"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     closePosition: boolean,  // example: false  // if Close-All
     symbol: string,  // example: "BTCUSDT"
     timeInForce: TimeInForce,  // example: "GTC"
     type: string,  // example: "TRAILING_STOP_MARKET"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     updateTime: number,  // example: 1571110484038
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean,  // example: false  // if conditional order trigger is protected
     priceMatch: PriceMatch,  // example: "NONE"  //price match mode
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 0  //order pre-set auot cancel time for TIF GTD order
    }>;
  
  
  fapi_cancelOrder(...args : any) {
      return this._sendRequest("/fapi/v1/order", "DELETE", "TRADE", false, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "fapi_cancelOrder");
  }
  
  
  /** Cancel All Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#cancel-all-open-orders-trade}
   * 
   * EndPoint: /fapi/v1/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_cancelAllOpenOrders(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_cancelAllOpenOrders"]>;
  
  
  /** Cancel All Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#cancel-all-open-orders-trade}
   * 
   * EndPoint: /fapi/v1/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_cancelAllOpenOrders(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "The operation of cancel all open order is done."
    }>;
  
  
  fapi_cancelAllOpenOrders(...args : any) {
      return this._sendRequest("/fapi/v1/allOpenOrders", "DELETE", "TRADE", false, args, ["symbol", "recvWindow", "timestamp"], "fapi_cancelAllOpenOrders");
  }
  
  
  /** Cancel Multiple Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#cancel-multiple-orders-trade}
   * 
   * EndPoint: /fapi/v1/batchOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG[]} orderIdList  -  max length 10  e.g. [1234567,2345678]
   * @param {string[]} origClientOrderIdList  -  max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_cancelMultipleOrders(symbol :string, orderIdList? :readonly LONG[], origClientOrderIdList? :readonly string[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_cancelMultipleOrders"]>;
  
  
  /** Cancel Multiple Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#cancel-multiple-orders-trade}
   * 
   * EndPoint: /fapi/v1/batchOrders
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG[]} options.orderIdList  -  max length 10  e.g. [1234567,2345678]
   * @param {string[]} options.origClientOrderIdList  -  max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_cancelMultipleOrders(options : { symbol :string, orderIdList? :readonly LONG[], origClientOrderIdList? :readonly string[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       clientOrderId: string,  // example: "myOrder1"
       cumQty: NumberString,  // example: "0"
       cumQuote: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 283194212
       origQty: NumberString,  // example: "11"
       origType: string,  // example: "TRAILING_STOP_MARKET"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "CANCELED"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       closePosition: boolean,  // example: false  // if Close-All
       symbol: string,  // example: "BTCUSDT"
       timeInForce: TimeInForce,  // example: "GTC"
       type: string,  // example: "TRAILING_STOP_MARKET"
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
       updateTime: number,  // example: 1571110484038
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean,  // example: false  // if conditional order trigger is protected
       priceMatch: PriceMatch,  // example: "NONE"  //price match mode
       selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
       goodTillDate: number  // example: 0  //order pre-set auot cancel time for TIF GTD order
     } |
     {
       code: number,  // example: -2011
       msg: string    // example: "Unknown order sent."
     }
    )[]>;
  
  
  fapi_cancelMultipleOrders(...args : any) {
      return this._sendRequest("/fapi/v1/batchOrders", "DELETE", "TRADE", false, args, ["symbol", "orderIdList", "origClientOrderIdList", "recvWindow", "timestamp"], "fapi_cancelMultipleOrders");
  }
  
  
  /** Auto-Cancel All Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#auto-cancel-all-open-orders-trade}
   * 
   * Cancel all open orders of the specified symbol at the end of the specified countdown.
   * 
   * EndPoint: /fapi/v1/countdownCancelAll
   * 
   * Weight(IP): 10
   * 
   * @param {string} symbol
   * @param {LONG} countdownTime  -  countdown time, 1000 for 1 second. 0 to cancel the timer
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_autoCancelAllOpenOrders(symbol :string, countdownTime :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_autoCancelAllOpenOrders"]>;
  
  
  /** Auto-Cancel All Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#auto-cancel-all-open-orders-trade}
   * 
   * Cancel all open orders of the specified symbol at the end of the specified countdown.
   * 
   * EndPoint: /fapi/v1/countdownCancelAll
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.symbol
   * @param {LONG} options.countdownTime  -  countdown time, 1000 for 1 second. 0 to cancel the timer
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_autoCancelAllOpenOrders(options : { symbol :string, countdownTime :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     countdownTime: NumberString  // example: "100000"
    }>;
  
  
  fapi_autoCancelAllOpenOrders(...args : any) {
      return this._sendRequest("/fapi/v1/countdownCancelAll", "POST", "TRADE", false, args, ["symbol", "countdownTime", "recvWindow", "timestamp"], "fapi_autoCancelAllOpenOrders");
  }
  
  
  /** Query Current Open Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#query-current-open-order-user_data}
   * 
   * EndPoint: /fapi/v1/openOrder
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_queryCurrentOpenOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_queryCurrentOpenOrder"]>;
  
  
  /** Query Current Open Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#query-current-open-order-user_data}
   * 
   * EndPoint: /fapi/v1/openOrder
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_queryCurrentOpenOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.00000"
     clientOrderId: string,  // example: "abc"
     cumQuote: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 1917641
     origQty: NumberString,  // example: "0.40"
     origType: string,  // example: "TRAILING_STOP_MARKET"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "NEW"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     closePosition: boolean,  // example: false  // if Close-All
     symbol: string,  // example: "BTCUSDT"
     time: number,  // example: 1579276756075  // order time
     timeInForce: TimeInForce,  // example: "GTC"
     type: string,  // example: "TRAILING_STOP_MARKET"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     updateTime: number,  // example: 1579276756075
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean,  // example: false  // if conditional order trigger is protected
     priceMatch: PriceMatch,  // example: "NONE"  //price match mode
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 0  //order pre-set auot cancel time for TIF GTD order
    }>;
  
  
  fapi_queryCurrentOpenOrder(...args : any) {
      return this._sendRequest("/fapi/v1/openOrder", "GET", "USER_DATA", false, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "fapi_queryCurrentOpenOrder");
  }
  
  
  /** Current All Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#current-all-open-orders-user_data}
   * 
   * EndPoint: /fapi/v1/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_currentAllOpenOrders(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_currentAllOpenOrders"]>;
  
  
  /** Current All Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#current-all-open-orders-user_data}
   * 
   * EndPoint: /fapi/v1/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_currentAllOpenOrders(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       avgPrice: NumberString,  // example: "0.00000"
       clientOrderId: string,  // example: "abc"
       cumQuote: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 1917641
       origQty: NumberString,  // example: "0.40"
       origType: string,  // example: "TRAILING_STOP_MARKET"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       closePosition: boolean,  // example: false  // if Close-All
       symbol: string,  // example: "BTCUSDT"
       time: number,  // example: 1579276756075  // order time
       timeInForce: TimeInForce,  // example: "GTC"
       type: string,  // example: "TRAILING_STOP_MARKET"
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
       updateTime: number,  // example: 1579276756075  // update time
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean,  // example: false  // if conditional order trigger is protected
       priceMatch: PriceMatch,  // example: "NONE"  //price match mode
       selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
       goodTillDate: number  // example: 0  //order pre-set auot cancel time for TIF GTD order
     }[]>;
  
  
  fapi_currentAllOpenOrders(...args : any) {
      return this._sendRequest("/fapi/v1/openOrders", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "fapi_currentAllOpenOrders");
  }
  
  
  /** All Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#all-orders-user_data}
   * 
   * Get all account orders; active, canceled, or filled.
   * 
   * EndPoint: /fapi/v1/allOrders
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_allOrders(symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_allOrders"]>;
  
  
  /** All Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#all-orders-user_data}
   * 
   * Get all account orders; active, canceled, or filled.
   * 
   * EndPoint: /fapi/v1/allOrders
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_allOrders(options : { symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       avgPrice: NumberString,  // example: "0.00000"
       clientOrderId: string,  // example: "abc"
       cumQuote: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 1917641
       origQty: NumberString,  // example: "0.40"
       origType: string,  // example: "TRAILING_STOP_MARKET"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       closePosition: boolean,  // example: false  // if Close-All
       symbol: string,  // example: "BTCUSDT"
       time: number,  // example: 1579276756075  // order time
       timeInForce: TimeInForce,  // example: "GTC"
       type: string,  // example: "TRAILING_STOP_MARKET"
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
       updateTime: number,  // example: 1579276756075  // update time
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean,  // example: false  // if conditional order trigger is protected
       priceMatch: PriceMatch,  // example: "NONE"  //price match mode
       selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
       goodTillDate: number  // example: 0  //order pre-set auot cancel time for TIF GTD order
     }[]>;
  
  
  fapi_allOrders(...args : any) {
      return this._sendRequest("/fapi/v1/allOrders", "GET", "USER_DATA", false, args, ["symbol", "orderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "fapi_allOrders");
  }
  
  
  /** Futures Account Balance V3 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#futures-account-balance-v3-user_data}
   * 
   * EndPoint: /fapi/v3/balance
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_futuresAccountBalanceV3(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_futuresAccountBalanceV3"]>;
  
  
  /** Futures Account Balance V3 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#futures-account-balance-v3-user_data}
   * 
   * EndPoint: /fapi/v3/balance
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_futuresAccountBalanceV3(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       accountAlias: string,  // example: "SgsR"  // unique account code
       asset: string,  // example: "USDT"  // asset name
       balance: NumberString,  // example: "122607.35137903"  // wallet balance
       crossWalletBalance: NumberString,  // example: "23.72469206"  // crossed wallet balance
       crossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit of crossed positions
       availableBalance: NumberString,  // example: "23.72469206"  // available balance
       maxWithdrawAmount: NumberString,  // example: "23.72469206"  // maximum amount for transfer out
       marginAvailable: boolean,  // example: true  // whether the asset can be used as margin in Multi-Assets mode
       updateTime: number  // example: 1617939110373
     }[]>;
  
  
  fapi_futuresAccountBalanceV3(...args : any) {
      return this._sendRequest("/fapi/v3/balance", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "fapi_futuresAccountBalanceV3");
  }
  
  
  /** Futures Account Balance V2 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#futures-account-balance-v2-user_data}
   * 
   * EndPoint: /fapi/v2/balance
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_futuresAccountBalanceV2(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_futuresAccountBalanceV2"]>;
  
  
  /** Futures Account Balance V2 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#futures-account-balance-v2-user_data}
   * 
   * EndPoint: /fapi/v2/balance
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_futuresAccountBalanceV2(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       accountAlias: string,  // example: "SgsR"  // unique account code
       asset: string,  // example: "USDT"  // asset name
       balance: NumberString,  // example: "122607.35137903"  // wallet balance
       crossWalletBalance: NumberString,  // example: "23.72469206"  // crossed wallet balance
       crossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit of crossed positions
       availableBalance: NumberString,  // example: "23.72469206"  // available balance
       maxWithdrawAmount: NumberString,  // example: "23.72469206"  // maximum amount for transfer out
       marginAvailable: boolean,  // example: true  // whether the asset can be used as margin in Multi-Assets mode
       updateTime: number  // example: 1617939110373
     }[]>;
  
  
  fapi_futuresAccountBalanceV2(...args : any) {
      return this._sendRequest("/fapi/v2/balance", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "fapi_futuresAccountBalanceV2");
  }
  
  
  /** Account Information V3 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#account-information-v3-user_data}
   * 
   * EndPoint: /fapi/v3/account
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_accountInformationV3(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_accountInformationV3"]>;
  
  
  /** Account Information V3 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#account-information-v3-user_data}
   * 
   * EndPoint: /fapi/v3/account
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_accountInformationV3(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  // single-asset mode
     totalInitialMargin: NumberString,  // example: "0.00000000"  // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
     totalMaintMargin: NumberString,  // example: "0.00000000"  // total maintenance margin required, only for USDT asset
     totalWalletBalance: NumberString,  // example: "103.12345678"  // total wallet balance, only for USDT asset
     totalUnrealizedProfit: NumberString,  // example: "0.00000000"  // total unrealized profit, only for USDT asset
     totalMarginBalance: NumberString,  // example: "103.12345678"  // total margin balance, only for USDT asset
     totalPositionInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for positions with current mark price, only for USDT asset
     totalOpenOrderInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for open orders with current mark price, only for USDT asset
     totalCrossWalletBalance: NumberString,  // example: "103.12345678"  // crossed wallet balance, only for USDT asset
     totalCrossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit of crossed positions, only for USDT asset
     availableBalance: NumberString,  // example: "103.12345678"  // available balance, only for USDT asset
     maxWithdrawAmount: NumberString,  // example: "103.12345678"  // maximum amount for transfer out, only for USDT asset
     assets: {
         asset: string,  // example: "USDT"  // asset name
         walletBalance: NumberString,  // example: "23.72469206"  // wallet balance
         unrealizedProfit: NumberString,  // example: "0.00000000"  // unrealized profit
         marginBalance: NumberString,  // example: "23.72469206"  // margin balance
         maintMargin: NumberString,  // example: "0.00000000"  // maintenance margin required
         initialMargin: NumberString,  // example: "0.00000000"  // total initial margin required with current mark price
         positionInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for positions with current mark price
         openOrderInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for open orders with current mark price
         crossWalletBalance: NumberString,  // example: "23.72469206"  // crossed wallet balance
         crossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit of crossed positions
         availableBalance: NumberString,  // example: "23.72469206"  // available balance
         maxWithdrawAmount: NumberString,  // example: "23.72469206"  // maximum amount for transfer out
         updateTime: number  // example: 1625474304765  // last update time
       }[],
     positions: {
         symbol: string,  // example: "BTCUSDT"
         positionSide: PositionSide,  // example: "BOTH"  // position side
         positionAmt: NumberString,  // example: "1.000"
         unrealizedProfit: NumberString,  // example: "0.00000000"  // unrealized profit
         isolatedMargin: NumberString,  // example: "0.00000000"
         notional: NumberString,  // example: "0"
         isolatedWallet: NumberString,  // example: "0"
         initialMargin: NumberString,  // example: "0"  // initial margin required with current mark price
         maintMargin: NumberString,  // example: "0"  // maintenance margin required
         updateTime: number  // example: 0
       }[]
    } | {  // multi-assets mode
     totalInitialMargin: NumberString,  // example: "0.00000000"  // the sum of USD value of all cross positions/open order initial margin
     totalMaintMargin: NumberString,  // example: "0.00000000"  // the sum of USD value of all cross positions maintenance margin
     totalWalletBalance: NumberString,  // example: "126.72469206"  // total wallet balance in USD
     totalUnrealizedProfit: NumberString,  // example: "0.00000000"  // total unrealized profit in USD
     totalMarginBalance: NumberString,  // example: "126.72469206"  // total margin balance in USD
     totalPositionInitialMargin: NumberString,  // example: "0.00000000"  // the sum of USD value of all cross positions initial margin
     totalOpenOrderInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for open orders with current mark price in USD
     totalCrossWalletBalance: NumberString,  // example: "126.72469206"  // crossed wallet balance in USD
     totalCrossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit of crossed positions in USD
     availableBalance: NumberString,  // example: "126.72469206"  // available balance in USD
     maxWithdrawAmount: NumberString,  // example: "126.72469206"  // maximum virtual amount for transfer out in USD
     assets: {
         asset: string,  // example: "USDT"  // asset name
         walletBalance: NumberString,  // example: "23.72469206"  // wallet balance
         unrealizedProfit: NumberString,  // example: "0.00000000"  // unrealized profit
         marginBalance: NumberString,  // example: "23.72469206"  // margin balance
         maintMargin: NumberString,  // example: "0.00000000"  // maintenance margin required
         initialMargin: NumberString,  // example: "0.00000000"  // total initial margin required with current mark price
         positionInitialMargin: NumberString,  // example: "0.00000000"  //initial margin required for positions with current mark price
         openOrderInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for open orders with current mark price
         crossWalletBalance: NumberString,  // example: "23.72469206"  // crossed wallet balance
         crossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit of crossed positions
         availableBalance: NumberString,  // example: "126.72469206"  // available balance
         maxWithdrawAmount: NumberString,  // example: "23.72469206"  // maximum amount for transfer out
         marginAvailable: boolean,  // example: true  // whether the asset can be used as margin in Multi-Assets mode
         updateTime: number  // example: 1625474304765  // last update time
       }[],
     positions: {
         symbol: string,  // example: "BTCUSDT"
         positionSide: PositionSide,  // example: "BOTH"  // position side
         positionAmt: NumberString,  // example: "1.000"
         unrealizedProfit: NumberString,  // example: "0.00000000"  // unrealized profit
         isolatedMargin: NumberString,  // example: "0.00000000"
         notional: NumberString,  // example: "0"
         isolatedWallet: NumberString,  // example: "0"
         initialMargin: NumberString,  // example: "0"  // initial margin required with current mark price
         maintMargin: NumberString,  // example: "0"  // maintenance margin required
         updateTime: number  // example: 0
       }[]
    }>;
  
  
  fapi_accountInformationV3(...args : any) {
      return this._sendRequest("/fapi/v3/account", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "fapi_accountInformationV3");
  }
  
  
  /** Account Information V2 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#account-information-v2-user_data}
   * 
   * EndPoint: /fapi/v2/account
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_accountInformationV2(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_accountInformationV2"]>;
  
  
  /** Account Information V2 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#account-information-v2-user_data}
   * 
   * EndPoint: /fapi/v2/account
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_accountInformationV2(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  // single-asset mode
     feeTier: number,  // example: 0  // account commission tier
     feeBurn: boolean,  // example: true  // "true": Fee Discount On; "false": Fee Discount Off
     canTrade: boolean,  // example: true  // if can trade
     canDeposit: boolean,  // example: true  // if can transfer in asset
     canWithdraw: boolean,  // example: true  // if can transfer out asset
     updateTime: number,  // example: 0  // reserved property, please ignore
     multiAssetsMargin: boolean,  // example: false
     tradeGroupId: number,  // example: -1
     totalInitialMargin: NumberString,  // example: "0.00000000"  // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
     totalMaintMargin: NumberString,  // example: "0.00000000"  // total maintenance margin required, only for USDT asset
     totalWalletBalance: NumberString,  // example: "23.72469206"  // total wallet balance, only for USDT asset
     totalUnrealizedProfit: NumberString,  // example: "0.00000000"  // total unrealized profit, only for USDT asset
     totalMarginBalance: NumberString,  // example: "23.72469206"  // total margin balance, only for USDT asset
     totalPositionInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for positions with current mark price, only for USDT asset
     totalOpenOrderInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for open orders with current mark price, only for USDT asset
     totalCrossWalletBalance: NumberString,  // example: "23.72469206"  // crossed wallet balance, only for USDT asset
     totalCrossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit of crossed positions, only for USDT asset
     availableBalance: NumberString,  // example: "23.72469206"  // available balance, only for USDT asset
     maxWithdrawAmount: NumberString,  // example: "23.72469206"  // maximum amount for transfer out, only for USDT asset
     assets: {
         asset: string,  // example: "USDT"  // asset name
         walletBalance: NumberString,  // example: "23.72469206"  // wallet balance
         unrealizedProfit: NumberString,  // example: "0.00000000"  // unrealized profit
         marginBalance: NumberString,  // example: "23.72469206"  // margin balance
         maintMargin: NumberString,  // example: "0.00000000"  // maintenance margin required
         initialMargin: NumberString,  // example: "0.00000000"  // total initial margin required with current mark price
         positionInitialMargin: NumberString,  // example: "0.00000000"  //initial margin required for positions with current mark price
         openOrderInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for open orders with current mark price
         crossWalletBalance: NumberString,  // example: "23.72469206"  // crossed wallet balance
         crossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit of crossed positions
         availableBalance: NumberString,  // example: "23.72469206"  // available balance
         maxWithdrawAmount: NumberString,  // example: "23.72469206"  // maximum amount for transfer out
         marginAvailable: boolean,  // example: true  // whether the asset can be used as margin in Multi-Assets mode
         updateTime: number  // example: 1625474304765  // last update time
       }[],
     positions: {
         symbol: string,  // example: "BTCUSDT"  // symbol name
         initialMargin: NumberString,  // example: "0"  // initial margin required with current mark price
         maintMargin: NumberString,  // example: "0"  // maintenance margin required
         unrealizedProfit: NumberString,  // example: "0.00000000"  // unrealized profit
         positionInitialMargin: NumberString,  // example: "0"  // initial margin required for positions with current mark price
         openOrderInitialMargin: NumberString,  // example: "0"  // initial margin required for open orders with current mark price
         leverage: NumberString,  // example: "100"  // current initial leverage
         isolated: boolean,  // example: true  // if the position is isolated
         entryPrice: NumberString,  // example: "0.00000"  // average entry price
         maxNotional: NumberString,  // example: "250000"  // maximum available notional with current leverage
         bidNotional: NumberString,  // example: "0"  // bids notional, ignore
         askNotional: NumberString,  // example: "0"  // ask notional, ignore
         positionSide: PositionSide,  // example: "BOTH"  // position side
         positionAmt: NumberString,  // example: "0"  // position amount
         updateTime: number  // example: 0  // last update time
       }[]
    } | {  // multi-assets mode
     feeTier: number,  // example: 0  // account commission tier
     feeBurn: boolean,  // example: true  // "true": Fee Discount On; "false": Fee Discount Off
     canTrade: boolean,  // example: true  // if can trade
     canDeposit: boolean,  // example: true  // if can transfer in asset
     canWithdraw: boolean,  // example: true  // if can transfer out asset
     updateTime: number,  // example: 0  // reserved property, please ignore
     multiAssetsMargin: boolean,  // example: true
     tradeGroupId: number,  // example: -1
     totalInitialMargin: NumberString,  // example: "0.00000000"  // the sum of USD value of all cross positions/open order initial margin
     totalMaintMargin: NumberString,  // example: "0.00000000"  // the sum of USD value of all cross positions maintenance margin
     totalWalletBalance: NumberString,  // example: "126.72469206"  // total wallet balance in USD
     totalUnrealizedProfit: NumberString,  // example: "0.00000000"  // total unrealized profit in USD
     totalMarginBalance: NumberString,  // example: "126.72469206"  // total margin balance in USD
     totalPositionInitialMargin: NumberString,  // example: "0.00000000"  // the sum of USD value of all cross positions initial margin
     totalOpenOrderInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for open orders with current mark price in USD
     totalCrossWalletBalance: NumberString,  // example: "126.72469206"  // crossed wallet balance in USD
     totalCrossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit of crossed positions in USD
     availableBalance: NumberString,  // example: "126.72469206"  // available balance in USD
     maxWithdrawAmount: NumberString,  // example: "126.72469206"  // maximum virtual amount for transfer out in USD
     assets: {
         asset: string,  // example: "USDT"  // asset name
         walletBalance: NumberString,  // example: "23.72469206"  // wallet balance
         unrealizedProfit: NumberString,  // example: "0.00000000"  // unrealized profit
         marginBalance: NumberString,  // example: "23.72469206"  // margin balance
         maintMargin: NumberString,  // example: "0.00000000"  // maintenance margin required
         initialMargin: NumberString,  // example: "0.00000000"  // total initial margin required with current mark price
         positionInitialMargin: NumberString,  // example: "0.00000000"  //initial margin required for positions with current mark price
         openOrderInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for open orders with current mark price
         crossWalletBalance: NumberString,  // example: "23.72469206"  // crossed wallet balance
         crossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit of crossed positions
         availableBalance: NumberString,  // example: "126.72469206"  // available balance
         maxWithdrawAmount: NumberString,  // example: "23.72469206"  // maximum amount for transfer out
         marginAvailable: boolean,  // example: true  // whether the asset can be used as margin in Multi-Assets mode
         updateTime: number  // example: 1625474304765  // last update time
       }[],
     positions: {
         symbol: string,  // example: "BTCUSDT"  // symbol name
         initialMargin: NumberString,  // example: "0"  // initial margin required with current mark price
         maintMargin: NumberString,  // example: "0"  // maintenance margin required
         unrealizedProfit: NumberString,  // example: "0.00000000"  // unrealized profit
         positionInitialMargin: NumberString,  // example: "0"  // initial margin required for positions with current mark price
         openOrderInitialMargin: NumberString,  // example: "0"  // initial margin required for open orders with current mark price
         leverage: NumberString,  // example: "100"  // current initial leverage
         isolated: boolean,  // example: true  // if the position is isolated
         entryPrice: NumberString,  // example: "0.00000"  // average entry price
         breakEvenPrice: NumberString,  // example: "0.0"  // average entry price
         maxNotional: NumberString,  // example: "250000"  // maximum available notional with current leverage
         bidNotional: NumberString,  // example: "0"  // bids notional, ignore
         askNotional: NumberString,  // example: "0"  // ask notional, ignore
         positionSide: PositionSide,  // example: "BOTH"  // position side
         positionAmt: NumberString,  // example: "0"  // position amount
         updateTime: number  // example: 0  // last update time
       }[]
    }>;
  
  
  fapi_accountInformationV2(...args : any) {
      return this._sendRequest("/fapi/v2/account", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "fapi_accountInformationV2");
  }
  
  
  /** Change Initial Leverage (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#change-initial-leverage-trade}
   * 
   * Change user's initial leverage of specific symbol market.
   * 
   * EndPoint: /fapi/v1/leverage
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {INT} leverage  -  target initial leverage: int from 1 to 125
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_changeInitialLeverage(symbol :string, leverage :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_changeInitialLeverage"]>;
  
  
  /** Change Initial Leverage (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#change-initial-leverage-trade}
   * 
   * Change user's initial leverage of specific symbol market.
   * 
   * EndPoint: /fapi/v1/leverage
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {INT} options.leverage  -  target initial leverage: int from 1 to 125
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_changeInitialLeverage(options : { symbol :string, leverage :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     leverage: number,  // example: 21
     maxNotionalValue: NumberString,  // example: "1000000"
     symbol: string  // example: "BTCUSDT"
    }>;
  
  
  fapi_changeInitialLeverage(...args : any) {
      return this._sendRequest("/fapi/v1/leverage", "POST", "TRADE", false, args, ["symbol", "leverage", "recvWindow", "timestamp"], "fapi_changeInitialLeverage");
  }
  
  
  /** Change Margin Type (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#change-margin-type-trade}
   * 
   * EndPoint: /fapi/v1/marginType
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {"ISOLATED"|"CROSSED"} marginType  -  ISOLATED, CROSSED
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_changeMarginType(symbol :string, marginType :"ISOLATED"|"CROSSED", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_changeMarginType"]>;
  
  
  /** Change Margin Type (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#change-margin-type-trade}
   * 
   * EndPoint: /fapi/v1/marginType
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {"ISOLATED"|"CROSSED"} options.marginType  -  ISOLATED, CROSSED
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_changeMarginType(options : { symbol :string, marginType :"ISOLATED"|"CROSSED", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "success"
    }>;
  
  
  fapi_changeMarginType(...args : any) {
      return this._sendRequest("/fapi/v1/marginType", "POST", "TRADE", false, args, ["symbol", "marginType", "recvWindow", "timestamp"], "fapi_changeMarginType");
  }
  
  
  /** Modify Isolated Position Margin (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#modify-isolated-position-margin-trade}
   * 
   * EndPoint: /fapi/v1/positionMargin
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent with Hedge Mode.
   * @param {DECIMAL} amount
   * @param {INT} type  -  1: Add position margin，2: Reduce position margin
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_modifyIsolatedPositionMargin(symbol :string, positionSide :PositionSide|undefined, amount :DECIMAL, type :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_modifyIsolatedPositionMargin"]>;
  
  
  /** Modify Isolated Position Margin (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#modify-isolated-position-margin-trade}
   * 
   * EndPoint: /fapi/v1/positionMargin
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent with Hedge Mode.
   * @param {DECIMAL} options.amount
   * @param {INT} options.type  -  1: Add position margin，2: Reduce position margin
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_modifyIsolatedPositionMargin(options : { symbol :string, positionSide? :PositionSide, amount :DECIMAL, type :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     amount: number,  // example: 100
     code: number,    // example: 200
     msg: string,     // example: "Successfully modify position margin."
     type: number     // example: 1
    }>;
  
  
  fapi_modifyIsolatedPositionMargin(...args : any) {
      return this._sendRequest("/fapi/v1/positionMargin", "POST", "TRADE", false, args, ["symbol", "positionSide", "amount", "type", "recvWindow", "timestamp"], "fapi_modifyIsolatedPositionMargin");
  }
  
  
  /** Get Position Margin Change History (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-position-margin-change-history-trade}
   * 
   * EndPoint: /fapi/v1/positionMargin/history
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {INT} type  -  1: Add position margin，2: Reduce position margin
   * @param {LONG} startTime
   * @param {LONG} endTime  -  Default current time if not pass
   * @param {INT} limit  -  Default: 500
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getPositionMarginChangeHistory(symbol :string, type? :INT, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getPositionMarginChangeHistory"]>;
  
  
  /** Get Position Margin Change History (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-position-margin-change-history-trade}
   * 
   * EndPoint: /fapi/v1/positionMargin/history
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {INT} options.type  -  1: Add position margin，2: Reduce position margin
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime  -  Default current time if not pass
   * @param {INT} options.limit  -  Default: 500
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getPositionMarginChangeHistory(options : { symbol :string, type? :INT, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       type: number,  // example: 1
       deltaType: string,  // example: "USER_ADJUST"
       amount: NumberString,  // example: "23.36332311"
       asset: string,  // example: "USDT"
       time: number,  // example: 1578047897183
       positionSide: PositionSide  // example: "BOTH"
     }[]>;
  
  
  fapi_getPositionMarginChangeHistory(...args : any) {
      return this._sendRequest("/fapi/v1/positionMargin/history", "GET", "TRADE", false, args, ["symbol", "type", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "fapi_getPositionMarginChangeHistory");
  }
  
  
  /** Position Information V3 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#position-information-v3-user_data}
   * 
   * Get current position information(only symbol that has position or open orders will be returned).
   * 
   * EndPoint: /fapi/v3/positionRisk
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_positionInformationV3(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_positionInformationV3"]>;
  
  
  /** Position Information V3 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#position-information-v3-user_data}
   * 
   * Get current position information(only symbol that has position or open orders will be returned).
   * 
   * EndPoint: /fapi/v3/positionRisk
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_positionInformationV3(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  // For One-way position mode:
       symbol: string,  // example: "ADAUSDT"
       positionSide: PositionSide,  // example: "BOTH"  // position side
       positionAmt: NumberString,  // example: "30"
       entryPrice: NumberString,  // example: "0.385"
       breakEvenPrice: NumberString,  // example: "0.385077"
       markPrice: NumberString,  // example: "0.41047590"
       unRealizedProfit: NumberString,  // example: "0.76427700"  // unrealized profit
       liquidationPrice: NumberString,  // example: "0"
       isolatedMargin: NumberString,  // example: "0"
       notional: NumberString,  // example: "12.31427700"
       marginAsset: string,  // example: "USDT"
       isolatedWallet: NumberString,  // example: "0"
       initialMargin: NumberString,  // example: "0.61571385"  // initial margin required with current mark price
       maintMargin: NumberString,  // example: "0.08004280"  // maintenance margin required
       positionInitialMargin: NumberString,  // example: "0.61571385"  // initial margin required for positions with current mark price
       openOrderInitialMargin: NumberString,  // example: "0"  // initial margin required for open orders with current mark price
       adl: number,  // example: 2
       bidNotional: NumberString,  // example: "0"  // bids notional, ignore
       askNotional: NumberString,  // example: "0"  // ask notional, ignore
       updateTime: number  // example: 1720736417660
     }[] | {  // For Hedge position mode:
       symbol: string,  // example: "BTCUSDT"
       positionAmt: NumberString,  // example: "0.001"
       entryPrice: NumberString,  // example: "22185.2"
       breakEvenPrice: NumberString,  // example: "0.0"
       markPrice: NumberString,  // example: "21123.05052574"
       unRealizedProfit: NumberString,  // example: "-1.06214947"
       liquidationPrice: NumberString,  // example: "19731.45529116"
       leverage: NumberString,  // example: "4"
       maxNotionalValue: NumberString,  // example: "100000000"
       marginType: string,  // example: "cross"
       isolatedMargin: NumberString,  // example: "0.00000000"
       isAutoAddMargin: string,  // example: "false"
       positionSide: PositionSide,  // example: "LONG"
       notional: NumberString,  // example: "21.12305052"
       isolatedWallet: NumberString,  // example: "0"
       updateTime: number  // example: 1655217461579
     }[]>;
  
  
  fapi_positionInformationV3(...args : any) {
      return this._sendRequest("/fapi/v3/positionRisk", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "fapi_positionInformationV3");
  }
  
  
  /** Position Information V2 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#position-information-v2-user_data}
   * 
   * Get current position information.
   * 
   * EndPoint: /fapi/v2/positionRisk
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_positionInformationV2(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_positionInformationV2"]>;
  
  
  /** Position Information V2 (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#position-information-v2-user_data}
   * 
   * Get current position information.
   * 
   * EndPoint: /fapi/v2/positionRisk
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_positionInformationV2(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  // For One-way position mode:
       entryPrice: NumberString,  // example: "0.00000"
       breakEvenPrice: NumberString,  // example: "0.0"
       marginType: string,  // example: "isolated"
       isAutoAddMargin: string,  // example: "false"
       isolatedMargin: NumberString,  // example: "0.00000000"
       leverage: NumberString,  // example: "10"
       liquidationPrice: NumberString,  // example: "0"
       markPrice: NumberString,  // example: "6679.50671178"
       maxNotionalValue: NumberString,  // example: "20000000"
       positionAmt: NumberString,  // example: "0.000"
       notional: NumberString,  // example: "0"
       isolatedWallet: NumberString,  // example: "0"
       symbol: string,  // example: "BTCUSDT"
       unRealizedProfit: NumberString,  // example: "0.00000000"
       positionSide: PositionSide,  // example: "BOTH"
       updateTime: number  // example: 0
     }[] | {  // For Hedge position mode:
       symbol: string,  // example: "BTCUSDT"
       positionAmt: NumberString,  // example: "0.001"
       entryPrice: NumberString,  // example: "22185.2"
       breakEvenPrice: NumberString,  // example: "0.0"
       markPrice: NumberString,  // example: "21123.05052574"
       unRealizedProfit: NumberString,  // example: "-1.06214947"
       liquidationPrice: NumberString,  // example: "19731.45529116"
       leverage: NumberString,  // example: "4"
       maxNotionalValue: NumberString,  // example: "100000000"
       marginType: string,  // example: "cross"
       isolatedMargin: NumberString,  // example: "0.00000000"
       isAutoAddMargin: string,  // example: "false"
       positionSide: PositionSide,  // example: "LONG"
       notional: NumberString,  // example: "21.12305052"
       isolatedWallet: NumberString,  // example: "0"
       updateTime: number  // example: 1655217461579
     }[]>;
  
  
  fapi_positionInformationV2(...args : any) {
      return this._sendRequest("/fapi/v2/positionRisk", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "fapi_positionInformationV2");
  }
  
  
  /** Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#account-trade-list-user_data}
   * 
   * Get trades for a specific account and symbol.
   * 
   * EndPoint: /fapi/v1/userTrades
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} orderId  -  This can only be used in combination with symbol
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} fromId  -  Trade id to fetch from. Default gets most recent trades.
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_accountTradeList(symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_accountTradeList"]>;
  
  
  /** Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#account-trade-list-user_data}
   * 
   * Get trades for a specific account and symbol.
   * 
   * EndPoint: /fapi/v1/userTrades
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId  -  This can only be used in combination with symbol
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.fromId  -  Trade id to fetch from. Default gets most recent trades.
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_accountTradeList(options : { symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       buyer: boolean,  // example: false
       commission: NumberString,  // example: "-0.07819010"
       commissionAsset: string,  // example: "USDT"
       id: number,  // example: 698759
       maker: boolean,  // example: false
       orderId: number,  // example: 25851813
       price: NumberString,  // example: "7819.01"
       qty: NumberString,  // example: "0.002"
       quoteQty: NumberString,  // example: "15.63802"
       realizedPnl: NumberString,  // example: "-0.91539999"
       side: OrderSide,  // example: "SELL"
       positionSide: PositionSide,  // example: "SHORT"
       symbol: string,  // example: "BTCUSDT"
       time: number  // example: 1569514978020
     }[]>;
  
  
  fapi_accountTradeList(...args : any) {
      return this._sendRequest("/fapi/v1/userTrades", "GET", "USER_DATA", false, args, ["symbol", "orderId", "startTime", "endTime", "fromId", "limit", "recvWindow", "timestamp"], "fapi_accountTradeList");
  }
  
  
  /** Get Income History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-income-history-user_data}
   * 
   * EndPoint: /fapi/v1/income
   * 
   * Weight(IP): 30
   * 
   * @param {string} symbol
   * @param {string} incomeType  -  TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
   * @param {LONG} startTime  -  Timestamp in ms to get funding from INCLUSIVE.
   * @param {LONG} endTime  -  Timestamp in ms to get funding until INCLUSIVE.
   * @param {INT} page
   * @param {INT} limit  -  Default 100; max 1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getIncomeHistory(symbol? :string, incomeType? :string, startTime? :LONG, endTime? :LONG, page? :INT, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getIncomeHistory"]>;
  
  
  /** Get Income History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-income-history-user_data}
   * 
   * EndPoint: /fapi/v1/income
   * 
   * Weight(IP): 30
   * 
   * @param {string} options.symbol
   * @param {string} options.incomeType  -  TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
   * @param {LONG} options.startTime  -  Timestamp in ms to get funding from INCLUSIVE.
   * @param {LONG} options.endTime  -  Timestamp in ms to get funding until INCLUSIVE.
   * @param {INT} options.page
   * @param {INT} options.limit  -  Default 100; max 1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getIncomeHistory(options? : { symbol? :string, incomeType? :string, startTime? :LONG, endTime? :LONG, page? :INT, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: ""  // trade symbol, if existing
       incomeType: string,  // example: "TRANSFER"  // income type
       income: NumberString,  // example: "-0.37500000"  // income amount
       asset: string,  // example: "USDT"  // income asset
       info: string,  // example: "TRANSFER"  // extra information
       time: number,  // example: 1570608000000
       tranId: NumberString,  // example: "9689322392"  // transaction id
       tradeId: string  // example: ""  // trade id, if existing
     } |
     {
       symbol: string,  // example: "BTCUSDT"
       incomeType: string,  // example: "COMMISSION"
       income: NumberString,  // example: "-0.01000000"
       asset: string,  // example: "USDT"
       info: string,  // example: "COMMISSION"
       time: number,  // example: 1570636800000
       tranId: NumberString,  // example: "9689322392"
       tradeId: number  // example: 2059192
     }
    )[]>;
  
  
  fapi_getIncomeHistory(...args : any) {
      return this._sendRequest("/fapi/v1/income", "GET", "USER_DATA", false, args, ["symbol", "incomeType", "startTime", "endTime", "page", "limit", "recvWindow", "timestamp"], "fapi_getIncomeHistory");
  }
  
  
  /** Notional and Leverage Brackets (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#notional-and-leverage-brackets-user_data}
   * 
   * EndPoint: /fapi/v1/leverageBracket
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_notionalAndLeverageBrackets(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_notionalAndLeverageBrackets"]>;
  
  
  /** Notional and Leverage Brackets (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#notional-and-leverage-brackets-user_data}
   * 
   * EndPoint: /fapi/v1/leverageBracket
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_notionalAndLeverageBrackets(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "ETHUSDT"
       notionalCoef: number,  // example: 1.5  //user symbol bracket multiplier, only appears when user's symbol bracket is adjusted
       brackets: {
           bracket: number,  // example: 1  // Notional bracket
           initialLeverage: number,  // example: 75  // Max initial leverage for this bracket
           notionalCap: number,  // example: 10000  // Cap notional of this bracket
           notionalFloor: number,  // example: 0  // Notional threshold of this bracket
           maintMarginRatio: number,  // example: 0.0065  // Maintenance ratio for this bracket
           cum: number  // example: 0  // Auxiliary number for quick calculation
         }[]
     }[] | {  // (if symbol sent)
     symbol: string,  // example: "ETHUSDT"
     notionalCoef: number,  // example: 1.5
     brackets: {
         bracket: number,  // example: 1
         initialLeverage: number,  // example: 75
         notionalCap: number,  // example: 10000
         notionalFloor: number,  // example: 0
         maintMarginRatio: number,  // example: 0.0065
         cum: number  // example: 0
       }[]
    }>;
  
  
  fapi_notionalAndLeverageBrackets(...args : any) {
      return this._sendRequest("/fapi/v1/leverageBracket", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "fapi_notionalAndLeverageBrackets");
  }
  
  
  /** Position ADL Quantile Estimation (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#position-adl-quantile-estimation-user_data}
   * 
   * EndPoint: /fapi/v1/adlQuantile
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_positionADLQuantileEstimation(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_positionADLQuantileEstimation"]>;
  
  
  /** Position ADL Quantile Estimation (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#position-adl-quantile-estimation-user_data}
   * 
   * EndPoint: /fapi/v1/adlQuantile
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_positionADLQuantileEstimation(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: "ETHUSDT"
       adlQuantile: {
         LONG: number,   // example: 3
         SHORT: number,  // example: 3
         HEDGE: number   // example: 0  // only a sign, ignore the value
       }
     } |
     {
       symbol: string,  // example: "BTCUSDT"
       adlQuantile: {
         LONG: number,   // example: 1  // adl quantile for "LONG" position in hedge mode
         SHORT: number,  // example: 2  // adl qauntile for "SHORT" position in hedge mode
         BOTH: number    // example: 0  // adl qunatile for position in one-way mode
       }
     }
    )[]>;
  
  
  fapi_positionADLQuantileEstimation(...args : any) {
      return this._sendRequest("/fapi/v1/adlQuantile", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "fapi_positionADLQuantileEstimation");
  }
  
  
  /** User's Force Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#user-39-s-force-orders-user_data}
   * 
   * EndPoint: /fapi/v1/forceOrders
   * 
   * Weight(IP): 20 with symbol, 50 without symbol
   * 
   * @param {string} symbol
   * @param {ENUM} autoCloseType  -  "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 50; max 100.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_userSForceOrders(symbol? :string, autoCloseType? :ENUM, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_userSForceOrders"]>;
  
  
  /** User's Force Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#user-39-s-force-orders-user_data}
   * 
   * EndPoint: /fapi/v1/forceOrders
   * 
   * Weight(IP): 20 with symbol, 50 without symbol
   * 
   * @param {string} options.symbol
   * @param {ENUM} options.autoCloseType  -  "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 50; max 100.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_userSForceOrders(options? : { symbol? :string, autoCloseType? :ENUM, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderId: number,  // example: 6071832819
       symbol: string,  // example: "BTCUSDT"
       status: string,  // example: "FILLED"
       clientOrderId: string,  // example: "autoclose-1596107620040000020"
       price: NumberString,  // example: "10871.09"
       avgPrice: NumberString,  // example: "10913.21000"
       origQty: NumberString,  // example: "0.001"
       executedQty: NumberString,  // example: "0.001"
       cumQuote: NumberString,  // example: "10.91321"
       timeInForce: TimeInForce,  // example: "IOC"
       type: OrderType,  // example: "LIMIT"
       reduceOnly: boolean,  // example: false
       closePosition: boolean,  // example: false
       side: OrderSide,  // example: "SELL"
       positionSide: PositionSide,  // example: "BOTH"
       stopPrice: NumberString,  // example: "0"
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       origType: string,  // example: "LIMIT"
       time: number,  // example: 1596107620044
       updateTime: number  // example: 1596107620087
     }[]>;
  
  
  fapi_userSForceOrders(...args : any) {
      return this._sendRequest("/fapi/v1/forceOrders", "GET", "USER_DATA", false, args, ["symbol", "autoCloseType", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "fapi_userSForceOrders");
  }
  
  
  /** Futures Trading Quantitative Rules Indicators (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#futures-trading-quantitative-rules-indicators-user_data}
   * 
   * EndPoint: /fapi/v1/apiTradingStatus
   * 
   * Weight(IP): 
   *   1 for a single symbol
   *   10 when the symbol parameter is omitted
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_futuresTradingQuantitativeRulesIndicators(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_futuresTradingQuantitativeRulesIndicators"]>;
  
  
  /** Futures Trading Quantitative Rules Indicators (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#futures-trading-quantitative-rules-indicators-user_data}
   * 
   * EndPoint: /fapi/v1/apiTradingStatus
   * 
   * Weight(IP): 
   *   1 for a single symbol
   *   10 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_futuresTradingQuantitativeRulesIndicators(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     indicators: {
       BTCUSDT: {
           isLocked: boolean,  // example: true
           plannedRecoverTime: number,  // example: 1545741270000
           indicator: string,  // example: "UFR"  // Unfilled Ratio (UFR)
           value: number,  // example: 0.05  // Current value
           triggerValue: number  // example: 0.995  // Trigger value
         }[],
       ETHUSDT: {
           isLocked: boolean,  // example: true
           plannedRecoverTime: number,  // example: 1545741270000
           indicator: string,  // example: "UFR"
           value: number,  // example: 0.05
           triggerValue: number  // example: 0.995
         }[]
     },
     updateTime: number  // example: 1545741270000
    } | {  // Or (account violation triggered)
     indicators: {
       ACCOUNT: {
           indicator: string,  // example: "TMV"  //  Too many violations under multiple symbols trigger account violation
           value: number,  // example: 10
           triggerValue: number,  // example: 1
           plannedRecoverTime: number,  // example: 1644919865000
           isLocked: boolean  // example: true
         }[]
     },
     updateTime: number  // example: 1644913304748
    }>;
  
  
  fapi_futuresTradingQuantitativeRulesIndicators(...args : any) {
      return this._sendRequest("/fapi/v1/apiTradingStatus", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "fapi_futuresTradingQuantitativeRulesIndicators");
  }
  
  
  /** Futures Account Configuration(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#futures-account-configuration-user_data}
   * 
   * Query account configuration
   * 
   * EndPoint: /fapi/v1/accountConfig
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_futuresAccountConfiguration(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_futuresAccountConfiguration"]>;
  
  
  /** Futures Account Configuration(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#futures-account-configuration-user_data}
   * 
   * Query account configuration
   * 
   * EndPoint: /fapi/v1/accountConfig
   * 
   * Weight(IP): 5
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_futuresAccountConfiguration(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     feeTier: number,  // example: 0  // account commission tier
     canTrade: boolean,  // example: true  // if can trade
     canDeposit: boolean,  // example: true  // if can transfer in asset
     canWithdraw: boolean,  // example: true  // if can transfer out asset
     dualSidePosition: boolean,  // example: true
     updateTime: number,  // example: 0  // reserved property, please ignore
     multiAssetsMargin: boolean,  // example: false
     tradeGroupId: number  // example: -1
    }>;
  
  
  fapi_futuresAccountConfiguration(...args : any) {
      return this._sendRequest("/fapi/v1/accountConfig", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "fapi_futuresAccountConfiguration");
  }
  
  
  /** Symbol Configuration(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#symbol-configuration-user_data}
   * 
   * Get current account symbol configuration.
   * 
   * EndPoint: /fapi/v1/symbolConfig
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_symbolConfiguration(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_symbolConfiguration"]>;
  
  
  /** Symbol Configuration(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#symbol-configuration-user_data}
   * 
   * Get current account symbol configuration.
   * 
   * EndPoint: /fapi/v1/symbolConfig
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_symbolConfiguration(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     feeTier: number,  // example: 0  // account commission tier
     canTrade: boolean,  // example: true  // if can trade
     canDeposit: boolean,  // example: true  // if can transfer in asset
     canWithdraw: boolean,  // example: true  // if can transfer out asset
     dualSidePosition: boolean,  // example: true
     updateTime: number,  // example: 0  // reserved property, please ignore
     multiAssetsMargin: boolean,  // example: false
     tradeGroupId: number  // example: -1
    }>;
  
  
  fapi_symbolConfiguration(...args : any) {
      return this._sendRequest("/fapi/v1/symbolConfig", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "fapi_symbolConfiguration");
  }
  
  
  /** User Commission Rate (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#user-commission-rate-user_data}
   * 
   * EndPoint: /fapi/v1/commissionRate
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_userCommissionRate(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_userCommissionRate"]>;
  
  
  /** User Commission Rate (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#user-commission-rate-user_data}
   * 
   * EndPoint: /fapi/v1/commissionRate
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_userCommissionRate(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     makerCommissionRate: NumberString,  // example: "0.0002"  // 0.02%
     takerCommissionRate: NumberString  // example: "0.0004"  // 0.04%
    }>;
  
  
  fapi_userCommissionRate(...args : any) {
      return this._sendRequest("/fapi/v1/commissionRate", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "fapi_userCommissionRate");
  }
  
  
  /** Query User Rate Limit (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#query-user-rate-limit-user_data}
   * 
   * EndPoint: /fapi/v1/rateLimit/order
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_queryUserRateLimit(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["fapi_queryUserRateLimit"]>;
  
  
  /** Query User Rate Limit (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#query-user-rate-limit-user_data}
   * 
   * EndPoint: /fapi/v1/rateLimit/order
   * 
   * Weight(IP): 1
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_queryUserRateLimit(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       rateLimitType: RateLimitType,  // example: "ORDERS"
       interval: RateLimitInterval,  // example: "SECOND"
       intervalNum: number,  // example: 10
       limit: number  // example: 10000
     }[]>;
  
  
  fapi_queryUserRateLimit(...args : any) {
      return this._sendRequest("/fapi/v1/rateLimit/order", "GET", "USER_DATA", false, args, ["recvWindow", "timestamp"], "fapi_queryUserRateLimit");
  }
  
  
  /** Get Download Id For Futures Transaction History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-download-id-for-futures-transaction-history-user_data}
   * 
   * EndPoint: /fapi/v1/income/asyn
   * 
   * Weight(IP): 1500
   * 
   * @param {LONG} startTime  -  Timestamp in ms
   * @param {LONG} endTime  -  Timestamp in ms
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getDownloadIdForFuturesTransactionHistory(startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getDownloadIdForFuturesTransactionHistory"]>;
  
  
  /** Get Download Id For Futures Transaction History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-download-id-for-futures-transaction-history-user_data}
   * 
   * EndPoint: /fapi/v1/income/asyn
   * 
   * Weight(IP): 1500
   * 
   * @param {LONG} options.startTime  -  Timestamp in ms
   * @param {LONG} options.endTime  -  Timestamp in ms
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getDownloadIdForFuturesTransactionHistory(options : { startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgCostTimestampOfLast30d: number,  // example: 7241837  // Average time taken for data download in the past 30 days
     downloadId: NumberString  // example: "546975389218332672"
    }>;
  
  
  fapi_getDownloadIdForFuturesTransactionHistory(...args : any) {
      return this._sendRequest("/fapi/v1/income/asyn", "GET", "USER_DATA", false, args, ["startTime", "endTime", "recvWindow", "timestamp"], "fapi_getDownloadIdForFuturesTransactionHistory");
  }
  
  
  /** Get Futures Transaction History Download Link by Id (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-futures-transaction-history-download-link-by-id-user_data}
   * 
   * EndPoint: /fapi/v1/income/asyn/id
   * 
   * Weight(IP): 10
   * 
   * @param {string} downloadId  -  get by download id api
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getFuturesTransactionHistoryDownloadLinkById(downloadId :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getFuturesTransactionHistoryDownloadLinkById"]>;
  
  
  /** Get Futures Transaction History Download Link by Id (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-futures-transaction-history-download-link-by-id-user_data}
   * 
   * EndPoint: /fapi/v1/income/asyn/id
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.downloadId  -  get by download id api
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getFuturesTransactionHistoryDownloadLinkById(options : { downloadId :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     downloadId: NumberString,  // example: "545923594199212032"
     status: string,  // example: "completed"  // Enum:completed,processing
     url: string,  // example: "www.binance.com"  // The link is mapped to download id
     notified: boolean,  // example: true  // ignore
     expirationTimestamp: number,  // example: 1645009771000  // The link would expire after this timestamp
     isExpired: null  // example: null
    }>;
  
  
  fapi_getFuturesTransactionHistoryDownloadLinkById(...args : any) {
      return this._sendRequest("/fapi/v1/income/asyn/id", "GET", "USER_DATA", false, args, ["downloadId", "recvWindow", "timestamp"], "fapi_getFuturesTransactionHistoryDownloadLinkById");
  }
  
  
  /** Get Download Id For Futures Order History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-download-id-for-futures-order-history-user_data}
   * 
   * EndPoint: /fapi/v1/order/asyn
   * 
   * Weight(IP): 1500
   * 
   * @param {LONG} startTime  -  Timestamp in ms
   * @param {LONG} endTime  -  Timestamp in ms
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getDownloadIdForFuturesOrderHistory(startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getDownloadIdForFuturesOrderHistory"]>;
  
  
  /** Get Download Id For Futures Order History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-download-id-for-futures-order-history-user_data}
   * 
   * EndPoint: /fapi/v1/order/asyn
   * 
   * Weight(IP): 1500
   * 
   * @param {LONG} options.startTime  -  Timestamp in ms
   * @param {LONG} options.endTime  -  Timestamp in ms
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getDownloadIdForFuturesOrderHistory(options : { startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgCostTimestampOfLast30d: number,  // example: 7241837  // Average time taken for data download in the past 30 days
     downloadId: NumberString  // example: "546975389218332672"
    }>;
  
  
  fapi_getDownloadIdForFuturesOrderHistory(...args : any) {
      return this._sendRequest("/fapi/v1/order/asyn", "GET", "USER_DATA", false, args, ["startTime", "endTime", "recvWindow", "timestamp"], "fapi_getDownloadIdForFuturesOrderHistory");
  }
  
  
  /** Get Futures Order History Download Link by Id (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-futures-order-history-download-link-by-id-user_data}
   * 
   * EndPoint: /fapi/v1/order/asyn/id
   * 
   * Weight(IP): 10
   * 
   * @param {string} downloadId  -  get by download id api
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getFuturesOrderHistoryDownloadLinkById(downloadId :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getFuturesOrderHistoryDownloadLinkById"]>;
  
  
  /** Get Futures Order History Download Link by Id (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-futures-order-history-download-link-by-id-user_data}
   * 
   * EndPoint: /fapi/v1/order/asyn/id
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.downloadId  -  get by download id api
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getFuturesOrderHistoryDownloadLinkById(options : { downloadId :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     downloadId: NumberString,  // example: "545923594199212032"
     status: string,  // example: "completed"  // Enum:completed,processing
     url: string,  // example: "www.binance.com"  // The link is mapped to download id
     notified: boolean,  // example: true  // ignore
     expirationTimestamp: number,  // example: 1645009771000  // The link would expire after this timestamp
     isExpired: null  // example: null
    }>;
  
  
  fapi_getFuturesOrderHistoryDownloadLinkById(...args : any) {
      return this._sendRequest("/fapi/v1/order/asyn/id", "GET", "USER_DATA", false, args, ["downloadId", "recvWindow", "timestamp"], "fapi_getFuturesOrderHistoryDownloadLinkById");
  }
  
  
  /** Get Download Id For Futures Trade History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-download-id-for-futures-trade-history-user_data}
   * 
   * EndPoint: /fapi/v1/trade/asyn
   * 
   * Weight(IP): 1500
   * 
   * @param {LONG} startTime  -  Timestamp in ms
   * @param {LONG} endTime  -  Timestamp in ms
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getDownloadIdForFuturesTradeHistory(startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getDownloadIdForFuturesTradeHistory"]>;
  
  
  /** Get Download Id For Futures Trade History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-download-id-for-futures-trade-history-user_data}
   * 
   * EndPoint: /fapi/v1/trade/asyn
   * 
   * Weight(IP): 1500
   * 
   * @param {LONG} options.startTime  -  Timestamp in ms
   * @param {LONG} options.endTime  -  Timestamp in ms
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getDownloadIdForFuturesTradeHistory(options : { startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgCostTimestampOfLast30d: number,  // example: 7241837  // Average time taken for data download in the past 30 days
     downloadId: NumberString  // example: "546975389218332672"
    }>;
  
  
  fapi_getDownloadIdForFuturesTradeHistory(...args : any) {
      return this._sendRequest("/fapi/v1/trade/asyn", "GET", "USER_DATA", false, args, ["startTime", "endTime", "recvWindow", "timestamp"], "fapi_getDownloadIdForFuturesTradeHistory");
  }
  
  
  /** Get Futures Trade Download Link by Id (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-futures-trade-download-link-by-id-user_data}
   * 
   * EndPoint: /fapi/v1/trade/asyn/id
   * 
   * Weight(IP): 10
   * 
   * @param {string} downloadId  -  get by download id api
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_getFuturesTradeDownloadLinkById(downloadId :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_getFuturesTradeDownloadLinkById"]>;
  
  
  /** Get Futures Trade Download Link by Id (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#get-futures-trade-download-link-by-id-user_data}
   * 
   * EndPoint: /fapi/v1/trade/asyn/id
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.downloadId  -  get by download id api
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_getFuturesTradeDownloadLinkById(options : { downloadId :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     downloadId: NumberString,  // example: "545923594199212032"
     status: string,  // example: "completed"  // Enum:completed,processing
     url: string,  // example: "www.binance.com"  // The link is mapped to download id
     notified: boolean,  // example: true  // ignore
     expirationTimestamp: number,  // example: 1645009771000  // The link would expire after this timestamp
     isExpired: null  // example: null
    }>;
  
  
  fapi_getFuturesTradeDownloadLinkById(...args : any) {
      return this._sendRequest("/fapi/v1/trade/asyn/id", "GET", "USER_DATA", false, args, ["downloadId", "recvWindow", "timestamp"], "fapi_getFuturesTradeDownloadLinkById");
  }
  
  
  
  //***** User Data Streams *****
  
  
  /** Start User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#start-user-data-stream-user_stream}
   * 
   * EndPoint: /fapi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  fapi_startUserDataStream() : Promise<{
     listenKey: string  // example: "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
    }> {
      return this._sendRequest("/fapi/v1/listenKey", "POST", "USER_STREAM", false, [], [], "fapi_startUserDataStream");
  }
  
  
  /** Keepalive User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#keepalive-user-data-stream-user_stream}
   * 
   * EndPoint: /fapi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  fapi_keepaliveUserDataStream() : Promise<{
     listenKey: string  // example: "3HBntNTepshgEdjIwSUIBgB9keLyOCg5qv3n6bYAtktG8ejcaW5HXz9Vx1JgIieg"  //the listenkey which got extended
    }> {
      return this._sendRequest("/fapi/v1/listenKey", "PUT", "USER_STREAM", false, [], [], "fapi_keepaliveUserDataStream");
  }
  
  
  /** Close User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#close-user-data-stream-user_stream}
   * 
   * Close out a user data stream.
   * 
   * EndPoint: /fapi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  fapi_closeUserDataStream() : Promise<{
    }> {
      return this._sendRequest("/fapi/v1/listenKey", "DELETE", "USER_STREAM", false, [], [], "fapi_closeUserDataStream");
  }
  
  
  
  //***** Portfolio Margin Pro Endpoints *****
  
  
  /** Portfolio Margin Pro Account Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#portfolio-margin-pro-account-information-user_data}
   * 
   * Get Portfolio Margin Pro current account information.
   * 
   * EndPoint: /fapi/v1/pmAccountInfo
   * 
   * Weight(IP): 5
   * 
   * @param {string} asset
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  fapi_portfolioMarginProAccountInformation(asset :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["fapi_portfolioMarginProAccountInformation"]>;
  
  
  /** Portfolio Margin Pro Account Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/futures/en/#portfolio-margin-pro-account-information-user_data}
   * 
   * Get Portfolio Margin Pro current account information.
   * 
   * EndPoint: /fapi/v1/pmAccountInfo
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.asset
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  fapi_portfolioMarginProAccountInformation(options : { asset :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     maxWithdrawAmountUSD: NumberString,  // example: "1627523.32459208"  // Portfolio Margin Pro maximum virtual amount for transfer out in USD
     asset: string,  // example: "BTC"  // asset name
     maxWithdrawAmount: NumberString  // example: "27.43689636"  // Please ignore
    }>;
  
  
  fapi_portfolioMarginProAccountInformation(...args : any) {
      return this._sendRequest("/fapi/v1/pmAccountInfo", "GET", "USER_DATA", false, args, ["asset", "recvWindow", "timestamp"], "fapi_portfolioMarginProAccountInformation");
  }
  
  
  
  //======== COIN FUTURES ========
  
  
  //***** Market Data Endpoints *****
  
  
  /** Test Connectivity
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#test-connectivity}
   * 
   * Test connectivity to the Rest API.
   * 
   * EndPoint: /dapi/v1/ping
   * 
   * Weight(IP): 1
   * 
   */
  dapi_testConnectivity() : Promise<{
    }> {
      return this._sendRequest("/dapi/v1/ping", "GET", "MARKET_DATA", false, [], [], "dapi_testConnectivity");
  }
  
  
  /** Check Server time
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#check-server-time}
   * 
   * Test connectivity to the Rest API and get the current server time.
   * 
   * EndPoint: /dapi/v1/time
   * 
   * Weight(IP): 1
   * 
   */
  dapi_checkServerTime() : Promise<{
     serverTime: number  // example: 1499827319559
    }> {
      return this._sendRequest("/dapi/v1/time", "GET", "MARKET_DATA", false, [], [], "dapi_checkServerTime");
  }
  
  
  /** Exchange Information
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#exchange-information}
   * 
   * Current exchange trading rules and symbol information
   * 
   * EndPoint: /dapi/v1/exchangeInfo
   * 
   * Weight(IP): 1
   * 
   */
  dapi_exchangeInformation() : Promise<{
     exchangeFilters: unknown[],
     rateLimits: {
         interval: RateLimitInterval,  // example: "MINUTE"
         intervalNum: number,  // example: 1
         limit: number,  // example: 6000
         rateLimitType: RateLimitType  // example: "REQUEST_WEIGHT"
       }[],
     serverTime: number,  // example: 1565613908500  // Ignore please. If you want to check current server time, please check via "GET /dapi/v1/time"
     symbols: {
         filters: (
           {
             filterType: "PRICE_FILTER",  // example: "PRICE_FILTER"
             maxPrice: NumberString,  // example: "100000"
             minPrice: NumberString,  // example: "0.1"
             tickSize: NumberString  // example: "0.1"
           } |
           {
             filterType: "LOT_SIZE",  // example: "LOT_SIZE"
             maxQty: NumberString,  // example: "100000"
             minQty: NumberString,  // example: "1"
             stepSize: NumberString  // example: "1"
           } |
           {
             filterType: "MARKET_LOT_SIZE",  // example: "MARKET_LOT_SIZE"
             maxQty: NumberString,  // example: "100000"
             minQty: NumberString,  // example: "1"
             stepSize: NumberString  // example: "1"
           } |
           {
             filterType: "MAX_NUM_ORDERS",  // example: "MAX_NUM_ORDERS"
             limit: number  // example: 200
           } |
           {
             filterType: "PERCENT_PRICE",  // example: "PERCENT_PRICE"
             multiplierUp: NumberString,  // example: "1.0500"
             multiplierDown: NumberString,  // example: "0.9500"
             multiplierDecimal: number  // example: 4
           }
         )[],
         OrderType: string[]  // example: "LIMIT",
         timeInForce: TimeInForce[]  // example: "GTC",
         liquidationFee: NumberString,  // example: "0.010000"  // liquidation fee rate
         marketTakeBound: NumberString,  // example: "0.30"  // the max price difference rate( from mark price) a market order can make
         symbol: string,  // example: "BTCUSD_200925"  // contract symbol name
         pair: string,  // example: "BTCUSD"  // underlying symbol
         contractType: string,  // example: "CURRENT_QUARTER"
         deliveryDate: number,  // example: 1601020800000
         onboardDate: number,  // example: 1590739200000
         contractStatus: string,  // example: "TRADING"
         contractSize: number,  // example: 100
         quoteAsset: string,  // example: "USD"
         baseAsset: string,  // example: "BTC"
         marginAsset: string,  // example: "BTC"
         pricePrecision: number,  // example: 1  // please do not use it as tickSize
         quantityPrecision: number,  // example: 0  // please do not use it as stepSize
         baseAssetPrecision: number,  // example: 8
         quotePrecision: number,  // example: 8
         equalQtyPrecision: number,  // example: 4  // ignore
         triggerProtect: NumberString,  // example: "0.0500"  // threshold for algo order with "priceProtect"
         maintMarginPercent: NumberString,  // example: "2.5000"  // ignore
         requiredMarginPercent: NumberString,  // example: "5.0000"  // ignore
         underlyingType: string,  // example: "COIN"
         underlyingSubType: unknown[]
       }[],
     timezone: string  // example: "UTC"
    }> {
      return this._sendRequest("/dapi/v1/exchangeInfo", "GET", "MARKET_DATA", false, [], [], "dapi_exchangeInformation");
  }
  
  
  /** Order Book
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#order-book}
   * 
   * Adjusted based on the limit:
   * 
   * EndPoint: /dapi/v1/depth
   * 
   * Weight(IP): Adjusted based on the limit:
   *   Limit         Weight
   *   5, 10, 20, 50 2     
   *   100           5     
   *   500           10    
   *   1000          20    
   * 
   * @param {string} symbol
   * @param {INT} limit  -  Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
   */
  dapi_orderBook(symbol :string, limit? :INT)  : ReturnType<MyBinanceClient["dapi_orderBook"]>;
  
  
  /** Order Book
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#order-book}
   * 
   * Adjusted based on the limit:
   * 
   * EndPoint: /dapi/v1/depth
   * 
   * Weight(IP): Adjusted based on the limit:
   *   Limit         Weight
   *   5, 10, 20, 50 2     
   *   100           5     
   *   500           10    
   *   1000          20    
   * 
   * @param {string} options.symbol
   * @param {INT} options.limit  -  Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
   */
  dapi_orderBook(options : { symbol :string, limit? :INT })
  : Promise<{
     lastUpdateId: number,  // example: 16769853
     symbol: string,  // example: "BTCUSD_PERP"  // Symbol
     pair: string,  // example: "BTCUSD"  // Pair
     E: number,  // example: 1591250106370  // Message output time
     T: number,  // example: 1591250106368  // Transaction time
     bids: NumberString[]  // example: "9638.0"  // PRICE[],
     asks: NumberString[]  // example: "9638.2"[]
    }>;
  
  
  dapi_orderBook(...args : any) {
      return this._sendRequest("/dapi/v1/depth", "GET", "MARKET_DATA", false, args, ["symbol", "limit"], "dapi_orderBook");
  }
  
  
  /** Recent Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#recent-trades-list}
   * 
   * Get recent market trades
   * 
   * EndPoint: /dapi/v1/trades
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {INT} limit  -  Default 500; max 1000.
   */
  dapi_recentTradesList(symbol :string, limit? :INT)  : ReturnType<MyBinanceClient["dapi_recentTradesList"]>;
  
  
  /** Recent Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#recent-trades-list}
   * 
   * Get recent market trades
   * 
   * EndPoint: /dapi/v1/trades
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {INT} options.limit  -  Default 500; max 1000.
   */
  dapi_recentTradesList(options : { symbol :string, limit? :INT })
  : Promise<{
       id: number,  // example: 28457
       price: NumberString,  // example: "9635.0"
       qty: NumberString,  // example: "1"
       baseQty: NumberString,  // example: "0.01037883"
       time: number,  // example: 1591250192508
       isBuyerMaker: boolean  // example: true
     }[]>;
  
  
  dapi_recentTradesList(...args : any) {
      return this._sendRequest("/dapi/v1/trades", "GET", "MARKET_DATA", false, args, ["symbol", "limit"], "dapi_recentTradesList");
  }
  
  
  /** Old Trades Lookup (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#old-trades-lookup-market_data}
   * 
   * Get older market historical trades.
   * 
   * EndPoint: /dapi/v1/historicalTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} fromId  -  TradeId to fetch from. Default gets most recent trades.
   */
  dapi_oldTradesLookup(symbol :string, limit? :INT, fromId? :LONG)  : ReturnType<MyBinanceClient["dapi_oldTradesLookup"]>;
  
  
  /** Old Trades Lookup (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#old-trades-lookup-market_data}
   * 
   * Get older market historical trades.
   * 
   * EndPoint: /dapi/v1/historicalTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.fromId  -  TradeId to fetch from. Default gets most recent trades.
   */
  dapi_oldTradesLookup(options : { symbol :string, limit? :INT, fromId? :LONG })
  : Promise<{
       id: number,  // example: 595103
       price: NumberString,  // example: "9642.2"
       qty: NumberString,  // example: "1"
       baseQty: NumberString,  // example: "0.01037108"
       time: number,  // example: 1499865549590
       isBuyerMaker: boolean  // example: true
     }[]>;
  
  
  dapi_oldTradesLookup(...args : any) {
      return this._sendRequest("/dapi/v1/historicalTrades", "GET", "MARKET_DATA", false, args, ["symbol", "limit", "fromId"], "dapi_oldTradesLookup");
  }
  
  
  /** Compressed/Aggregate Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#compressed-aggregate-trades-list}
   * 
   * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
   * 
   * EndPoint: /dapi/v1/aggTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol
   * @param {LONG} fromId  -  ID to get aggregate trades from INCLUSIVE.
   * @param {LONG} startTime  -  Timestamp in ms to get aggregate trades from INCLUSIVE.
   * @param {LONG} endTime  -  Timestamp in ms to get aggregate trades until INCLUSIVE.
   * @param {INT} limit  -  Default 500; max 1000.
   */
  dapi_compressedAggregateTradesList(symbol :string, fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["dapi_compressedAggregateTradesList"]>;
  
  
  /** Compressed/Aggregate Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#compressed-aggregate-trades-list}
   * 
   * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
   * 
   * EndPoint: /dapi/v1/aggTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol
   * @param {LONG} options.fromId  -  ID to get aggregate trades from INCLUSIVE.
   * @param {LONG} options.startTime  -  Timestamp in ms to get aggregate trades from INCLUSIVE.
   * @param {LONG} options.endTime  -  Timestamp in ms to get aggregate trades until INCLUSIVE.
   * @param {INT} options.limit  -  Default 500; max 1000.
   */
  dapi_compressedAggregateTradesList(options : { symbol :string, fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<{
       a: number,  // example: 416690  // Aggregate tradeId
       p: NumberString,  // example: "9642.4"  // Price
       q: NumberString,  // example: "3"  // Quantity
       f: number,  // example: 595259  // First tradeId
       l: number,  // example: 595259  // Last tradeId
       T: number,  // example: 1591250548649  // Timestamp
       m: boolean  // example: false  // Was the buyer the maker?
     }[]>;
  
  
  dapi_compressedAggregateTradesList(...args : any) {
      return this._sendRequest("/dapi/v1/aggTrades", "GET", "MARKET_DATA", false, args, ["symbol", "fromId", "startTime", "endTime", "limit"], "dapi_compressedAggregateTradesList");
  }
  
  
  /** Index Price and Mark Price
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#index-price-and-mark-price}
   * 
   * EndPoint: /dapi/v1/premiumIndex
   * 
   * Weight(IP): 10
   * 
   * @param {string} symbol
   * @param {string} pair
   */
  dapi_indexPriceAndMarkPrice(symbol? :string, pair? :string)
  : ReturnType<MyBinanceClient["dapi_indexPriceAndMarkPrice"]>;
  
  
  /** Index Price and Mark Price
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#index-price-and-mark-price}
   * 
   * EndPoint: /dapi/v1/premiumIndex
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.symbol
   * @param {string} options.pair
   */
  dapi_indexPriceAndMarkPrice(options? : { symbol? :string, pair? :string })
  : Promise<(
     {
       symbol: string,  // example: "BTCUSD_PERP"
       pair: string,  // example: "BTCUSD"
       markPrice: NumberString,  // example: "11029.69574559"  // mark price
       indexPrice: NumberString,  // example: "10979.14437500"  // index price
       estimatedSettlePrice: NumberString,  // example: "10981.74168236"  // Estimated Settle Price, only useful in the last hour before the settlement starts.
       lastFundingRate: NumberString,  // example: "0.00071003"  // the lasted funding rate, for perpetual contract symbols only. For delivery symbols, "" will be shown.
       interestRate: NumberString,  // example: "0.00010000"  // the base asset interest rate, for perpetual contract symbols only. For delivery symbols, "" will be shown.
       nextFundingTime: number,  // example: 1596096000000  // For perpetual contract symbols only. For delivery symbols, 0 will be shown
       time: number  // example: 1596094042000
     } |
     {
       symbol: string,  // example: "BTCUSD_200925"
       pair: string,  // example: "BTCUSD"
       markPrice: NumberString,  // example: "12077.01343750"
       indexPrice: NumberString,  // example: "10979.10312500"
       estimatedSettlePrice: NumberString,  // example: "10981.74168236"
       lastFundingRate: string,  // example: ""
       interestRate: string,  // example: ""
       nextFundingTime: number,  // example: 0
       time: number  // example: 1596094042000
     }
    )[]>;
  
  
  dapi_indexPriceAndMarkPrice(...args : any) {
      return this._sendRequest("/dapi/v1/premiumIndex", "GET", "MARKET_DATA", false, args, ["symbol", "pair"], "dapi_indexPriceAndMarkPrice");
  }
  
  
  /** Get Funding Rate History of Perpetual Futures
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-funding-rate-history-of-perpetual-futures}
   * 
   * EndPoint: /dapi/v1/fundingRate
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} startTime  -  Timestamp in ms to get funding rate from INCLUSIVE.
   * @param {LONG} endTime  -  Timestamp in ms to get funding rate  until INCLUSIVE.
   * @param {INT} limit  -  Default 100; max 1000
   */
  dapi_getFundingRateHistoryOfPerpetualFutures(symbol :string, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["dapi_getFundingRateHistoryOfPerpetualFutures"]>;
  
  
  /** Get Funding Rate History of Perpetual Futures
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-funding-rate-history-of-perpetual-futures}
   * 
   * EndPoint: /dapi/v1/fundingRate
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.startTime  -  Timestamp in ms to get funding rate from INCLUSIVE.
   * @param {LONG} options.endTime  -  Timestamp in ms to get funding rate  until INCLUSIVE.
   * @param {INT} options.limit  -  Default 100; max 1000
   */
  dapi_getFundingRateHistoryOfPerpetualFutures(options : { symbol :string, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<{
       symbol: string,  // example: "BTCUSD_PERP"
       fundingTime: number,  // example: 1698768000000
       fundingRate: NumberString,  // example: "-0.00300000"
       markPrice: NumberString  // example: "34651.40000000"  // mark price associated with a particular funding fee charge
     }[]>;
  
  
  dapi_getFundingRateHistoryOfPerpetualFutures(...args : any) {
      return this._sendRequest("/dapi/v1/fundingRate", "GET", "MARKET_DATA", false, args, ["symbol", "startTime", "endTime", "limit"], "dapi_getFundingRateHistoryOfPerpetualFutures");
  }
  
  
  /** Get Funding Rate Info
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-funding-rate-info}
   * 
   * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
   * 
   * EndPoint: /dapi/v1/fundingInfo
   * 
   */
  dapi_getFundingRateInfo() : Promise<{
       symbol: string,  // example: "BLZUSDT"
       adjustedFundingRateCap: NumberString,  // example: "0.02500000"
       adjustedFundingRateFloor: NumberString,  // example: "-0.02500000"
       fundingIntervalHours: number,  // example: 8
       disclaimer: boolean  // example: false  // ingore
     }[]> {
      return this._sendRequest("/dapi/v1/fundingInfo", "GET", "MARKET_DATA", false, [], [], "dapi_getFundingRateInfo");
  }
  
  
  /** Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#kline-candlestick-data}
   * 
   * Kline/candlestick bars for a symbol. 
   * 
   * EndPoint: /dapi/v1/klines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} symbol
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1500.
   */
  dapi_klineCandlestickData(symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["dapi_klineCandlestickData"]>;
  
  
  /** Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#kline-candlestick-data}
   * 
   * Kline/candlestick bars for a symbol. 
   * 
   * EndPoint: /dapi/v1/klines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} options.symbol
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1500.
   */
  dapi_klineCandlestickData(options : { symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<[
       number,        // example: 1591258320000  // Open time
       NumberString,  // example: "9640.7"  // Open
       NumberString,  // example: "9642.4"  // High
       NumberString,  // example: "9640.6"  // Low
       NumberString,  // example: "9642.0"  // Close (or latest price)
       NumberString,  // example: "206"  // Volume
       number,        // example: 1591258379999  // Close time
       NumberString,  // example: "2.13660389"  // Base asset volume
       number,        // example: 48  // Number of trades
       NumberString,  // example: "119"  // Taker buy volume
       NumberString,  // example: "1.23424865"  // Taker buy base asset volume
       NumberString   // example: "0"  // Ignore.
     ][]>;
  
  
  dapi_klineCandlestickData(...args : any) {
      return this._sendRequest("/dapi/v1/klines", "GET", "MARKET_DATA", false, args, ["symbol", "interval", "startTime", "endTime", "limit"], "dapi_klineCandlestickData");
  }
  
  
  /** Continuous Contract Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#continuous-contract-kline-candlestick-data}
   * 
   * Kline/candlestick bars for a specific contract type.
   * 
   * EndPoint: /dapi/v1/continuousKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} pair
   * @param {ENUM} contractType
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1500.
   */
  dapi_continuousContractKlineCandlestickData(pair :string, contractType :ENUM, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["dapi_continuousContractKlineCandlestickData"]>;
  
  
  /** Continuous Contract Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#continuous-contract-kline-candlestick-data}
   * 
   * Kline/candlestick bars for a specific contract type.
   * 
   * EndPoint: /dapi/v1/continuousKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} options.pair
   * @param {ENUM} options.contractType
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1500.
   */
  dapi_continuousContractKlineCandlestickData(options : { pair :string, contractType :ENUM, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<[
       number,        // example: 1591258320000  // Open time
       NumberString,  // example: "9640.7"  // Open
       NumberString,  // example: "9642.4"  // High
       NumberString,  // example: "9640.6"  // Low
       NumberString,  // example: "9642.0"  // Close (or latest price)
       NumberString,  // example: "206"  // Volume
       number,        // example: 1591258379999  // Close time
       NumberString,  // example: "2.13660389"  // Base asset volume
       number,        // example: 48  // Number of trades
       NumberString,  // example: "119"  // Taker buy volume
       NumberString,  // example: "1.23424865"  // Taker buy base asset volume
       NumberString   // example: "0"  // Ignore.
     ][]>;
  
  
  dapi_continuousContractKlineCandlestickData(...args : any) {
      return this._sendRequest("/dapi/v1/continuousKlines", "GET", "MARKET_DATA", false, args, ["pair", "contractType", "interval", "startTime", "endTime", "limit"], "dapi_continuousContractKlineCandlestickData");
  }
  
  
  /** Index Price Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#index-price-kline-candlestick-data}
   * 
   * Kline/candlestick bars for the index price of a pair.
   * 
   * EndPoint: /dapi/v1/indexPriceKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} pair
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1500.
   */
  dapi_indexPriceKlineCandlestickData(pair :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["dapi_indexPriceKlineCandlestickData"]>;
  
  
  /** Index Price Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#index-price-kline-candlestick-data}
   * 
   * Kline/candlestick bars for the index price of a pair.
   * 
   * EndPoint: /dapi/v1/indexPriceKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} options.pair
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1500.
   */
  dapi_indexPriceKlineCandlestickData(options : { pair :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<[
       number,        // example: 1591256400000  // Open time
       NumberString,  // example: "9653.69440000"  // Open
       NumberString,  // example: "9653.69640000"  // High
       NumberString,  // example: "9651.38600000"  // Low
       NumberString,  // example: "9651.55200000"  // Close (or latest price)
       NumberString,  // example: "0  "  // Ignore
       number,        // example: 1591256459999  // Close time
       NumberString,  // example: "0"  // Ignore
       number,        // example: 60  // Number of bisic data
       NumberString,  // example: "0"  // Ignore
       NumberString,  // example: "0"  // Ignore
       NumberString   // example: "0"  // Ignore
     ][]>;
  
  
  dapi_indexPriceKlineCandlestickData(...args : any) {
      return this._sendRequest("/dapi/v1/indexPriceKlines", "GET", "MARKET_DATA", false, args, ["pair", "interval", "startTime", "endTime", "limit"], "dapi_indexPriceKlineCandlestickData");
  }
  
  
  /** Mark Price Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#mark-price-kline-candlestick-data}
   * 
   * Kline/candlestick bars for the mark price of a symbol.
   * 
   * EndPoint: /dapi/v1/markPriceKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} symbol
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1500.
   */
  dapi_markPriceKlineCandlestickData(symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["dapi_markPriceKlineCandlestickData"]>;
  
  
  /** Mark Price Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#mark-price-kline-candlestick-data}
   * 
   * Kline/candlestick bars for the mark price of a symbol.
   * 
   * EndPoint: /dapi/v1/markPriceKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} options.symbol
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1500.
   */
  dapi_markPriceKlineCandlestickData(options : { symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<[
       number,        // example: 1591256460000  // Open time
       NumberString,  // example: "9653.29201333"  // Open
       NumberString,  // example: "9654.56401333"  // High
       NumberString,  // example: "9653.07367333"  // Low
       NumberString,  // example: "9653.07367333"  // Close (or latest price)
       NumberString,  // example: "0  "  // Ignore
       number,        // example: 1591256519999  // Close time
       NumberString,  // example: "0"  // Ignore
       number,        // example: 60  // Number of bisic data
       NumberString,  // example: "0"  // Ignore
       NumberString,  // example: "0"  // Ignore
       NumberString   // example: "0"  // Ignore
     ][]>;
  
  
  dapi_markPriceKlineCandlestickData(...args : any) {
      return this._sendRequest("/dapi/v1/markPriceKlines", "GET", "MARKET_DATA", false, args, ["symbol", "interval", "startTime", "endTime", "limit"], "dapi_markPriceKlineCandlestickData");
  }
  
  
  /** Premium index Kline Data
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#premium-index-kline-data}
   * 
   * Premium index kline bars of a symbol.
   * 
   * EndPoint: /dapi/v1/premiumIndexKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} symbol
   * @param {RateLimitInterval} interval
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1500.
   */
  dapi_premiumIndexKlineData(symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["dapi_premiumIndexKlineData"]>;
  
  
  /** Premium index Kline Data
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#premium-index-kline-data}
   * 
   * Premium index kline bars of a symbol.
   * 
   * EndPoint: /dapi/v1/premiumIndexKlines
   * 
   * Weight(IP): Adjusted based on the limit:
   *   LIMIT       weight
   *   [1,100)     1     
   *   [100, 500)  2     
   *   [500, 1000] 5     
   *   > 1000      10    
   * 
   * @param {string} options.symbol
   * @param {RateLimitInterval} options.interval
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1500.
   */
  dapi_premiumIndexKlineData(options : { symbol :string, interval :RateLimitInterval, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<[
       number,        // example: 1691603820000  // Open time
       NumberString,  // example: "-0.00042931"  // Open
       NumberString,  // example: "-0.00023641"  // High
       NumberString,  // example: "-0.00059406"  // Low
       NumberString,  // example: "-0.00043659"  // Close
       NumberString,  // example: "0"  // Ignore
       number,        // example: 1691603879999  // Close time
       NumberString,  // example: "0"  // Ignore
       number,        // example: 12  // Ignore
       NumberString,  // example: "0"  // Ignore
       NumberString,  // example: "0"  // Ignore
       NumberString   // example: "0"  // Ignore
     ][]>;
  
  
  dapi_premiumIndexKlineData(...args : any) {
      return this._sendRequest("/dapi/v1/premiumIndexKlines", "GET", "MARKET_DATA", false, args, ["symbol", "interval", "startTime", "endTime", "limit"], "dapi_premiumIndexKlineData");
  }
  
  
  /** 24hr Ticker Price Change Statistics
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#24hr-ticker-price-change-statistics}
   * 
   * EndPoint: /dapi/v1/ticker/24hr
   * 
   * Weight(IP): 
   *   1 for a single symbol;
   *   40 when the symbol parameter is omitted
   * 
   * @param {string} symbol
   * @param {string} pair
   */
  dapi_tickerPriceChangeStatistics24hr(symbol? :string, pair? :string)
  : ReturnType<MyBinanceClient["dapi_tickerPriceChangeStatistics24hr"]>;
  
  
  /** 24hr Ticker Price Change Statistics
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#24hr-ticker-price-change-statistics}
   * 
   * EndPoint: /dapi/v1/ticker/24hr
   * 
   * Weight(IP): 
   *   1 for a single symbol;
   *   40 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol
   * @param {string} options.pair
   */
  dapi_tickerPriceChangeStatistics24hr(options? : { symbol? :string, pair? :string })
  : Promise<{
       symbol: string,  // example: "BTCUSD_200925"
       pair: string,  // example: "BTCUSD"
       priceChange: NumberString,  // example: "136.6"
       priceChangePercent: NumberString,  // example: "1.436"
       weightedAvgPrice: NumberString,  // example: "9547.3"
       lastPrice: NumberString,  // example: "9651.6"
       lastQty: NumberString,  // example: "1"
       openPrice: NumberString,  // example: "9515.0"
       highPrice: NumberString,  // example: "9687.0"
       lowPrice: NumberString,  // example: "9499.5"
       volume: NumberString,  // example: "494109"
       baseVolume: NumberString,  // example: "5192.94797687"
       openTime: number,  // example: 1591170300000
       closeTime: number,  // example: 1591256718418
       firstId: number,  // example: 600507  // First tradeId
       lastId: number,  // example: 697803  // Last tradeId
       count: number  // example: 97297  // Trade count
     }[]>;
  
  
  dapi_tickerPriceChangeStatistics24hr(...args : any) {
      return this._sendRequest("/dapi/v1/ticker/24hr", "GET", "MARKET_DATA", false, args, ["symbol", "pair"], "dapi_tickerPriceChangeStatistics24hr");
  }
  
  
  /** Symbol Price Ticker
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#symbol-price-ticker}
   * 
   * Latest price for a symbol or symbols.
   * 
   * EndPoint: /dapi/v1/ticker/price
   * 
   * Weight(IP): 
   *   1 for a single symbol;
   *   2 when the symbol parameter is omitted
   * 
   * @param {string} symbol
   * @param {string} pair
   */
  dapi_symbolPriceTicker(symbol? :string, pair? :string)  : ReturnType<MyBinanceClient["dapi_symbolPriceTicker"]>;
  
  
  /** Symbol Price Ticker
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#symbol-price-ticker}
   * 
   * Latest price for a symbol or symbols.
   * 
   * EndPoint: /dapi/v1/ticker/price
   * 
   * Weight(IP): 
   *   1 for a single symbol;
   *   2 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol
   * @param {string} options.pair
   */
  dapi_symbolPriceTicker(options? : { symbol? :string, pair? :string })
  : Promise<{
       symbol: string,  // example: "BTCUSD_200626"
       ps: NumberString,  // example: "9647.8"  // pair
       price: NumberString,  // example: "9647.8"
       time: number  // example: 1591257246176
     }[]>;
  
  
  dapi_symbolPriceTicker(...args : any) {
      return this._sendRequest("/dapi/v1/ticker/price", "GET", "MARKET_DATA", false, args, ["symbol", "pair"], "dapi_symbolPriceTicker");
  }
  
  
  /** Symbol Order Book Ticker
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#symbol-order-book-ticker}
   * 
   * Best price/qty on the order book for a symbol or symbols.
   * 
   * EndPoint: /dapi/v1/ticker/bookTicker
   * 
   * Weight(IP): 
   *   2 for a single symbol;
   *   5 when the symbol parameter is omitted
   * 
   * @param {string} symbol
   * @param {string} pair
   */
  dapi_symbolOrderBookTicker(symbol? :string, pair? :string)  : ReturnType<MyBinanceClient["dapi_symbolOrderBookTicker"]>;
  
  
  /** Symbol Order Book Ticker
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#symbol-order-book-ticker}
   * 
   * Best price/qty on the order book for a symbol or symbols.
   * 
   * EndPoint: /dapi/v1/ticker/bookTicker
   * 
   * Weight(IP): 
   *   2 for a single symbol;
   *   5 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol
   * @param {string} options.pair
   */
  dapi_symbolOrderBookTicker(options? : { symbol? :string, pair? :string })
  : Promise<{
       lastUpdateId: number,  // example: 1027024
       symbol: string,  // example: "BTCUSD_200626"
       pair: string,  // example: "BTCUSD"
       bidPrice: NumberString,  // example: "9650.1"
       bidQty: NumberString,  // example: "16"
       askPrice: NumberString,  // example: "9650.3"
       askQty: NumberString,  // example: "7"
       time: number  // example: 1591257300345
     }[]>;
  
  
  dapi_symbolOrderBookTicker(...args : any) {
      return this._sendRequest("/dapi/v1/ticker/bookTicker", "GET", "MARKET_DATA", false, args, ["symbol", "pair"], "dapi_symbolOrderBookTicker");
  }
  
  
  /** Query Index Price Constituents
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#query-index-price-constituents}
   * 
   * Query index price constituents 
   * 
   * EndPoint: /dapi/v1/constituents
   * 
   * Weight(IP): 2
   * 
   * @param {string} symbol  -  symbol underlying e.g BTCUSD
   */
  dapi_queryIndexPriceConstituents(symbol :string)  : ReturnType<MyBinanceClient["dapi_queryIndexPriceConstituents"]>;
  
  
  /** Query Index Price Constituents
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#query-index-price-constituents}
   * 
   * Query index price constituents 
   * 
   * EndPoint: /dapi/v1/constituents
   * 
   * Weight(IP): 2
   * 
   * @param {string} options.symbol  -  symbol underlying e.g BTCUSD
   */
  dapi_queryIndexPriceConstituents(options : { symbol :string })
  : Promise<{
     symbol: string,  // example: "BTCUSD"
     time: number,  // example: 1697422647853
     constituents: {
         exchange: string,  // example: "bitstamp"
         symbol: string  // example: "btcusd"
       }[]
    }>;
  
  
  dapi_queryIndexPriceConstituents(...args : any) {
      return this._sendRequest("/dapi/v1/constituents", "GET", "MARKET_DATA", false, args, ["symbol"], "dapi_queryIndexPriceConstituents");
  }
  
  
  /** Open Interest
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#open-interest}
   * 
   * Get present open interest of a specific symbol.
   * 
   * EndPoint: /dapi/v1/openInterest
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   */
  dapi_openInterest(symbol :string)  : ReturnType<MyBinanceClient["dapi_openInterest"]>;
  
  
  /** Open Interest
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#open-interest}
   * 
   * Get present open interest of a specific symbol.
   * 
   * EndPoint: /dapi/v1/openInterest
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   */
  dapi_openInterest(options : { symbol :string })
  : Promise<{
     symbol: string,  // example: "BTCUSD_200626"
     pair: string,  // example: "BTCUSD"
     openInterest: NumberString,  // example: "15004"
     contractType: string,  // example: "CURRENT_QUARTER"
     time: number  // example: 1591261042378
    }>;
  
  
  dapi_openInterest(...args : any) {
      return this._sendRequest("/dapi/v1/openInterest", "GET", "MARKET_DATA", false, args, ["symbol"], "dapi_openInterest");
  }
  
  
  /** Quarterly Contract Settlement Price
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#quarterly-contract-settlement-price}
   * 
   * EndPoint: /futures/data/delivery-price
   * 
   * @param {string} pair  -  e.g BTCUSD
   */
  dapi_quarterlyContractSettlementPrice(pair :string)
  : ReturnType<MyBinanceClient["dapi_quarterlyContractSettlementPrice"]>;
  
  
  /** Quarterly Contract Settlement Price
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#quarterly-contract-settlement-price}
   * 
   * EndPoint: /futures/data/delivery-price
   * 
   * @param {string} options.pair  -  e.g BTCUSD
   */
  dapi_quarterlyContractSettlementPrice(options : { pair :string })
  : Promise<{
       deliveryPrice: number,  // example: 27101.1
       deliveryTime: number  // example: 1695945600000
     }[]>;
  
  
  dapi_quarterlyContractSettlementPrice(...args : any) {
      return this._sendRequest("/futures/data/delivery-price", "GET", "MARKET_DATA", false, args, ["pair"], "dapi_quarterlyContractSettlementPrice");
  }
  
  
  /** Open Interest Statistics
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#open-interest-statistics}
   * 
   * EndPoint: /futures/data/openInterestHist
   * 
   * Weight(IP): 1
   * 
   * @param {string} pair  -  BTCUSD
   * @param {"ALL"|"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL"} contractType  -  ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  Default 30,Max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  dapi_openInterestStatistics(pair :string, contractType :"ALL"|"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL", period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["dapi_openInterestStatistics"]>;
  
  
  /** Open Interest Statistics
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#open-interest-statistics}
   * 
   * EndPoint: /futures/data/openInterestHist
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.pair  -  BTCUSD
   * @param {"ALL"|"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL"} options.contractType  -  ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  Default 30,Max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  dapi_openInterestStatistics(options : { pair :string, contractType :"ALL"|"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL", period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       pair: string,  // example: "BTCUSD"
       contractType: string,  // example: "CURRENT_QUARTER"
       sumOpenInterest: NumberString,  // example: "20403"  //unit: cont
       sumOpenInterestValue: NumberString,  // example: "176196512.23400000"  //unit: base asset
       timestamp: number  // example: 1591261042378
     }[]>;
  
  
  dapi_openInterestStatistics(...args : any) {
      return this._sendRequest("/futures/data/openInterestHist", "GET", "MARKET_DATA", false, args, ["pair", "contractType", "period", "limit", "startTime", "endTime"], "dapi_openInterestStatistics");
  }
  
  
  /** Top Trader Long/Short Ratio (Accounts)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#top-trader-long-short-ratio-accounts}
   * 
   * EndPoint: /futures/data/topLongShortAccountRatio
   * 
   * Weight(IP): 1
   * 
   * @param {string} pair  -  BTCUSD
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  Default 30,Max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  dapi_topTraderLongShortAccountRatio(pair :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["dapi_topTraderLongShortAccountRatio"]>;
  
  
  /** Top Trader Long/Short Ratio (Accounts)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#top-trader-long-short-ratio-accounts}
   * 
   * EndPoint: /futures/data/topLongShortAccountRatio
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.pair  -  BTCUSD
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  Default 30,Max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  dapi_topTraderLongShortAccountRatio(options : { pair :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       pair: string,  // example: "BTCUSD"
       longShortRatio: NumberString,  // example: "1.8105"
       longAccount: NumberString,  // example: "0.6442"  //64.42%
       shortAccount: NumberString,  // example: "0.3558"  //35.58%
       timestamp: number  // example: 1591261042378
     }[]>;
  
  
  dapi_topTraderLongShortAccountRatio(...args : any) {
      return this._sendRequest("/futures/data/topLongShortAccountRatio", "GET", "MARKET_DATA", false, args, ["pair", "period", "limit", "startTime", "endTime"], "dapi_topTraderLongShortAccountRatio");
  }
  
  
  /** Top Trader Long/Short Ratio (Positions)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#top-trader-long-short-ratio-positions}
   * 
   * EndPoint: /futures/data/topLongShortPositionRatio
   * 
   * Weight(IP): 1
   * 
   * @param {string} pair  -  BTCUSD
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  Default 30,Max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  dapi_topTraderLongShortPositionRatio(pair :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["dapi_topTraderLongShortPositionRatio"]>;
  
  
  /** Top Trader Long/Short Ratio (Positions)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#top-trader-long-short-ratio-positions}
   * 
   * EndPoint: /futures/data/topLongShortPositionRatio
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.pair  -  BTCUSD
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  Default 30,Max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  dapi_topTraderLongShortPositionRatio(options : { pair :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       pair: string,  // example: "BTCUSD"
       longShortRatio: NumberString,  // example: "0.7869"
       longPosition: NumberString,  // example: "0.6442"  //64.42%
       shortPosition: NumberString,  // example: "0.4404"  //44.04%
       timestamp: number  // example: 1592870400000
     }[]>;
  
  
  dapi_topTraderLongShortPositionRatio(...args : any) {
      return this._sendRequest("/futures/data/topLongShortPositionRatio", "GET", "MARKET_DATA", false, args, ["pair", "period", "limit", "startTime", "endTime"], "dapi_topTraderLongShortPositionRatio");
  }
  
  
  /** Long/Short Ratio
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#long-short-ratio}
   * 
   * EndPoint: /futures/data/globalLongShortAccountRatio
   * 
   * Weight(IP): 1
   * 
   * @param {string} pair  -  BTCUSD
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  Default 30,Max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  dapi_longShortRatio(pair :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["dapi_longShortRatio"]>;
  
  
  /** Long/Short Ratio
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#long-short-ratio}
   * 
   * EndPoint: /futures/data/globalLongShortAccountRatio
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.pair  -  BTCUSD
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  Default 30,Max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  dapi_longShortRatio(options : { pair :string, period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       pair: string,  // example: "BTCUSD"
       longShortRatio: NumberString,  // example: "0.1960"
       longAccount: NumberString,  // example: "0.6622"  //66.22%
       shortAccount: NumberString,  // example: "0.3378"  //33.78%
       timestamp: number  // example: 1583139600000
     }[]>;
  
  
  dapi_longShortRatio(...args : any) {
      return this._sendRequest("/futures/data/globalLongShortAccountRatio", "GET", "MARKET_DATA", false, args, ["pair", "period", "limit", "startTime", "endTime"], "dapi_longShortRatio");
  }
  
  
  /** Taker Buy/Sell Volume
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#taker-buy-sell-volume}
   * 
   * EndPoint: /futures/data/takerBuySellVol
   * 
   * Weight(IP): 1
   * 
   * @param {string} pair  -  BTCUSD
   * @param {"ALL"|"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL"} contractType  -  ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  Default 30,Max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  dapi_takerBuySellVolume(pair :string, contractType :"ALL"|"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL", period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["dapi_takerBuySellVolume"]>;
  
  
  /** Taker Buy/Sell Volume
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#taker-buy-sell-volume}
   * 
   * EndPoint: /futures/data/takerBuySellVol
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.pair  -  BTCUSD
   * @param {"ALL"|"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL"} options.contractType  -  ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  Default 30,Max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  dapi_takerBuySellVolume(options : { pair :string, contractType :"ALL"|"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL", period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       pair: string,  // example: "BTCUSD"
       contractType: string,  // example: "CURRENT_QUARTER"
       takerBuyVol: NumberString,  // example: "387"  //unit: cont
       takerSellVol: NumberString,  // example: "248"  //unit: cont
       takerBuyVolValue: NumberString,  // example: "2342.1220"  //unit: base asset
       takerSellVolValue: NumberString,  // example: "4213.9800"  //unit: base asset
       timestamp: number  // example: 1591261042378
     }[]>;
  
  
  dapi_takerBuySellVolume(...args : any) {
      return this._sendRequest("/futures/data/takerBuySellVol", "GET", "MARKET_DATA", false, args, ["pair", "contractType", "period", "limit", "startTime", "endTime"], "dapi_takerBuySellVolume");
  }
  
  
  /** Basis
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#basis}
   * 
   * EndPoint: /futures/data/basis
   * 
   * @param {string} pair  -  BTCUSD
   * @param {"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL"} contractType  -  CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} limit  -  Default 30,Max 500
   * @param {LONG} startTime
   * @param {LONG} endTime
   */
  dapi_basis(pair :string, contractType :"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL", period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG)
  : ReturnType<MyBinanceClient["dapi_basis"]>;
  
  
  /** Basis
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#basis}
   * 
   * EndPoint: /futures/data/basis
   * 
   * @param {string} options.pair  -  BTCUSD
   * @param {"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL"} options.contractType  -  CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
   * @param {"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d"} options.period  -  "5m","15m","30m","1h","2h","4h","6h","12h","1d"
   * @param {LONG} options.limit  -  Default 30,Max 500
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   */
  dapi_basis(options : { pair :string, contractType :"CURRENT_QUARTER"|"NEXT_QUARTER"|"PERPETUAL", period :"5m"|"15m"|"30m"|"1h"|"2h"|"4h"|"6h"|"12h"|"1d", limit? :LONG, startTime? :LONG, endTime? :LONG })
  : Promise<{
       indexPrice: NumberString,  // example: "29269.93972727"
       contractType: string,  // example: "CURRENT_QUARTER"
       basisRate: NumberString,  // example: "0.0024"
       futuresPrice: NumberString,  // example: "29341.3"
       annualizedBasisRate: NumberString,  // example: "0.0283"
       basis: NumberString,  // example: "71.36027273"
       pair: string,  // example: "BTCUSD"
       timestamp: number  // example: 1653381600000
     }[]>;
  
  
  dapi_basis(...args : any) {
      return this._sendRequest("/futures/data/basis", "GET", "MARKET_DATA", false, args, ["pair", "contractType", "period", "limit", "startTime", "endTime"], "dapi_basis");
  }
  
  
  
  //***** Account/Trades Endpoints *****
  
  
  /** Change Position Mode(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#change-position-mode-trade}
   * 
   * EndPoint: /dapi/v1/positionSide/dual
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} dualSidePosition  -  "true": Hedge Mode; "false": One-way Mode
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_changePositionMode(dualSidePosition :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_changePositionMode"]>;
  
  
  /** Change Position Mode(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#change-position-mode-trade}
   * 
   * EndPoint: /dapi/v1/positionSide/dual
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.dualSidePosition  -  "true": Hedge Mode; "false": One-way Mode
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_changePositionMode(options : { dualSidePosition :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "success"
    }>;
  
  
  dapi_changePositionMode(...args : any) {
      return this._sendRequest("/dapi/v1/positionSide/dual", "POST", "TRADE", true, args, ["dualSidePosition", "recvWindow", "timestamp"], "dapi_changePositionMode");
  }
  
  
  /** Get Current Position Mode(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-current-position-mode-user_data}
   * 
   * EndPoint: /dapi/v1/positionSide/dual
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_getCurrentPositionMode(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_getCurrentPositionMode"]>;
  
  
  /** Get Current Position Mode(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-current-position-mode-user_data}
   * 
   * EndPoint: /dapi/v1/positionSide/dual
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_getCurrentPositionMode(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     dualSidePosition: boolean  // example: true  // "true": Hedge Mode; "false": One-way Mode
    }>;
  
  
  dapi_getCurrentPositionMode(...args : any) {
      return this._sendRequest("/dapi/v1/positionSide/dual", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "dapi_getCurrentPositionMode");
  }
  
  
  /** New Order  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#new-order-trade}
   * 
   * Send in a new order.
   * 
   * EndPoint: /dapi/v1/order
   * 
   * Weight(IP): 0
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {OrderType} type
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity  -  quantity measured by contract number, Cannot be sent with closePosition=true
   * @param {"true"|"false"} reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with closePosition=true(Close-All)
   * @param {DECIMAL} price
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,36}$
   * @param {DECIMAL} stopPrice  -  Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {string} closePosition  -  true, false；Close-All,used with STOP_MARKET or TAKE_PROFIT_MARKET.
   * @param {DECIMAL} activationPrice  -  Used with TRAILING_STOP_MARKET orders, default as the latest price(supporting different workingType)
   * @param {DECIMAL} callbackRate  -  Used with TRAILING_STOP_MARKET orders, min 0.1, max 10 where 1 for 1%
   * @param {WorkingType} workingType  -  stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
   * @param {"TRUE"|"FALSE"} priceProtect  -  "TRUE" or "FALSE", default "FALSE". Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {OrderResponseType} newOrderRespType  -  "ACK", "RESULT", default "ACK"
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_newOrder(symbol :string, side :OrderSide, positionSide :PositionSide|undefined, type :OrderType, timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, stopPrice? :DECIMAL, closePosition? :string, activationPrice? :DECIMAL, callbackRate? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newOrderRespType? :OrderResponseType, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_newOrder"]>;
  
  
  /** New Order  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#new-order-trade}
   * 
   * Send in a new order.
   * 
   * EndPoint: /dapi/v1/order
   * 
   * Weight(IP): 0
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {OrderType} options.type
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity  -  quantity measured by contract number, Cannot be sent with closePosition=true
   * @param {"true"|"false"} options.reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with closePosition=true(Close-All)
   * @param {DECIMAL} options.price
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,36}$
   * @param {DECIMAL} options.stopPrice  -  Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {string} options.closePosition  -  true, false；Close-All,used with STOP_MARKET or TAKE_PROFIT_MARKET.
   * @param {DECIMAL} options.activationPrice  -  Used with TRAILING_STOP_MARKET orders, default as the latest price(supporting different workingType)
   * @param {DECIMAL} options.callbackRate  -  Used with TRAILING_STOP_MARKET orders, min 0.1, max 10 where 1 for 1%
   * @param {WorkingType} options.workingType  -  stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
   * @param {"TRUE"|"FALSE"} options.priceProtect  -  "TRUE" or "FALSE", default "FALSE". Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {OrderResponseType} options.newOrderRespType  -  "ACK", "RESULT", default "ACK"
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_newOrder(options : { symbol :string, side :OrderSide, positionSide? :PositionSide, type :OrderType, timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, stopPrice? :DECIMAL, closePosition? :string, activationPrice? :DECIMAL, callbackRate? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newOrderRespType? :OrderResponseType, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     clientOrderId: string,  // example: "testOrder"
     cumQty: NumberString,  // example: "0"
     cumBase: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 22542179
     avgPrice: NumberString,  // example: "0.0"
     origQty: NumberString,  // example: "10"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "NEW"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     closePosition: boolean,  // example: false  // if Close-All
     symbol: string,  // example: "BTCUSD_200925"
     pair: string,  // example: "BTCUSD"
     timeInForce: TimeInForce,  // example: "GTC"
     type: string,  // example: "TRAILING_STOP_MARKET"
     origType: string,  // example: "TRAILING_STOP_MARKET"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     updateTime: number,  // example: 1566818724722
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean  // example: false  // if conditional order trigger is protected
    }>;
  
  
  dapi_newOrder(...args : any) {
      return this._sendRequest("/dapi/v1/order", "POST", "TRADE", false, args, ["symbol", "side", "positionSide", "type", "timeInForce", "quantity", "reduceOnly", "price", "newClientOrderId", "stopPrice", "closePosition", "activationPrice", "callbackRate", "workingType", "priceProtect", "newOrderRespType", "recvWindow", "timestamp"], "dapi_newOrder");
  }
  
  
  /** Modify Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#modify-order-trade}
   * 
   * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
   * 
   * EndPoint: /dapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {string} symbol
   * @param {"SELL"|"BUY"} side  -  SELL, BUY
   * @param {DECIMAL} quantity  -  Order quantity, cannot be sent with closePosition=true
   * @param {DECIMAL} price
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_modifyOrder(orderId :LONG|undefined, origClientOrderId :string|undefined, symbol :string, side :"SELL"|"BUY", quantity? :DECIMAL, price? :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_modifyOrder"]>;
  
  
  /** Modify Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#modify-order-trade}
   * 
   * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
   * 
   * EndPoint: /dapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {string} options.symbol
   * @param {"SELL"|"BUY"} options.side  -  SELL, BUY
   * @param {DECIMAL} options.quantity  -  Order quantity, cannot be sent with closePosition=true
   * @param {DECIMAL} options.price
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_modifyOrder(options : { orderId? :LONG, origClientOrderId? :string, symbol :string, side :"SELL"|"BUY", quantity? :DECIMAL, price? :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderId: number,  // example: 20072994037
     symbol: string,  // example: "BTCUSD_PERP"
     pair: string,  // example: "BTCUSD"
     status: string,  // example: "NEW"
     clientOrderId: string,  // example: "LJ9R4QZDihCaS8UAOOLpgW"
     price: NumberString,  // example: "30005"
     avgPrice: NumberString,  // example: "0.0"
     origQty: NumberString,  // example: "1"
     executedQty: NumberString,  // example: "0"
     cumQty: NumberString,  // example: "0"
     cumBase: NumberString,  // example: "0"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     reduceOnly: boolean,  // example: false
     closePosition: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "LONG"
     stopPrice: NumberString,  // example: "0"
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean,  // example: false
     origType: string,  // example: "LIMIT"
     updateTime: number  // example: 1629182711600
    }>;
  
  
  dapi_modifyOrder(...args : any) {
      return this._sendRequest("/dapi/v1/order", "PUT", "TRADE", true, args, ["orderId", "origClientOrderId", "symbol", "side", "quantity", "price", "recvWindow", "timestamp"], "dapi_modifyOrder");
  }
  
  
  /** Place Multiple Orders  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#place-multiple-orders-trade}
   * 
   * EndPoint: /dapi/v1/batchOrders
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {object[]} batchOrders  -  order list. Max 5 orders
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_placeMultipleOrders(batchOrders :{symbol :string, side :OrderSide, positionSide? :PositionSide, type :OrderType, timeInForce? :TimeInForce, quantity :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, stopPrice? :DECIMAL, activationPrice? :DECIMAL, callbackRate? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newOrderRespType? :OrderResponseType}[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_placeMultipleOrders"]>;
  
  
  /** Place Multiple Orders  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#place-multiple-orders-trade}
   * 
   * EndPoint: /dapi/v1/batchOrders
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {object[]} options.batchOrders  -  order list. Max 5 orders
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_placeMultipleOrders(options : { batchOrders :{symbol :string, side :OrderSide, positionSide? :PositionSide, type :OrderType, timeInForce? :TimeInForce, quantity :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, stopPrice? :DECIMAL, activationPrice? :DECIMAL, callbackRate? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newOrderRespType? :OrderResponseType}[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       clientOrderId: string,  // example: "testOrder"
       cumQty: NumberString,  // example: "0"
       cumBase: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 22542179
       avgPrice: NumberString,  // example: "0.0"
       origQty: NumberString,  // example: "10"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       symbol: string,  // example: "BTCUSD_200925"
       pair: string,  // example: "BTCUSD"
       timeInForce: TimeInForce,  // example: "GTC"
       type: string,  // example: "TRAILING_STOP_MARKET"
       origType: string,  // example: "TRAILING_STOP_MARKET"
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
       updateTime: number,  // example: 1566818724722
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean  // example: false  // if conditional order trigger is protected
     } |
     {
       code: number,  // example: -2022
       msg: string    // example: "ReduceOnly Order is rejected."
     }
    )[]>;
  
  
  dapi_placeMultipleOrders(...args : any) {
      return this._sendRequest("/dapi/v1/batchOrders", "POST", "TRADE", true, args, ["batchOrders", "recvWindow", "timestamp"], "dapi_placeMultipleOrders");
  }
  
  
  /** Modify Multiple Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#modify-multiple-orders-trade}
   * 
   * EndPoint: /dapi/v1/batchOrders
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {object[]} batchOrders  -  order list. Max 5 orders
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_modifyMultipleOrders(batchOrders :{orderId? :LONG, origClientOrderId? :string, symbol :string, side :"SELL"|"BUY", quantity? :DECIMAL, price? :DECIMAL, recvWindow? :LONG, timestamp :LONG}[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_modifyMultipleOrders"]>;
  
  
  /** Modify Multiple Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#modify-multiple-orders-trade}
   * 
   * EndPoint: /dapi/v1/batchOrders
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {object[]} options.batchOrders  -  order list. Max 5 orders
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_modifyMultipleOrders(options : { batchOrders :{orderId? :LONG, origClientOrderId? :string, symbol :string, side :"SELL"|"BUY", quantity? :DECIMAL, price? :DECIMAL, recvWindow? :LONG, timestamp :LONG}[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       orderId: number,  // example: 20072994037
       symbol: string,  // example: "BTCUSD_PERP"
       pair: string,  // example: "BTCUSD"
       status: string,  // example: "NEW"
       clientOrderId: string,  // example: "LJ9R4QZDihCaS8UAOOLpgW"
       price: NumberString,  // example: "30005"
       avgPrice: NumberString,  // example: "0.0"
       origQty: NumberString,  // example: "1"
       executedQty: NumberString,  // example: "0"
       cumQty: NumberString,  // example: "0"
       cumBase: NumberString,  // example: "0"
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       reduceOnly: boolean,  // example: false
       closePosition: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "LONG"
       stopPrice: NumberString,  // example: "0"
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean,  // example: false
       origType: string,  // example: "LIMIT"
       updateTime: number  // example: 1629182711600
     } |
     {
       code: number,  // example: -2022
       msg: string    // example: "ReduceOnly Order is rejected."
     }
    )[]>;
  
  
  dapi_modifyMultipleOrders(...args : any) {
      return this._sendRequest("/dapi/v1/batchOrders", "PUT", "TRADE", true, args, ["batchOrders", "recvWindow", "timestamp"], "dapi_modifyMultipleOrders");
  }
  
  
  /** Get Order Modify History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-order-modify-history-user_data}
   * 
   * Get order modification history
   * 
   * EndPoint: /dapi/v1/orderAmendment
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} startTime  -  Timestamp in ms to get modification history from INCLUSIVE
   * @param {LONG} endTime  -  Timestamp in ms to get modification history until INCLUSIVE
   * @param {INT} limit  -  Default 50; max 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_getOrderModifyHistory(symbol :string, orderId? :LONG, origClientOrderId? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_getOrderModifyHistory"]>;
  
  
  /** Get Order Modify History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-order-modify-history-user_data}
   * 
   * Get order modification history
   * 
   * EndPoint: /dapi/v1/orderAmendment
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.startTime  -  Timestamp in ms to get modification history from INCLUSIVE
   * @param {LONG} options.endTime  -  Timestamp in ms to get modification history until INCLUSIVE
   * @param {INT} options.limit  -  Default 50; max 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_getOrderModifyHistory(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       amendmentId: number,  // example: 5363  // Order modification ID
       symbol: string,  // example: "BTCUSD_PERP"
       pair: string,  // example: "BTCUSD"
       orderId: number,  // example: 20072994037
       clientOrderId: string,  // example: "LJ9R4QZDihCaS8UAOOLpgW"
       time: number,  // example: 1629184560899  // Order modification time
       amendment: {
         price: {
           before: NumberString,  // example: "30004"
           after: NumberString  // example: "30003.2"
         },
         origQty: {
           before: NumberString,  // example: "1"
           after: NumberString  // example: "1"
         },
         count: number  // example: 3  // Order modification count, representing the number of times the order has been modified
       }
     }[]>;
  
  
  dapi_getOrderModifyHistory(...args : any) {
      return this._sendRequest("/dapi/v1/orderAmendment", "GET", "USER_DATA", true, args, ["symbol", "orderId", "origClientOrderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "dapi_getOrderModifyHistory");
  }
  
  
  /** Query Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#query-order-user_data}
   * 
   * Check an order's status.
   * 
   * EndPoint: /dapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_queryOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_queryOrder"]>;
  
  
  /** Query Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#query-order-user_data}
   * 
   * Check an order's status.
   * 
   * EndPoint: /dapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_queryOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.0"
     clientOrderId: string,  // example: "abc"
     cumBase: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 1917641
     origQty: NumberString,  // example: "0.40"
     origType: string,  // example: "TRAILING_STOP_MARKET"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     status: string,  // example: "NEW"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     closePosition: boolean,  // example: false  // if Close-All
     symbol: string,  // example: "BTCUSD_200925"
     pair: string,  // example: "BTCUSD"
     time: number,  // example: 1579276756075  // order time
     timeInForce: TimeInForce,  // example: "GTC"
     type: string,  // example: "TRAILING_STOP_MARKET"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     updateTime: number,  // example: 1579276756075  // update time
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean  // example: false  // if conditional order trigger is protected
    }>;
  
  
  dapi_queryOrder(...args : any) {
      return this._sendRequest("/dapi/v1/order", "GET", "USER_DATA", true, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "dapi_queryOrder");
  }
  
  
  /** Cancel Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#cancel-order-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /dapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_cancelOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_cancelOrder"]>;
  
  
  /** Cancel Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#cancel-order-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /dapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_cancelOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.0"
     clientOrderId: string,  // example: "myOrder1"
     cumQty: NumberString,  // example: "0"
     cumBase: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 283194212
     origQty: NumberString,  // example: "11"
     origType: string,  // example: "TRAILING_STOP_MARKET"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "CANCELED"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     closePosition: boolean,  // example: false  // if Close-All
     symbol: string,  // example: "BTCUSD_200925"
     pair: string,  // example: "BTCUSD"
     timeInForce: TimeInForce,  // example: "GTC"
     type: string,  // example: "TRAILING_STOP_MARKET"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     updateTime: number,  // example: 1571110484038
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean  // example: false  // if conditional order trigger is protected
    }>;
  
  
  dapi_cancelOrder(...args : any) {
      return this._sendRequest("/dapi/v1/order", "DELETE", "TRADE", true, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "dapi_cancelOrder");
  }
  
  
  /** Cancel All Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#cancel-all-open-orders-trade}
   * 
   * EndPoint: /dapi/v1/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_cancelAllOpenOrders(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_cancelAllOpenOrders"]>;
  
  
  /** Cancel All Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#cancel-all-open-orders-trade}
   * 
   * EndPoint: /dapi/v1/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_cancelAllOpenOrders(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "The operation of cancel all open order is done."
    }>;
  
  
  dapi_cancelAllOpenOrders(...args : any) {
      return this._sendRequest("/dapi/v1/allOpenOrders", "DELETE", "TRADE", true, args, ["symbol", "recvWindow", "timestamp"], "dapi_cancelAllOpenOrders");
  }
  
  
  /** Cancel Multiple Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#cancel-multiple-orders-trade}
   * 
   * EndPoint: /dapi/v1/batchOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG[]} orderIdList  -  max length 10  e.g. [1234567,2345678]
   * @param {string[]} origClientOrderIdList  -  max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_cancelMultipleOrders(symbol :string, orderIdList? :readonly LONG[], origClientOrderIdList? :readonly string[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_cancelMultipleOrders"]>;
  
  
  /** Cancel Multiple Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#cancel-multiple-orders-trade}
   * 
   * EndPoint: /dapi/v1/batchOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG[]} options.orderIdList  -  max length 10  e.g. [1234567,2345678]
   * @param {string[]} options.origClientOrderIdList  -  max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_cancelMultipleOrders(options : { symbol :string, orderIdList? :readonly LONG[], origClientOrderIdList? :readonly string[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       avgPrice: NumberString,  // example: "0.0"
       clientOrderId: string,  // example: "myOrder1"
       cumQty: NumberString,  // example: "0"
       cumBase: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 283194212
       origQty: NumberString,  // example: "11"
       origType: string,  // example: "TRAILING_STOP_MARKET"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "CANCELED"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       closePosition: boolean,  // example: false  // if Close-All
       symbol: string,  // example: "BTCUSD_200925"
       timeInForce: TimeInForce,  // example: "GTC"
       type: string,  // example: "TRAILING_STOP_MARKET"
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean,  // example: false  // if conditional order trigger is protected
       updateTime: number  // example: 1571110484038
     } |
     {
       code: number,  // example: -2011
       msg: string    // example: "Unknown order sent."
     }
    )[]>;
  
  
  dapi_cancelMultipleOrders(...args : any) {
      return this._sendRequest("/dapi/v1/batchOrders", "DELETE", "TRADE", true, args, ["symbol", "orderIdList", "origClientOrderIdList", "recvWindow", "timestamp"], "dapi_cancelMultipleOrders");
  }
  
  
  /** Auto-Cancel All Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#auto-cancel-all-open-orders-trade}
   * 
   * Cancel all open orders of the specified symbol at the end of the specified countdown.
   * 
   * EndPoint: /dapi/v1/countdownCancelAll
   * 
   * Weight(IP): 10
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} countdownTime  -  countdown time, 1000 for 1 second. 0 to cancel the timer
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_autoCancelAllOpenOrders(symbol :string, countdownTime :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_autoCancelAllOpenOrders"]>;
  
  
  /** Auto-Cancel All Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#auto-cancel-all-open-orders-trade}
   * 
   * Cancel all open orders of the specified symbol at the end of the specified countdown.
   * 
   * EndPoint: /dapi/v1/countdownCancelAll
   * 
   * Weight(IP): 10
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.countdownTime  -  countdown time, 1000 for 1 second. 0 to cancel the timer
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_autoCancelAllOpenOrders(options : { symbol :string, countdownTime :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "BTCUSD_200925"
     countdownTime: NumberString  // example: "100000"
    }>;
  
  
  dapi_autoCancelAllOpenOrders(...args : any) {
      return this._sendRequest("/dapi/v1/countdownCancelAll", "POST", "TRADE", true, args, ["symbol", "countdownTime", "recvWindow", "timestamp"], "dapi_autoCancelAllOpenOrders");
  }
  
  
  /** Query Current Open Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#query-current-open-order-user_data}
   * 
   * EndPoint: /dapi/v1/openOrder
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_queryCurrentOpenOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_queryCurrentOpenOrder"]>;
  
  
  /** Query Current Open Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#query-current-open-order-user_data}
   * 
   * EndPoint: /dapi/v1/openOrder
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_queryCurrentOpenOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.0"
     clientOrderId: string,  // example: "abc"
     cumBase: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 1917641
     origQty: NumberString,  // example: "0.40"
     origType: string,  // example: "TRAILING_STOP_MARKET"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "NEW"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     closePosition: boolean,  // example: false  // if Close-All
     symbol: string,  // example: "BTCUSD_200925"
     pair: string,  // example: "BTCUSD"
     time: number,  // example: 1579276756075  // order time
     timeInForce: TimeInForce,  // example: "GTC"
     type: string,  // example: "TRAILING_STOP_MARKET"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     updateTime: number,  // example: 1579276756075
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean  // example: false  // if conditional order trigger is protected
    }>;
  
  
  dapi_queryCurrentOpenOrder(...args : any) {
      return this._sendRequest("/dapi/v1/openOrder", "GET", "USER_DATA", true, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "dapi_queryCurrentOpenOrder");
  }
  
  
  /** Current All Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#current-all-open-orders-user_data}
   * 
   * EndPoint: /dapi/v1/openOrders
   * 
   * Weight(IP): 
   *   1 for a single symbol;
   *   40 for mutltiple symbols
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {string} pair
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_currentAllOpenOrders(symbol? :string, pair? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_currentAllOpenOrders"]>;
  
  
  /** Current All Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#current-all-open-orders-user_data}
   * 
   * EndPoint: /dapi/v1/openOrders
   * 
   * Weight(IP): 
   *   1 for a single symbol;
   *   40 for mutltiple symbols
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {string} options.pair
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_currentAllOpenOrders(options? : { symbol? :string, pair? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       avgPrice: NumberString,  // example: "0.0"
       clientOrderId: string,  // example: "abc"
       cumBase: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 1917641
       origQty: NumberString,  // example: "0.40"
       origType: string,  // example: "TRAILING_STOP_MARKET"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       closePosition: boolean,  // example: false  // if Close-All
       symbol: string,  // example: "BTCUSD_200925"
       time: number,  // example: 1579276756075  // order time
       timeInForce: TimeInForce,  // example: "GTC"
       type: string,  // example: "TRAILING_STOP_MARKET"
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
       updateTime: number,  // example: 1579276756075  // update time
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean  // example: false  // if conditional order trigger is protected
     }[]>;
  
  
  dapi_currentAllOpenOrders(...args : any) {
      return this._sendRequest("/dapi/v1/openOrders", "GET", "USER_DATA", true, args, ["symbol", "pair", "recvWindow", "timestamp"], "dapi_currentAllOpenOrders");
  }
  
  
  /** All Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#all-orders-user_data}
   * 
   * Get all account orders; active, canceled, or filled.
   * 
   * EndPoint: /dapi/v1/allOrders
   * 
   * Weight(IP): 
   *   20 with symbol
   *   40 with pair
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 50; max 100.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_allOrders(symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_allOrders"]>;
  
  
  /** All Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#all-orders-user_data}
   * 
   * Get all account orders; active, canceled, or filled.
   * 
   * EndPoint: /dapi/v1/allOrders
   * 
   * Weight(IP): 
   *   20 with symbol
   *   40 with pair
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 50; max 100.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_allOrders(options : { symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       avgPrice: NumberString,  // example: "0.0"
       clientOrderId: string,  // example: "abc"
       cumBase: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 1917641
       origQty: NumberString,  // example: "0.40"
       origType: string,  // example: "TRAILING_STOP_MARKET"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       closePosition: boolean,  // example: false  // if Close-All
       symbol: string,  // example: "BTCUSD_200925"
       pair: string,  // example: "BTCUSD"
       time: number,  // example: 1579276756075  // order time
       timeInForce: TimeInForce,  // example: "GTC"
       type: string,  // example: "TRAILING_STOP_MARKET"
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
       updateTime: number,  // example: 1579276756075  // update time
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean  // example: false  // if conditional order trigger is protected
     }[]>;
  
  
  /** All Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#all-orders-user_data}
   * 
   * Get all account orders; active, canceled, or filled.
   * 
   * EndPoint: /dapi/v1/allOrders
   * 
   * Weight(IP): 
   *   20 with symbol
   *   40 with pair
   * 
   * HMAC SHA256
   * 
   * @param {string} options.pair
   * @param {LONG} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 50; max 100.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_allOrders(options : { pair :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       avgPrice: NumberString,  // example: "0.0"
       clientOrderId: string,  // example: "abc"
       cumBase: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 1917641
       origQty: NumberString,  // example: "0.40"
       origType: string,  // example: "TRAILING_STOP_MARKET"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       stopPrice: NumberString,  // example: "9300"
       closePosition: boolean,  // example: false
       symbol: string,  // example: "BTCUSD_200925"
       pair: string,  // example: "BTCUSD"
       time: number,  // example: 1579276756075
       timeInForce: TimeInForce,  // example: "GTC"
       type: string,  // example: "TRAILING_STOP_MARKET"
       activatePrice: NumberString,  // example: "9020"
       priceRate: NumberString,  // example: "0.3"
       updateTime: number,  // example: 1579276756075
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean  // example: false
     }[]>;
  
  
  dapi_allOrders(...args : any) {
      return this._sendRequest("/dapi/v1/allOrders", "GET", "USER_DATA", true, args, [{symbol:'string',orderId:null,startTime:null,endTime:null,limit:null,recvWindow:null,timestamp:null}, {pair:'string',orderId:null,startTime:null,endTime:null,limit:null,recvWindow:null,timestamp:null}], "dapi_allOrders");
  }
  
  
  /** Futures Account Balance (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#futures-account-balance-user_data}
   * 
   * EndPoint: /dapi/v1/balance
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_futuresAccountBalance(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_futuresAccountBalance"]>;
  
  
  /** Futures Account Balance (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#futures-account-balance-user_data}
   * 
   * EndPoint: /dapi/v1/balance
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_futuresAccountBalance(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       accountAlias: string,  // example: "SgsR"  // unique account code
       asset: string,  // example: "BTC"
       balance: NumberString,  // example: "0.00250000"
       withdrawAvailable: NumberString,  // example: "0.00250000"
       crossWalletBalance: NumberString,  // example: "0.00241969"
       crossUnPnl: NumberString,  // example: "0.00000000"
       availableBalance: NumberString,  // example: "0.00241969"
       updateTime: number  // example: 1592468353979
     }[]>;
  
  
  dapi_futuresAccountBalance(...args : any) {
      return this._sendRequest("/dapi/v1/balance", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "dapi_futuresAccountBalance");
  }
  
  
  /** Account Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#account-information-user_data}
   * 
   * Get current account information.
   * 
   * EndPoint: /dapi/v1/account
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_accountInformation(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["dapi_accountInformation"]>;
  
  
  /** Account Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#account-information-user_data}
   * 
   * Get current account information.
   * 
   * EndPoint: /dapi/v1/account
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_accountInformation(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     assets: {
         asset: string,  // example: "BTC"  // asset name
         walletBalance: NumberString,  // example: "0.00241969"  // total wallet balance
         unrealizedProfit: NumberString,  // example: "0.00000000"  // unrealized profit or loss
         marginBalance: NumberString,  // example: "0.00241969"  // margin balance
         maintMargin: NumberString,  // example: "0.00000000"  // maintenance margin
         initialMargin: NumberString,  // example: "0.00000000"  // total intial margin required with the latest mark price
         positionInitialMargin: NumberString,  // example: "0.00000000"  // positions" margin required with the latest mark price
         openOrderInitialMargin: NumberString,  // example: "0.00000000"  // open orders" intial margin required with the latest mark price
         maxWithdrawAmount: NumberString,  // example: "0.00241969"  // available amount for transfer out
         crossWalletBalance: NumberString,  // example: "0.00241969"  // wallet balance for crossed margin
         crossUnPnl: NumberString,  // example: "0.00000000"  // total unrealized profit or loss of crossed positions
         availableBalance: NumberString,  // example: "0.00241969"  // available margin balance
         updateTime: number  // example: 1625474304765  //update time
       }[],
     positions: {
         symbol: string,  // example: "BTCUSD_201225"
         positionAmt: NumberString,  // example: "0"  // position amount
         initialMargin: NumberString,  // example: "0"
         maintMargin: NumberString,  // example: "0"
         unrealizedProfit: NumberString,  // example: "0.00000000"
         positionInitialMargin: NumberString,  // example: "0"
         openOrderInitialMargin: NumberString,  // example: "0"
         leverage: NumberString,  // example: "125"
         isolated: boolean,  // example: false
         positionSide: PositionSide,  // example: "BOTH"  // BOTH means that it is the position of One-way Mode
         entryPrice: NumberString,  // example: "0.0"
         breakEvenPrice: NumberString,  // example: "0.0"  // break-even price
         maxQty: NumberString,  // example: "50"  // maximum quantity of base asset
         updateTime: number  // example: 0
       }[],
     canDeposit: boolean,  // example: true
     canTrade: boolean,  // example: true
     canWithdraw: boolean,  // example: true
     feeTier: number,  // example: 2
     updateTime: number  // example: 0
    }>;
  
  
  dapi_accountInformation(...args : any) {
      return this._sendRequest("/dapi/v1/account", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "dapi_accountInformation");
  }
  
  
  /** Change Initial Leverage (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#change-initial-leverage-trade}
   * 
   * EndPoint: /dapi/v1/leverage
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {INT} leverage  -  target initial leverage: int from 1 to 125
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_changeInitialLeverage(symbol :string, leverage :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_changeInitialLeverage"]>;
  
  
  /** Change Initial Leverage (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#change-initial-leverage-trade}
   * 
   * EndPoint: /dapi/v1/leverage
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {INT} options.leverage  -  target initial leverage: int from 1 to 125
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_changeInitialLeverage(options : { symbol :string, leverage :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     leverage: number,  // example: 21
     maxQty: NumberString,  // example: "1000"  // maximum quantity of base asset
     symbol: string  // example: "BTCUSD_200925"
    }>;
  
  
  dapi_changeInitialLeverage(...args : any) {
      return this._sendRequest("/dapi/v1/leverage", "POST", "TRADE", true, args, ["symbol", "leverage", "recvWindow", "timestamp"], "dapi_changeInitialLeverage");
  }
  
  
  /** Change Margin Type (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#change-margin-type-trade}
   * 
   * EndPoint: /dapi/v1/marginType
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {"ISOLATED"|"CROSSED"} marginType  -  ISOLATED, CROSSED
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_changeMarginType(symbol :string, marginType :"ISOLATED"|"CROSSED", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_changeMarginType"]>;
  
  
  /** Change Margin Type (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#change-margin-type-trade}
   * 
   * EndPoint: /dapi/v1/marginType
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {"ISOLATED"|"CROSSED"} options.marginType  -  ISOLATED, CROSSED
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_changeMarginType(options : { symbol :string, marginType :"ISOLATED"|"CROSSED", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "success"
    }>;
  
  
  dapi_changeMarginType(...args : any) {
      return this._sendRequest("/dapi/v1/marginType", "POST", "TRADE", true, args, ["symbol", "marginType", "recvWindow", "timestamp"], "dapi_changeMarginType");
  }
  
  
  /** Modify Isolated Position Margin (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#modify-isolated-position-margin-trade}
   * 
   * EndPoint: /dapi/v1/positionMargin
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent with Hedge Mode.
   * @param {DECIMAL} amount
   * @param {INT} type  -  1: Add position margin,2: Reduce position margin
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_modifyIsolatedPositionMargin(symbol :string, positionSide :PositionSide|undefined, amount :DECIMAL, type :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_modifyIsolatedPositionMargin"]>;
  
  
  /** Modify Isolated Position Margin (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#modify-isolated-position-margin-trade}
   * 
   * EndPoint: /dapi/v1/positionMargin
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent with Hedge Mode.
   * @param {DECIMAL} options.amount
   * @param {INT} options.type  -  1: Add position margin,2: Reduce position margin
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_modifyIsolatedPositionMargin(options : { symbol :string, positionSide? :PositionSide, amount :DECIMAL, type :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     amount: number,  // example: 100
     code: number,    // example: 200
     msg: string,     // example: "Successfully modify position margin."
     type: number     // example: 1
    }>;
  
  
  dapi_modifyIsolatedPositionMargin(...args : any) {
      return this._sendRequest("/dapi/v1/positionMargin", "POST", "TRADE", true, args, ["symbol", "positionSide", "amount", "type", "recvWindow", "timestamp"], "dapi_modifyIsolatedPositionMargin");
  }
  
  
  /** Get Position Margin Change History (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-position-margin-change-history-trade}
   * 
   * EndPoint: /dapi/v1/positionMargin/history
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {INT} type  -  1: Add position margin,2: Reduce position margin
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default: 50
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_getPositionMarginChangeHistory(symbol :string, type? :INT, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_getPositionMarginChangeHistory"]>;
  
  
  /** Get Position Margin Change History (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-position-margin-change-history-trade}
   * 
   * EndPoint: /dapi/v1/positionMargin/history
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {INT} options.type  -  1: Add position margin,2: Reduce position margin
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default: 50
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_getPositionMarginChangeHistory(options : { symbol :string, type? :INT, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       amount: NumberString,  // example: "23.36332311"
       asset: string,  // example: "BTC"
       symbol: string,  // example: "BTCUSD_200925"
       time: number,  // example: 1578047897183
       type: number,  // example: 1
       positionSide: PositionSide  // example: "BOTH"
     }[]>;
  
  
  dapi_getPositionMarginChangeHistory(...args : any) {
      return this._sendRequest("/dapi/v1/positionMargin/history", "GET", "TRADE", true, args, ["symbol", "type", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "dapi_getPositionMarginChangeHistory");
  }
  
  
  /** Position Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#position-information-user_data}
   * 
   * EndPoint: /dapi/v1/positionRisk
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} marginAsset
   * @param {string} pair
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_positionInformation(marginAsset? :string, pair? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_positionInformation"]>;
  
  
  /** Position Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#position-information-user_data}
   * 
   * EndPoint: /dapi/v1/positionRisk
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.marginAsset
   * @param {string} options.pair
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_positionInformation(options? : { marginAsset? :string, pair? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSD_201225"
       positionAmt: NumberString,  // example: "0"
       entryPrice: NumberString,  // example: "0.0"
       breakEvenPrice: NumberString,  // example: "0.0"  // break-even price
       markPrice: NumberString,  // example: "0.00000000"
       unRealizedProfit: NumberString,  // example: "0.00000000"
       liquidationPrice: NumberString,  // example: "0"
       leverage: NumberString,  // example: "125"
       maxQty: NumberString,  // example: "50"  // maximum quantity of base asset
       marginType: string,  // example: "cross"
       isolatedMargin: NumberString,  // example: "0.00000000"
       isAutoAddMargin: string,  // example: "false"
       positionSide: PositionSide,  // example: "BOTH"
       notionalValue: NumberString,  // example: "0"
       updateTime: number  // example: 0
     }[]>;
  
  
  dapi_positionInformation(...args : any) {
      return this._sendRequest("/dapi/v1/positionRisk", "GET", "USER_DATA", true, args, ["marginAsset", "pair", "recvWindow", "timestamp"], "dapi_positionInformation");
  }
  
  
  /** Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#account-trade-list-user_data}
   * 
   * Get trades for a specific account and symbol.
   * 
   * EndPoint: /dapi/v1/userTrades
   * 
   * Weight(IP): 
   *   20 with symbol
   *   40 with pair
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {string} pair
   * @param {string} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} fromId  -  Trade id to fetch from. Default gets most recent trades.
   * @param {INT} limit  -  Default 50; max 1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_accountTradeList(symbol? :string, pair? :string, orderId? :string, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_accountTradeList"]>;
  
  
  /** Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#account-trade-list-user_data}
   * 
   * Get trades for a specific account and symbol.
   * 
   * EndPoint: /dapi/v1/userTrades
   * 
   * Weight(IP): 
   *   20 with symbol
   *   40 with pair
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {string} options.pair
   * @param {string} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.fromId  -  Trade id to fetch from. Default gets most recent trades.
   * @param {INT} options.limit  -  Default 50; max 1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_accountTradeList(options? : { symbol? :string, pair? :string, orderId? :string, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSD_200626"
       id: number,  // example: 6
       orderId: number,  // example: 28
       pair: string,  // example: "BTCUSD"
       side: OrderSide,  // example: "SELL"
       price: NumberString,  // example: "8800"
       qty: NumberString,  // example: "1"
       realizedPnl: NumberString,  // example: "0"
       marginAsset: string,  // example: "BTC"
       baseQty: NumberString,  // example: "0.01136364"
       commission: NumberString,  // example: "0.00000454"
       commissionAsset: string,  // example: "BTC"
       time: number,  // example: 1590743483586
       positionSide: PositionSide,  // example: "BOTH"
       buyer: boolean,  // example: false
       maker: boolean  // example: false
     }[]>;
  
  
  dapi_accountTradeList(...args : any) {
      return this._sendRequest("/dapi/v1/userTrades", "GET", "USER_DATA", true, args, ["symbol", "pair", "orderId", "startTime", "endTime", "fromId", "limit", "recvWindow", "timestamp"], "dapi_accountTradeList");
  }
  
  
  /** Get Income History(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-income-history-user_data}
   * 
   * EndPoint: /dapi/v1/income
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {string} incomeType  -  "TRANSFER","WELCOME_BONUS", "FUNDING_FEE", "REALIZED_PNL", "COMMISSION", "INSURANCE_CLEAR", "API_REBATE" and "DELIVERED_SETTELMENT"
   * @param {LONG} startTime  -  Timestamp in ms to get funding from INCLUSIVE.
   * @param {LONG} endTime  -  Timestamp in ms to get funding until INCLUSIVE.
   * @param {INT} page
   * @param {INT} limit  -  Default 100; max 1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_getIncomeHistory(symbol? :string, incomeType? :string, startTime? :LONG, endTime? :LONG, page? :INT, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_getIncomeHistory"]>;
  
  
  /** Get Income History(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-income-history-user_data}
   * 
   * EndPoint: /dapi/v1/income
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {string} options.incomeType  -  "TRANSFER","WELCOME_BONUS", "FUNDING_FEE", "REALIZED_PNL", "COMMISSION", "INSURANCE_CLEAR", "API_REBATE" and "DELIVERED_SETTELMENT"
   * @param {LONG} options.startTime  -  Timestamp in ms to get funding from INCLUSIVE.
   * @param {LONG} options.endTime  -  Timestamp in ms to get funding until INCLUSIVE.
   * @param {INT} options.page
   * @param {INT} options.limit  -  Default 100; max 1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_getIncomeHistory(options? : { symbol? :string, incomeType? :string, startTime? :LONG, endTime? :LONG, page? :INT, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: ""  // trade symbol, if existing
       incomeType: string,  // example: "TRANSFER"  // income type
       income: NumberString,  // example: "-0.37500000"  // income amount
       asset: string,  // example: "BTC"  // income asset
       info: string,  // example: "WITHDRAW"  // extra information
       time: number,  // example: 1570608000000
       tranId: NumberString,  // example: "9689322392"  // transaction id
       tradeId: string  // example: ""  // trade id, if existing
     } |
     {
       symbol: string,  // example: "BTCUSD_200925"
       incomeType: string,  // example: "COMMISSION"
       income: NumberString,  // example: "-0.01000000"
       asset: string,  // example: "BTC"
       info: string,  // example: ""
       time: number,  // example: 1570636800000
       tranId: NumberString,  // example: "9689322392"
       tradeId: NumberString  // example: "2059192"
     }
    )[]>;
  
  
  dapi_getIncomeHistory(...args : any) {
      return this._sendRequest("/dapi/v1/income", "GET", "USER_DATA", true, args, ["symbol", "incomeType", "startTime", "endTime", "page", "limit", "recvWindow", "timestamp"], "dapi_getIncomeHistory");
  }
  
  
  /** Notional Bracket for Pair(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#notional-bracket-for-pair-user_data}
   * 
   * EndPoint: /dapi/v1/leverageBracket
   * 
   * Weight(IP): 1
   * 
   * @param {string} pair
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_notionalBracketForPair(pair? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_notionalBracketForPair"]>;
  
  
  /** Notional Bracket for Pair(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#notional-bracket-for-pair-user_data}
   * 
   * EndPoint: /dapi/v1/leverageBracket
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.pair
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_notionalBracketForPair(options? : { pair? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       pair: string,  // example: "BTCUSD"
       brackets: {
           bracket: number,  // example: 1  // bracket level
           initialLeverage: number,  // example: 125  // the maximum leverage
           qtyCap: number,  // example: 50  // upper edge of base asset quantity
           qtylFloor: number,  // example: 0  // lower edge of base asset quantity
           maintMarginRatio: number,  // example: 0.004  // maintenance margin rate
           cum: number  // example: 0  // Auxiliary number for quick calculation
         }[]
     }[]>;
  
  
  dapi_notionalBracketForPair(...args : any) {
      return this._sendRequest("/dapi/v1/leverageBracket", "GET", "USER_DATA", false, args, ["pair", "recvWindow", "timestamp"], "dapi_notionalBracketForPair");
  }
  
  
  /** Notional Bracket for Symbol(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#notional-bracket-for-symbol-user_data}
   * 
   * Get the symbol's notional bracket list.
   * 
   * EndPoint: /dapi/v2/leverageBracket
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_notionalBracketForSymbol(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_notionalBracketForSymbol"]>;
  
  
  /** Notional Bracket for Symbol(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#notional-bracket-for-symbol-user_data}
   * 
   * Get the symbol's notional bracket list.
   * 
   * EndPoint: /dapi/v2/leverageBracket
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_notionalBracketForSymbol(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSD_PERP"
       notionalCoef: number,  // example: 1.5  //user symbol bracket multiplier, only appears when user's symbol bracket is adjusted
       brackets: {
           bracket: number,  // example: 1  // bracket level
           initialLeverage: number,  // example: 125  // the maximum leverage
           qtyCap: number,  // example: 50  // upper edge of base asset quantity
           qtylFloor: number,  // example: 0  // lower edge of base asset quantity
           maintMarginRatio: number,  // example: 0.004  // maintenance margin rate
           cum: number  // example: 0  // Auxiliary number for quick calculation
         }[]
     }[]>;
  
  
  dapi_notionalBracketForSymbol(...args : any) {
      return this._sendRequest("/dapi/v2/leverageBracket", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "dapi_notionalBracketForSymbol");
  }
  
  
  /** User's Force Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#user-39-s-force-orders-user_data}
   * 
   * EndPoint: /dapi/v1/forceOrders
   * 
   * Weight(IP): 20 with symbol, 50 without symbol
   * 
   * @param {string} symbol
   * @param {ENUM} autoCloseType  -  "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 50; max 100.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_userSForceOrders(symbol? :string, autoCloseType? :ENUM, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_userSForceOrders"]>;
  
  
  /** User's Force Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#user-39-s-force-orders-user_data}
   * 
   * EndPoint: /dapi/v1/forceOrders
   * 
   * Weight(IP): 20 with symbol, 50 without symbol
   * 
   * @param {string} options.symbol
   * @param {ENUM} options.autoCloseType  -  "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 50; max 100.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_userSForceOrders(options? : { symbol? :string, autoCloseType? :ENUM, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderId: number,  // example: 165123080
       symbol: string,  // example: "BTCUSD_200925"
       pair: string,  // example: "BTCUSD"
       status: string,  // example: "FILLED"
       clientOrderId: string,  // example: "autoclose-1596542005017000006"
       price: NumberString,  // example: "11326.9"
       avgPrice: NumberString,  // example: "11326.9"
       origQty: NumberString,  // example: "1"
       executedQty: NumberString,  // example: "1"
       cumBase: NumberString,  // example: "0.00882854"
       timeInForce: TimeInForce,  // example: "IOC"
       type: OrderType,  // example: "LIMIT"
       reduceOnly: boolean,  // example: false
       closePosition: boolean,  // example: false
       side: OrderSide,  // example: "SELL"
       positionSide: PositionSide,  // example: "BOTH"
       stopPrice: NumberString,  // example: "0"
       workingType: WorkingType,  // example: "CONTRACT_PRICE"
       priceProtect: boolean,  // example: false
       origType: string,  // example: "LIMIT"
       time: number,  // example: 1596542005019
       updateTime: number  // example: 1596542005050
     }[]>;
  
  
  dapi_userSForceOrders(...args : any) {
      return this._sendRequest("/dapi/v1/forceOrders", "GET", "USER_DATA", false, args, ["symbol", "autoCloseType", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "dapi_userSForceOrders");
  }
  
  
  /** Position ADL Quantile Estimation (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#position-adl-quantile-estimation-user_data}
   * 
   * EndPoint: /dapi/v1/adlQuantile
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_positionADLQuantileEstimation(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_positionADLQuantileEstimation"]>;
  
  
  /** Position ADL Quantile Estimation (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#position-adl-quantile-estimation-user_data}
   * 
   * EndPoint: /dapi/v1/adlQuantile
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_positionADLQuantileEstimation(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: "BTCUSD_200925"
       adlQuantile: {
         LONG: number,   // example: 3
         SHORT: number,  // example: 3
         HEDGE: number   // example: 0  // only a sign, ignore the value
       }
     } |
     {
       symbol: string,  // example: "BTCUSD_201225"
       adlQuantile: {
         LONG: number,   // example: 1  // adl quantile for "LONG" position in hedge mode
         SHORT: number,  // example: 2  // adl qauntile for "SHORT" position in hedge mode
         BOTH: number    // example: 0  // adl qunatile for position in one-way mode
       }
     }
    )[]>;
  
  
  dapi_positionADLQuantileEstimation(...args : any) {
      return this._sendRequest("/dapi/v1/adlQuantile", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "dapi_positionADLQuantileEstimation");
  }
  
  
  /** User Commission Rate (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#user-commission-rate-user_data}
   * 
   * EndPoint: /dapi/v1/commissionRate
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_userCommissionRate(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_userCommissionRate"]>;
  
  
  /** User Commission Rate (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#user-commission-rate-user_data}
   * 
   * EndPoint: /dapi/v1/commissionRate
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_userCommissionRate(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "BTCUSD_PERP"
     makerCommissionRate: NumberString,  // example: "0.00015"  // 0.015%
     takerCommissionRate: NumberString  // example: "0.00040"  // 0.040%
    }>;
  
  
  dapi_userCommissionRate(...args : any) {
      return this._sendRequest("/dapi/v1/commissionRate", "GET", "USER_DATA", true, args, ["symbol", "recvWindow", "timestamp"], "dapi_userCommissionRate");
  }
  
  
  /** Get Download Id For Futures Transaction History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-download-id-for-futures-transaction-history-user_data}
   * 
   * EndPoint: /dapi/v1/income/asyn
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} startTime  -  Timestamp in ms
   * @param {LONG} endTime  -  Timestamp in ms
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_getDownloadIdForFuturesTransactionHistory(startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_getDownloadIdForFuturesTransactionHistory"]>;
  
  
  /** Get Download Id For Futures Transaction History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-download-id-for-futures-transaction-history-user_data}
   * 
   * EndPoint: /dapi/v1/income/asyn
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.startTime  -  Timestamp in ms
   * @param {LONG} options.endTime  -  Timestamp in ms
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_getDownloadIdForFuturesTransactionHistory(options : { startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgCostTimestampOfLast30d: number,  // example: 7241837  // Average time taken for data download in the past 30 days
     downloadId: NumberString  // example: "546975389218332672"
    }>;
  
  
  dapi_getDownloadIdForFuturesTransactionHistory(...args : any) {
      return this._sendRequest("/dapi/v1/income/asyn", "GET", "USER_DATA", true, args, ["startTime", "endTime", "recvWindow", "timestamp"], "dapi_getDownloadIdForFuturesTransactionHistory");
  }
  
  
  /** Get Futures Transaction History Download Link by Id (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-futures-transaction-history-download-link-by-id-user_data}
   * 
   * EndPoint: /dapi/v1/income/asyn/id
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} downloadId  -  get by download id api
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  dapi_getFuturesTransactionHistoryDownloadLinkById(downloadId :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["dapi_getFuturesTransactionHistoryDownloadLinkById"]>;
  
  
  /** Get Futures Transaction History Download Link by Id (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#get-futures-transaction-history-download-link-by-id-user_data}
   * 
   * EndPoint: /dapi/v1/income/asyn/id
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.downloadId  -  get by download id api
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  dapi_getFuturesTransactionHistoryDownloadLinkById(options : { downloadId :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     downloadId: NumberString,  // example: "545923594199212032"
     status: string,  // example: "completed"  // Enum:completed,processing
     url: string,  // example: "www.binance.com"  // The link is mapped to download id
     notified: boolean,  // example: true  // ignore
     expirationTimestamp: number,  // example: 1645009771000  // The link would expire after this timestamp
     isExpired: null  // example: null
    }>;
  
  
  dapi_getFuturesTransactionHistoryDownloadLinkById(...args : any) {
      return this._sendRequest("/dapi/v1/income/asyn/id", "GET", "USER_DATA", true, args, ["downloadId", "recvWindow", "timestamp"], "dapi_getFuturesTransactionHistoryDownloadLinkById");
  }
  
  
  
  //***** User Data Streams *****
  
  
  /** Start User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#start-user-data-stream-user_stream}
   * 
   * EndPoint: /dapi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  dapi_startUserDataStream() : Promise<{
     listenKey: string  // example: "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
    }> {
      return this._sendRequest("/dapi/v1/listenKey", "POST", "USER_STREAM", false, [], [], "dapi_startUserDataStream");
  }
  
  
  /** Keepalive User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#keepalive-user-data-stream-user_stream}
   * 
   * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. 
   * 
   * EndPoint: /dapi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  dapi_keepaliveUserDataStream() : Promise<{
    }> {
      return this._sendRequest("/dapi/v1/listenKey", "PUT", "USER_STREAM", false, [], [], "dapi_keepaliveUserDataStream");
  }
  
  
  /** Close User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#close-user-data-stream-user_stream}
   * 
   * Close out a user data stream.
   * 
   * EndPoint: /dapi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  dapi_closeUserDataStream() : Promise<{
    }> {
      return this._sendRequest("/dapi/v1/listenKey", "DELETE", "USER_STREAM", false, [], [], "dapi_closeUserDataStream");
  }
  
  
  
  //***** Classic Portfolio Margin Endpoints *****
  
  
  /** Query Classic Portfolio Margin Notional Limit (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#query-classic-portfolio-margin-notional-limit-user_data}
   * 
   * Get Classic Portfolio Margin notional limit.
   * 
   * EndPoint: /dapi/v1/pmExchangeInfo
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {string} pair
   */
  dapi_queryClassicPortfolioMarginNotionalLimit(symbol? :string, pair? :string)
  : ReturnType<MyBinanceClient["dapi_queryClassicPortfolioMarginNotionalLimit"]>;
  
  
  /** Query Classic Portfolio Margin Notional Limit (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#query-classic-portfolio-margin-notional-limit-user_data}
   * 
   * Get Classic Portfolio Margin notional limit.
   * 
   * EndPoint: /dapi/v1/pmExchangeInfo
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {string} options.pair
   */
  dapi_queryClassicPortfolioMarginNotionalLimit(options? : { symbol? :string, pair? :string })
  : Promise<{
     notionalLimits: (
       {
         symbol: string,  // example: "BTCUSD_PERP"  // Symbol
         pair: string,  // example: "BTCUSD"  // Pair
         notionalLimit: NumberString  // example: "500"  // Classic Portfolio Margin Notional Limit in coin
       } |
       {
         symbol: string,  // example: "BTCUSD_220624"
         pair: string,  // example: "BTCUSD"
         " notionalLimit": NumberString
       }
     )[]
    }>;
  
  
  dapi_queryClassicPortfolioMarginNotionalLimit(...args : any) {
      return this._sendRequest("/dapi/v1/pmExchangeInfo", "GET", "USER_DATA", false, args, ["symbol", "pair"], "dapi_queryClassicPortfolioMarginNotionalLimit");
  }
  
  
  /** Classic Portfolio Margin Account Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#classic-portfolio-margin-account-information-user_data}
   * 
   * Get Classic Portfolio Margin current account information.
   * 
   * EndPoint: /dapi/v1/pmAccountInfo
   * 
   * Weight(IP): 5
   * 
   * @param {string} asset
   * @param {LONG} recvWindow
   */
  dapi_classicPortfolioMarginAccountInformation(asset :string, recvWindow? :LONG)
  : ReturnType<MyBinanceClient["dapi_classicPortfolioMarginAccountInformation"]>;
  
  
  /** Classic Portfolio Margin Account Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/delivery/en/#classic-portfolio-margin-account-information-user_data}
   * 
   * Get Classic Portfolio Margin current account information.
   * 
   * EndPoint: /dapi/v1/pmAccountInfo
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.asset
   * @param {LONG} options.recvWindow
   */
  dapi_classicPortfolioMarginAccountInformation(options : { asset :string, recvWindow? :LONG })
  : Promise<{
     maxWithdrawAmountUSD: NumberString,  // example: "25347.92083245"  // Classic Portfolio margin maximum virtual amount for transfer out in USD
     asset: string,  // example: "BTC"  // asset name
     maxWithdrawAmount: NumberString  // example: "1.33663654"  // maximum amount for transfer out
    }>;
  
  
  dapi_classicPortfolioMarginAccountInformation(...args : any) {
      return this._sendRequest("/dapi/v1/pmAccountInfo", "GET", "USER_DATA", false, args, ["asset", "recvWindow"], "dapi_classicPortfolioMarginAccountInformation");
  }
  
  
  
  //======== EUROPEAN OPTIONS ========
  
  
  //***** Market Data Endpoints *****
  
  
  /** Test Connectivity
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#test-connectivity}
   * 
   * Test connectivity to the Rest API.
   * 
   * EndPoint: /eapi/v1/ping
   * 
   * Weight(IP): 1
   * 
   */
  eapi_testConnectivity() : Promise<{
    }> {
      return this._sendRequest("/eapi/v1/ping", "GET", "MARKET_DATA", false, [], [], "eapi_testConnectivity");
  }
  
  
  /** Check Server Time
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#check-server-time}
   * 
   * Test connectivity to the Rest API and get the current server time.
   * 
   * EndPoint: /eapi/v1/time
   * 
   * Weight(IP): 1
   * 
   */
  eapi_checkServerTime() : Promise<{
     serverTime: number  // example: 1499827319559
    }> {
      return this._sendRequest("/eapi/v1/time", "GET", "MARKET_DATA", false, [], [], "eapi_checkServerTime");
  }
  
  
  /** Exchange Information
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#exchange-information}
   * 
   * Current exchange trading rules and symbol information
   * 
   * EndPoint: /eapi/v1/exchangeInfo
   * 
   * Weight(IP): 1
   * 
   */
  eapi_exchangeInformation() : Promise<{
     timezone: string,  // example: "UTC"  // Time zone used by the server
     serverTime: number,  // example: 1592387337630  // Current system time
     optionContracts: {
         id: number,  // example: 1
         baseAsset: string,  // example: "BTC"  // Base currency
         quoteAsset: string,  // example: "USDT"  // Quotation asset
         underlying: string,  // example: "BTCUSDT"  // Name of the underlying asset of the option contract
         settleAsset: string  // example: "USDT"  // Settlement currency
       }[],
     optionAssets: {
         id: number,   // example: 1
         name: string  // example: "USDT"  // Asset name
       }[],
     optionSymbols: {
         contractId: number,  // example: 2
         expiryDate: number,  // example: 1660521600000  // expiry time
         filters: (
           {
             filterType: "PRICE_FILTER",  // example: "PRICE_FILTER"
             minPrice: NumberString,  // example: "0.02"
             maxPrice: NumberString,  // example: "80000.01"
             tickSize: NumberString  // example: "0.01"
           } |
           {
             filterType: "LOT_SIZE",  // example: "LOT_SIZE"
             minQty: NumberString,  // example: "0.01"
             maxQty: NumberString,  // example: "100"
             stepSize: NumberString  // example: "0.01"
           }
         )[],
         id: number,  // example: 17
         symbol: string,  // example: "BTC-220815-50000-C"  // Trading pair name
         side: string,  // example: "CALL"  // Direction: CALL long, PUT short
         strikePrice: NumberString,  // example: "50000"  // Strike price
         underlying: string,  // example: "BTCUSDT"  // Underlying asset of the contract
         unit: number,  // example: 1  // Contract unit, the quantity of the underlying asset represented by a single contract.
         makerFeeRate: NumberString,  // example: "0.0002"  // maker commission rate
         takerFeeRate: NumberString,  // example: "0.0002"  // taker commission rate
         minQty: NumberString,  // example: "0.01"  // Minimum order quantity
         maxQty: NumberString,  // example: "100"  // Maximum order quantity
         initialMargin: NumberString,  // example: "0.15"  // Initial Magin Ratio
         maintenanceMargin: NumberString,  // example: "0.075"  // Maintenance Margin Ratio
         minInitialMargin: NumberString,  // example: "0.1"  // Min Initial Margin Ratio
         minMaintenanceMargin: NumberString,  // example: "0.05"  // Min Maintenance Margin Ratio
         priceScale: number,  // example: 2  // price precision
         quantityScale: number,  // example: 2  // quantity precision
         quoteAsset: string  // example: "USDT"  // Quotation asset
       }[],
     rateLimits: {
         rateLimitType: RateLimitType,  // example: "REQUEST_WEIGHT"
         interval: RateLimitInterval,  // example: "MINUTE"
         intervalNum: number,  // example: 1
         limit: number  // example: 2400
       }[]
    }> {
      return this._sendRequest("/eapi/v1/exchangeInfo", "GET", "MARKET_DATA", false, [], [], "eapi_exchangeInformation");
  }
  
  
  /** Order Book
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#order-book}
   * 
   * EndPoint: /eapi/v1/depth
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {INT} limit  -  Default:100 Max:1000.Optional value:[10, 20, 50, 100, 500, 1000]
   */
  eapi_orderBook(symbol :string, limit? :INT)  : ReturnType<MyBinanceClient["eapi_orderBook"]>;
  
  
  /** Order Book
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#order-book}
   * 
   * EndPoint: /eapi/v1/depth
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {INT} options.limit  -  Default:100 Max:1000.Optional value:[10, 20, 50, 100, 500, 1000]
   */
  eapi_orderBook(options : { symbol :string, limit? :INT })
  : Promise<{
     T: number,  // example: 1589436922972  // transaction time
     u: number,  // example: 37461  // update id
     bids: NumberString[]  // example: "1000"  // Price[],
     asks: NumberString[]  // example: "1100"  // Price[]
    }>;
  
  
  eapi_orderBook(...args : any) {
      return this._sendRequest("/eapi/v1/depth", "GET", "MARKET_DATA", false, args, ["symbol", "limit"], "eapi_orderBook");
  }
  
  
  /** Recent Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#recent-trades-list}
   * 
   * Get recent market trades
   * 
   * EndPoint: /eapi/v1/trades
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {INT} limit  -  Number of records Default:100 Max:500
   */
  eapi_recentTradesList(symbol :string, limit? :INT)  : ReturnType<MyBinanceClient["eapi_recentTradesList"]>;
  
  
  /** Recent Trades List
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#recent-trades-list}
   * 
   * Get recent market trades
   * 
   * EndPoint: /eapi/v1/trades
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {INT} options.limit  -  Number of records Default:100 Max:500
   */
  eapi_recentTradesList(options : { symbol :string, limit? :INT })
  : Promise<{
       id: NumberString,  // example: "1"  // TradeId
       symbol: string,  // example: "BTC-220722-19000-C"
       price: NumberString,  // example: "1000"  // Completed trade price
       qty: NumberString,  // example: "-0.1"  // Completed trade quantity
       quoteQty: NumberString,  // example: "-100"  // Completed trade amount
       side: number,  // example: -1  // Completed trade direction（-1 Sell,1 Buy）
       time: number  // example: 1592449455993  // Time
     }[]>;
  
  
  eapi_recentTradesList(...args : any) {
      return this._sendRequest("/eapi/v1/trades", "GET", "MARKET_DATA", false, args, ["symbol", "limit"], "eapi_recentTradesList");
  }
  
  
  /** Old Trades Lookup (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#old-trades-lookup-market_data}
   * 
   * Get older market historical trades.
   * 
   * EndPoint: /eapi/v1/historicalTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} fromId  -  The UniqueId ID from which to return. The latest deal record is returned by default
   * @param {INT} limit  -  Number of records Default:100 Max:500
   */
  eapi_oldTradesLookup(symbol :string, fromId? :LONG, limit? :INT)  : ReturnType<MyBinanceClient["eapi_oldTradesLookup"]>;
  
  
  /** Old Trades Lookup (MARKET_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#old-trades-lookup-market_data}
   * 
   * Get older market historical trades.
   * 
   * EndPoint: /eapi/v1/historicalTrades
   * 
   * Weight(IP): 20
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} options.fromId  -  The UniqueId ID from which to return. The latest deal record is returned by default
   * @param {INT} options.limit  -  Number of records Default:100 Max:500
   */
  eapi_oldTradesLookup(options : { symbol :string, fromId? :LONG, limit? :INT })
  : Promise<{
       id: NumberString,  // example: "1"  // UniqueId
       tradeId: NumberString,  // example: "159244329455993"  // TradeId
       price: NumberString,  // example: "1000"  // Completed trade price
       qty: NumberString,  // example: "-0.1"  // Completed trade Quantity
       quoteQty: NumberString,  // example: "-100"  // Completed trade amount
       side: number,  // example: -1  // Completed trade direction（-1 Sell,1 Buy）
       time: number  // example: 1592449455993  // Time
     }[]>;
  
  
  eapi_oldTradesLookup(...args : any) {
      return this._sendRequest("/eapi/v1/historicalTrades", "GET", "MARKET_DATA", false, args, ["symbol", "fromId", "limit"], "eapi_oldTradesLookup");
  }
  
  
  /** Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#kline-candlestick-data}
   * 
   * Kline/candlestick bars for an option symbol. 
   * Klines are uniquely identified by their open time.
   * 
   * EndPoint: /eapi/v1/klines
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {string} interval  -  Time interval
   * @param {LONG} startTime  -  Start Time  1592317127349
   * @param {LONG} endTime  -  End Time
   * @param {INT} limit  -  Number of records Default:500 Max:1500
   */
  eapi_klineCandlestickData(symbol :string, interval :string, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["eapi_klineCandlestickData"]>;
  
  
  /** Kline/Candlestick Data
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#kline-candlestick-data}
   * 
   * Kline/candlestick bars for an option symbol. 
   * Klines are uniquely identified by their open time.
   * 
   * EndPoint: /eapi/v1/klines
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {string} options.interval  -  Time interval
   * @param {LONG} options.startTime  -  Start Time  1592317127349
   * @param {LONG} options.endTime  -  End Time
   * @param {INT} options.limit  -  Number of records Default:500 Max:1500
   */
  eapi_klineCandlestickData(options : { symbol :string, interval :string, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<{
       open: NumberString,  // example: "950"  // Opening price
       high: NumberString,  // example: "1100"  // Highest price
       low: NumberString,  // example: "900"  // Lowest price
       close: NumberString,  // example: "1000"  // Closing price (latest price if the current candle has not closed)
       volume: NumberString,  // example: "100"  // Trading volume(contracts)
       amount: NumberString,  // example: "2"  // Trading amount(in quote asset)
       interval: string,  // example: "5m"  // Candle type
       tradeCount: number,  // example: 10  // Number of completed trades
       takerVolume: NumberString,  // example: "100"  // Taker trading volume(contracts)
       takerAmount: NumberString,  // example: "10000"  // Taker trade amount(in quote asset)
       openTime: number,  // example: 1499040000000  // Opening time
       closeTime: number  // example: 1499644799999  // Closing time
     }[]>;
  
  
  eapi_klineCandlestickData(...args : any) {
      return this._sendRequest("/eapi/v1/klines", "GET", "MARKET_DATA", false, args, ["symbol", "interval", "startTime", "endTime", "limit"], "eapi_klineCandlestickData");
  }
  
  
  /** Option Mark Price
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#option-mark-price}
   * 
   * Option mark price and greek info.
   * 
   * EndPoint: /eapi/v1/mark
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   */
  eapi_optionMarkPrice(symbol? :string)  : ReturnType<MyBinanceClient["eapi_optionMarkPrice"]>;
  
  
  /** Option Mark Price
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#option-mark-price}
   * 
   * Option mark price and greek info.
   * 
   * EndPoint: /eapi/v1/mark
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   */
  eapi_optionMarkPrice(options? : { symbol? :string })
  : Promise<{
       symbol: string,  // example: "BTC-200730-9000-C"
       markPrice: NumberString,  // example: "1343.2883"  // Mark price
       bidIV: NumberString,  // example: "1.40000077"  // Implied volatility Buy
       askIV: NumberString,  // example: "1.50000153"  // Implied volatility Sell
       markIV: NumberString,  // example: "1.45000000"  // Implied volatility mark
       delta: NumberString,  // example: "0.55937056"  // delta
       theta: NumberString,  // example: "3739.82509871"  // theta
       gamma: NumberString,  // example: "0.00010969"  // gamma
       vega: NumberString,  // example: "978.58874732"  // vega
       highPriceLimit: NumberString,  // example: "1618.241"  // Current highest buy price
       lowPriceLimit: NumberString  // example: "1068.3356"  // Current lowest sell price
     }[]>;
  
  
  eapi_optionMarkPrice(...args : any) {
      return this._sendRequest("/eapi/v1/mark", "GET", "MARKET_DATA", false, args, ["symbol"], "eapi_optionMarkPrice");
  }
  
  
  /** 24hr Ticker Price Change Statistics
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#24hr-ticker-price-change-statistics}
   * 
   * 24 hour rolling window price change statistics.
   * 
   * EndPoint: /eapi/v1/ticker
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   */
  eapi_tickerPriceChangeStatistics24hr(symbol? :string)
  : ReturnType<MyBinanceClient["eapi_tickerPriceChangeStatistics24hr"]>;
  
  
  /** 24hr Ticker Price Change Statistics
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#24hr-ticker-price-change-statistics}
   * 
   * 24 hour rolling window price change statistics.
   * 
   * EndPoint: /eapi/v1/ticker
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   */
  eapi_tickerPriceChangeStatistics24hr(options? : { symbol? :string })
  : Promise<{
       symbol: string,  // example: "BTC-200730-9000-C"
       priceChange: NumberString,  // example: "-16.2038"  //24-hour price change
       priceChangePercent: NumberString,  // example: "-0.0162"  //24-hour percent price change
       lastPrice: NumberString,  // example: "1000"  //Last trade price
       lastQty: NumberString,  // example: "1000"  //Last trade amount
       open: NumberString,  // example: "1016.2038"  //24-hour open price
       high: NumberString,  // example: "1016.2038"  //24-hour high
       low: NumberString,  // example: "0"  //24-hour low
       volume: NumberString,  // example: "5"  //Trading volume(contracts)
       amount: NumberString,  // example: "1"  //Trade amount(in quote asset)
       bidPrice: NumberString,  // example: "999.34"  //The best buy price
       askPrice: NumberString,  // example: "1000.23"  //The best sell price
       openTime: number,  // example: 1592317127349  //Time the first trade occurred within the last 24 hours
       closeTime: number,  // example: 1592380593516  //Time the last trade occurred within the last 24 hours
       firstTradeId: number,  // example: 1  //First trade ID
       tradeCount: number,  // example: 5  //Number of trades
       strikePrice: NumberString,  // example: "9000"  //Strike price
       exercisePrice: NumberString  // example: "3000.3356"  //return estimated settlement price one hour before exercise, return index price at other times
     }[]>;
  
  
  eapi_tickerPriceChangeStatistics24hr(...args : any) {
      return this._sendRequest("/eapi/v1/ticker", "GET", "MARKET_DATA", false, args, ["symbol"], "eapi_tickerPriceChangeStatistics24hr");
  }
  
  
  /** Symbol Price Ticker
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#symbol-price-ticker}
   * 
   * Get spot index price for option underlying.
   * 
   * EndPoint: /eapi/v1/index
   * 
   * Weight(IP): 1
   * 
   * @param {string} underlying  -  Spot pair（Option contract underlying asset, e.g BTCUSDT)
   */
  eapi_symbolPriceTicker(underlying :string)  : ReturnType<MyBinanceClient["eapi_symbolPriceTicker"]>;
  
  
  /** Symbol Price Ticker
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#symbol-price-ticker}
   * 
   * Get spot index price for option underlying.
   * 
   * EndPoint: /eapi/v1/index
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.underlying  -  Spot pair（Option contract underlying asset, e.g BTCUSDT)
   */
  eapi_symbolPriceTicker(options : { underlying :string })
  : Promise<{
     time: number,  // example: 1656647305000
     indexPrice: NumberString  // example: "9200"  // Current spot index price
    }>;
  
  
  eapi_symbolPriceTicker(...args : any) {
      return this._sendRequest("/eapi/v1/index", "GET", "MARKET_DATA", false, args, ["underlying"], "eapi_symbolPriceTicker");
  }
  
  
  /** Historical Exercise Records
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#historical-exercise-records}
   * 
   * REALISTIC_VALUE_STRICKEN -> Exercised
   * 
   * EndPoint: /eapi/v1/exerciseHistory
   * 
   * Weight(IP): 3
   * 
   * @param {string} underlying  -  Underlying index like BTCUSDT
   * @param {LONG} startTime  -  Start Time
   * @param {LONG} endTime  -  End Time
   * @param {INT} limit  -  Number of records Default:100 Max:100
   */
  eapi_historicalExerciseRecords(underlying? :string, startTime? :LONG, endTime? :LONG, limit? :INT)
  : ReturnType<MyBinanceClient["eapi_historicalExerciseRecords"]>;
  
  
  /** Historical Exercise Records
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#historical-exercise-records}
   * 
   * REALISTIC_VALUE_STRICKEN -> Exercised
   * 
   * EndPoint: /eapi/v1/exerciseHistory
   * 
   * Weight(IP): 3
   * 
   * @param {string} options.underlying  -  Underlying index like BTCUSDT
   * @param {LONG} options.startTime  -  Start Time
   * @param {LONG} options.endTime  -  End Time
   * @param {INT} options.limit  -  Number of records Default:100 Max:100
   */
  eapi_historicalExerciseRecords(options? : { underlying? :string, startTime? :LONG, endTime? :LONG, limit? :INT })
  : Promise<{
       symbol: string,  // example: "BTC-220121-60000-P"  // symbol
       strikePrice: NumberString,  // example: "60000"  // strike price
       realStrikePrice: NumberString,  // example: "38844.69652571"  // real strike price
       expiryDate: number,  // example: 1642752000000  // Exercise time
       strikeResult: string  // example: "REALISTIC_VALUE_STRICKEN"  // strike result
     }[]>;
  
  
  eapi_historicalExerciseRecords(...args : any) {
      return this._sendRequest("/eapi/v1/exerciseHistory", "GET", "MARKET_DATA", false, args, ["underlying", "startTime", "endTime", "limit"], "eapi_historicalExerciseRecords");
  }
  
  
  /** Open interest
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#open-interest}
   * 
   * Get open interest for specific underlying asset on specific expiration date.
   * 
   * EndPoint: /eapi/v1/openInterest
   * 
   * @param {string} underlyingAsset  -  underlying asset, e.g ETH/BTC
   * @param {string} expiration  -  expiration date, e.g 221225
   */
  eapi_openInterest(underlyingAsset :string, expiration :string)  : ReturnType<MyBinanceClient["eapi_openInterest"]>;
  
  
  /** Open interest
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#open-interest}
   * 
   * Get open interest for specific underlying asset on specific expiration date.
   * 
   * EndPoint: /eapi/v1/openInterest
   * 
   * @param {string} options.underlyingAsset  -  underlying asset, e.g ETH/BTC
   * @param {string} options.expiration  -  expiration date, e.g 221225
   */
  eapi_openInterest(options : { underlyingAsset :string, expiration :string })
  : Promise<{
       symbol: string,  // example: "ETH-221119-1175-P"
       sumOpenInterest: NumberString,  // example: "4.01"
       sumOpenInterestUsd: NumberString,  // example: "4880.2985615624"
       timestamp: NumberString  // example: "1668754020000"
     }[]>;
  
  
  eapi_openInterest(...args : any) {
      return this._sendRequest("/eapi/v1/openInterest", "GET", "MARKET_DATA", false, args, ["underlyingAsset", "expiration"], "eapi_openInterest");
  }
  
  
  
  //***** Account/Trades Endpoints *****
  
  
  /** Option Account Information (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#option-account-information-trade}
   * 
   * Get current account information.
   * 
   * EndPoint: /eapi/v1/account
   * 
   * Weight(IP): 3
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_optionAccountInformation(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_optionAccountInformation"]>;
  
  
  /** Option Account Information (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#option-account-information-trade}
   * 
   * Get current account information.
   * 
   * EndPoint: /eapi/v1/account
   * 
   * Weight(IP): 3
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_optionAccountInformation(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     asset: {
         asset: string,  // example: "USDT"  // Asset type
         marginBalance: NumberString,  // example: "1877.52214415"  // Account balance
         equity: NumberString,  // example: "617.77711415"  // Account equity
         available: NumberString,  // example: "0"  // Available funds
         locked: NumberString,  // example: "2898.92389933"  // locked balance for order and position
         unrealizedPNL: NumberString  // example: "222.23697000"  // Unrealized profit/loss
       }[],
     greek: {
         underlying: string,  // example: "BTCUSDT"  // Option Underlying
         delta: NumberString,  // example: "-0.05"  // Account delta
         gamma: NumberString,  // example: "-0.002"  // Account gamma
         theta: NumberString,  // example: "-0.05"  // Account theta
         vega: NumberString  // example: "-0.002"  // Account vega
       }[],
     riskLevel: string,  // example: "NORMAL"  // Account risk level
     time: number  // example: 1592449455993  // Time
    }>;
  
  
  eapi_optionAccountInformation(...args : any) {
      return this._sendRequest("/eapi/v1/account", "GET", "TRADE", true, args, ["recvWindow", "timestamp"], "eapi_optionAccountInformation");
  }
  
  
  /** New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#new-order-trade}
   * 
   * Send a new order.
   * 
   * EndPoint: /eapi/v1/order
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {OrderSide} side  -  Buy/sell direction: SELL, BUY
   * @param {OrderType} type  -  Order Type: LIMIT(only support limit)
   * @param {DECIMAL} quantity  -  Order Quantity
   * @param {DECIMAL} price  -  Order Price
   * @param {TimeInForce} timeInForce  -  Time in force method（Default GTC）
   * @param {boolean} reduceOnly  -  Reduce Only（Default false）
   * @param {boolean} postOnly  -  Post Only（Default false）
   * @param {OrderResponseType} newOrderRespType  -  "ACK", "RESULT", Default "ACK"
   * @param {string} clientOrderId  -  User-defined order ID cannot be repeated in pending orders
   * @param {boolean} isMmp  -  is market maker protection order, true/false
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_newOrder(symbol :string, side :OrderSide, type :OrderType, quantity :DECIMAL, price? :DECIMAL, timeInForce? :TimeInForce, reduceOnly? :boolean, postOnly? :boolean, newOrderRespType? :OrderResponseType, clientOrderId? :string, isMmp? :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_newOrder"]>;
  
  
  /** New Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#new-order-trade}
   * 
   * Send a new order.
   * 
   * EndPoint: /eapi/v1/order
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {OrderSide} options.side  -  Buy/sell direction: SELL, BUY
   * @param {OrderType} options.type  -  Order Type: LIMIT(only support limit)
   * @param {DECIMAL} options.quantity  -  Order Quantity
   * @param {DECIMAL} options.price  -  Order Price
   * @param {TimeInForce} options.timeInForce  -  Time in force method（Default GTC）
   * @param {boolean} options.reduceOnly  -  Reduce Only（Default false）
   * @param {boolean} options.postOnly  -  Post Only（Default false）
   * @param {OrderResponseType} options.newOrderRespType  -  "ACK", "RESULT", Default "ACK"
   * @param {string} options.clientOrderId  -  User-defined order ID cannot be repeated in pending orders
   * @param {boolean} options.isMmp  -  is market maker protection order, true/false
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_newOrder(options : { symbol :string, side :OrderSide, type :OrderType, quantity :DECIMAL, price? :DECIMAL, timeInForce? :TimeInForce, reduceOnly? :boolean, postOnly? :boolean, newOrderRespType? :OrderResponseType, clientOrderId? :string, isMmp? :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  // ACK:
     orderId: number,  // example: 4611875134427365000  // System order number
     clientOrderId: string,  // example: ""  // Client order ID
     symbol: string,  // example: "BTC-200730-9000-C"  // Option trading pair
     price: NumberString,  // example: "100"  // Order Price
     quantity: NumberString,  // example: "1"  // Order Quantity
     side: OrderSide,  // example: "BUY"  // Buy/sell direction
     type: OrderType,  // example: "LIMIT"  // Order type
     createDate: number,  // example: 1592465880683  // Order Time
     updateTime: number  // example: 1566818724722  // Update time
    } | {  // RESULT:
     orderId: number,  // example: 4611875134427365000  // System order number
     symbol: string,  // example: "BTC-200730-9000-C"  // Option trading pair
     price: NumberString,  // example: "100"  // Order Price
     quantity: NumberString,  // example: "1"  // Order Quantity
     executedQty: NumberString,  // example: "0"  // Number of executed quantity
     fee: NumberString,  // example: "0"  // Fee
     side: OrderSide,  // example: "BUY"  // Buy/sell direction
     type: OrderType,  // example: "LIMIT"  // Order type
     timeInForce: TimeInForce,  // example: "GTC"  // Time in force method
     reduceOnly: boolean,  // example: false  // Order is reduce only Y/N
     postOnly: boolean,  // example: false  // Order is post only
     createTime: number,  // example: 1592465880683  // Order Time
     updateTime: number,  // example: 1566818724722  // Update time
     status: string,  // example: "ACCEPTED"  // Order status
     avgPrice: NumberString,  // example: "0"  // Average price of completed trade
     clientOrderId: string,  // example: ""  // Client order ID
     priceScale: number,  // example: 2
     quantityScale: number,  // example: 2
     optionSide: string,  // example: "CALL"
     quoteAsset: string,  // example: "USDT"
     mmp: boolean  // example: false
    }>;
  
  
  eapi_newOrder(...args : any) {
      return this._sendRequest("/eapi/v1/order", "POST", "TRADE", true, args, ["symbol", "side", "type", "quantity", "price", "timeInForce", "reduceOnly", "postOnly", "newOrderRespType", "clientOrderId", "isMmp", "recvWindow", "timestamp"], "eapi_newOrder");
  }
  
  
  /** Place Multiple Orders  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#place-multiple-orders-trade}
   * 
   * Send multiple option orders.
   * 
   * EndPoint: /eapi/v1/batchOrders
   * 
   * Weight(IP): 5
   * 
   * @param {[]} orders  -  order list. Max 5 orders
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_placeMultipleOrders(orders :[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_placeMultipleOrders"]>;
  
  
  /** Place Multiple Orders  (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#place-multiple-orders-trade}
   * 
   * Send multiple option orders.
   * 
   * EndPoint: /eapi/v1/batchOrders
   * 
   * Weight(IP): 5
   * 
   * @param {[]} options.orders  -  order list. Max 5 orders
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_placeMultipleOrders(options : { orders :[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderId: number,  // example: 4612288550799409000  // System order number
       symbol: string,  // example: "ETH-220826-1800-C"  // Option trading pair
       price: NumberString,  // example: "100"  // Order Price
       quantity: NumberString,  // example: "0.01"  // Order Quantity
       side: OrderSide,  // example: "BUY"  // Buy/sell direction
       type: OrderType,  // example: "LIMIT"  // Order type
       reduceOnly: boolean,  // example: false  // Order is reduce only Y/N
       postOnly: boolean,  // example: false  // Post only or not
       clientOrderId: NumberString,  // example: "1001"  // Client order ID
       mmp: boolean  // example: false  // MMP
     }[]>;
  
  
  eapi_placeMultipleOrders(...args : any) {
      return this._sendRequest("/eapi/v1/batchOrders", "POST", "TRADE", false, args, ["orders", "recvWindow", "timestamp"], "eapi_placeMultipleOrders");
  }
  
  
  /** Query Single Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#query-single-order-trade}
   * 
   * Check an order status.
   * 
   * EndPoint: /eapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} orderId  -  Order id
   * @param {string} clientOrderId  -  User-defined order ID cannot be repeated in pending orders
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_querySingleOrder(symbol :string, orderId? :LONG, clientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_querySingleOrder"]>;
  
  
  /** Query Single Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#query-single-order-trade}
   * 
   * Check an order status.
   * 
   * EndPoint: /eapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} options.orderId  -  Order id
   * @param {string} options.clientOrderId  -  User-defined order ID cannot be repeated in pending orders
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_querySingleOrder(options : { symbol :string, orderId? :LONG, clientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderId: number,  // example: 4611875134427365000  // System order id
     symbol: string,  // example: "BTC-200730-9000-C"  // Option trading pair
     price: NumberString,  // example: "100"  // Order Price
     quantity: NumberString,  // example: "1"  // Order Quantity
     executedQty: NumberString,  // example: "0"  // Number of executed quantity
     fee: NumberString,  // example: "0"  // Fee
     side: OrderSide,  // example: "BUY"  // Buy/sell direction
     type: OrderType,  // example: "LIMIT"  // Order type
     timeInForce: TimeInForce,  // example: "GTC"  // Time in force method
     reduceOnly: boolean,  // example: false  // Order is reduce only Y/N
     postOnly: boolean,  // example: false  // Order is post only
     createTime: number,  // example: 1592465880683  // Order Time
     updateTime: number,  // example: 1566818724722  // Update time
     status: string,  // example: "ACCEPTED"  // Order status
     avgPrice: NumberString,  // example: "0"  // Average price of completed trade
     source: string,  // example: "API"  // Order source
     clientOrderId: string,  // example: ""  // Client order ID
     priceScale: number,  // example: 2
     quantityScale: number,  // example: 2
     optionSide: string,  // example: "CALL"
     quoteAsset: string,  // example: "USDT"
     mmp: boolean  // example: false
    } | {  // No Order
     code: number,  // example: -2013
     msg: string    // example: "Order does not exist"
    }>;
  
  
  eapi_querySingleOrder(...args : any) {
      return this._sendRequest("/eapi/v1/order", "GET", "TRADE", true, args, ["symbol", "orderId", "clientOrderId", "recvWindow", "timestamp"], "eapi_querySingleOrder");
  }
  
  
  /** Cancel Option Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#cancel-option-order-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /eapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} orderId  -  Order ID, e.g 4611875134427365377
   * @param {string} clientOrderId  -  User-defined order ID, e.g 10000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_cancelOptionOrder(symbol :string, orderId? :LONG, clientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_cancelOptionOrder"]>;
  
  
  /** Cancel Option Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#cancel-option-order-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /eapi/v1/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} options.orderId  -  Order ID, e.g 4611875134427365377
   * @param {string} options.clientOrderId  -  User-defined order ID, e.g 10000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_cancelOptionOrder(options : { symbol :string, orderId? :LONG, clientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderId: number,  // example: 4611875134427365000  // System order number
     symbol: string,  // example: "BTC-200730-9000-C"  // Option trading pair
     price: NumberString,  // example: "100"  // Order Price
     quantity: NumberString,  // example: "1"  // Order Quantity
     executedQty: NumberString,  // example: "0"  // Number of executed quantity
     fee: NumberString,  // example: "0"  // Fee
     side: OrderSide,  // example: "BUY"  // Buy/sell direction
     type: OrderType,  // example: "LIMIT"  // Order type
     timeInForce: TimeInForce,  // example: "GTC"  // Time in force method
     reduceOnly: boolean,  // example: false  // Order is reduce only Y/N
     postOnly: boolean,  // example: false
     createDate: number,  // example: 1592465880683  // Order Time
     updateTime: number,  // example: 1566818724722  // Update time
     status: string,  // example: "ACCEPTED"  // Order status
     avgPrice: NumberString,  // example: "0"  // Average price of completed trade
     source: string,  // example: "API"
     clientOrderId: string,  // example: ""  // Client order ID
     priceScale: number,  // example: 4
     quantityScale: number,  // example: 4
     optionSide: string,  // example: "CALL"
     quoteAsset: string,  // example: "USDT"
     mmp: boolean  // example: false
    }>;
  
  
  eapi_cancelOptionOrder(...args : any) {
      return this._sendRequest("/eapi/v1/order", "DELETE", "TRADE", true, args, ["symbol", "orderId", "clientOrderId", "recvWindow", "timestamp"], "eapi_cancelOptionOrder");
  }
  
  
  /** Cancel Multiple Option Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#cancel-multiple-option-orders-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /eapi/v1/batchOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG[]} orderIds  -  Order ID, e.g [4611875134427365377,4611875134427365378]
   * @param {string[]} clientOrderIds  -  User-defined order ID, e.g ["my_id_1","my_id_2"]
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_cancelMultipleOptionOrders(symbol :string, orderIds? :readonly LONG[], clientOrderIds? :readonly string[], recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_cancelMultipleOptionOrders"]>;
  
  
  /** Cancel Multiple Option Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#cancel-multiple-option-orders-trade}
   * 
   * Cancel an active order.
   * 
   * EndPoint: /eapi/v1/batchOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG[]} options.orderIds  -  Order ID, e.g [4611875134427365377,4611875134427365378]
   * @param {string[]} options.clientOrderIds  -  User-defined order ID, e.g ["my_id_1","my_id_2"]
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_cancelMultipleOptionOrders(options : { symbol :string, orderIds? :readonly LONG[], clientOrderIds? :readonly string[], recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderId: number,  // example: 4611875134427365000  // System order number
       symbol: string,  // example: "BTC-200730-9000-C"  // Option trading pair
       price: NumberString,  // example: "100"  // Order Price
       quantity: NumberString,  // example: "1"  // Order Quantity
       executedQty: NumberString,  // example: "0"  // Number of completed quantity
       fee: number,  // example: 0  // Fee
       side: OrderSide,  // example: "BUY"  // Buy/sell direction
       type: OrderType,  // example: "LIMIT"  // Order type
       timeInForce: TimeInForce,  // example: "GTC"  // Time in force method
       createTime: number,  // example: 1592465880683  // Order Time
       status: string,  // example: "ACCEPTED"  // Order status
       avgPrice: NumberString,  // example: "0"  // Average price of completed trade
       reduceOnly: boolean,  // example: false  // Order is reduce only Y/N
       clientOrderId: string,  // example: ""  // Client order ID
       updateTime: number  // example: 1566818724722  // Update time
     }[]>;
  
  
  eapi_cancelMultipleOptionOrders(...args : any) {
      return this._sendRequest("/eapi/v1/batchOrders", "DELETE", "TRADE", true, args, ["symbol", "orderIds", "clientOrderIds", "recvWindow", "timestamp"], "eapi_cancelMultipleOptionOrders");
  }
  
  
  /** Cancel all Option orders on specific symbol (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#cancel-all-option-orders-on-specific-symbol-trade}
   * 
   * Cancel all active order on a symbol.
   * 
   * EndPoint: /eapi/v1/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_cancelAllOptionOrdersOnSpecificSymbol(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_cancelAllOptionOrdersOnSpecificSymbol"]>;
  
  
  /** Cancel all Option orders on specific symbol (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#cancel-all-option-orders-on-specific-symbol-trade}
   * 
   * Cancel all active order on a symbol.
   * 
   * EndPoint: /eapi/v1/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_cancelAllOptionOrdersOnSpecificSymbol(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string    // example: "success"
    }>;
  
  
  eapi_cancelAllOptionOrdersOnSpecificSymbol(...args : any) {
      return this._sendRequest("/eapi/v1/allOpenOrders", "DELETE", "TRADE", true, args, ["symbol", "recvWindow", "timestamp"], "eapi_cancelAllOptionOrdersOnSpecificSymbol");
  }
  
  
  /** Cancel All Option Orders By Underlying (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#cancel-all-option-orders-by-underlying-trade}
   * 
   * Cancel all active orders on specified underlying.
   * 
   * EndPoint: /eapi/v1/allOpenOrdersByUnderlying
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} underlying  -  Option underlying, e.g BTCUSDT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_cancelAllOptionOrdersByUnderlying(underlying :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_cancelAllOptionOrdersByUnderlying"]>;
  
  
  /** Cancel All Option Orders By Underlying (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#cancel-all-option-orders-by-underlying-trade}
   * 
   * Cancel all active orders on specified underlying.
   * 
   * EndPoint: /eapi/v1/allOpenOrdersByUnderlying
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.underlying  -  Option underlying, e.g BTCUSDT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_cancelAllOptionOrdersByUnderlying(options : { underlying :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 0
     msg: string,   // example: "success"
     data: number   // example: 0
    }>;
  
  
  eapi_cancelAllOptionOrdersByUnderlying(...args : any) {
      return this._sendRequest("/eapi/v1/allOpenOrdersByUnderlying", "DELETE", "TRADE", true, args, ["underlying", "recvWindow", "timestamp"], "eapi_cancelAllOptionOrdersByUnderlying");
  }
  
  
  /** Query Current Open Option Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#query-current-open-option-orders-user_data}
   * 
   * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
   * 
   * EndPoint: /eapi/v1/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol  -  return all orders if don't pass, Option trading pair, e.g BTC-200730-9000-C,
   * @param {LONG} orderId  -  Returns the orderId and subsequent orders, the most recent order is returned by default
   * @param {LONG} startTime  -  Start Time
   * @param {LONG} endTime  -  End Time
   * @param {INT} limit  -  Number of result sets returned Default:100 Max:1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_queryCurrentOpenOptionOrders(symbol? :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_queryCurrentOpenOptionOrders"]>;
  
  
  /** Query Current Open Option Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#query-current-open-option-orders-user_data}
   * 
   * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
   * 
   * EndPoint: /eapi/v1/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol  -  return all orders if don't pass, Option trading pair, e.g BTC-200730-9000-C,
   * @param {LONG} options.orderId  -  Returns the orderId and subsequent orders, the most recent order is returned by default
   * @param {LONG} options.startTime  -  Start Time
   * @param {LONG} options.endTime  -  End Time
   * @param {INT} options.limit  -  Number of result sets returned Default:100 Max:1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_queryCurrentOpenOptionOrders(options? : { symbol? :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderId: number,  // example: 4611875134427365000  // System order number
       symbol: string,  // example: "BTC-200730-9000-C"  // Option trading pair
       price: NumberString,  // example: "100"  // Order Price
       quantity: NumberString,  // example: "1"  // Order Quantity
       executedQty: NumberString,  // example: "0"  // Number of completed trades
       fee: NumberString,  // example: "0"  // Fee
       side: OrderSide,  // example: "BUY"  // Buy/sell direction
       type: OrderType,  // example: "LIMIT"  // Order type
       timeInForce: TimeInForce,  // example: "GTC"  // Time in force method
       reduceOnly: boolean,  // example: false  // Order is reduce only Y/N
       postOnly: boolean,  // example: false
       createTime: number,  // example: 1592465880683  // Order Time
       updateTime: number,  // example: 1592465880683  // Update Time
       status: string,  // example: "ACCEPTED"  // Order status
       avgPrice: NumberString,  // example: "0"  // Average price of completed trade
       clientOrderId: string,  // example: ""  // Client order ID
       priceScale: number,  // example: 2
       quantityScale: number,  // example: 2
       optionSide: string,  // example: "CALL"
       quoteAsset: string,  // example: "USDT"
       mmp: boolean  // example: false
     }[]>;
  
  
  eapi_queryCurrentOpenOptionOrders(...args : any) {
      return this._sendRequest("/eapi/v1/openOrders", "GET", "USER_DATA", true, args, ["symbol", "orderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "eapi_queryCurrentOpenOptionOrders");
  }
  
  
  /** Query Option Order History (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#query-option-order-history-trade}
   * 
   * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED. 
   * 
   * EndPoint: /eapi/v1/historyOrders
   * 
   * Weight(IP): 3
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol  -  Option trading pair
   * @param {LONG} orderId  -  Returns the orderId and subsequent orders, the most recent order is returned by default
   * @param {LONG} startTime  -  Start Time, e.g 1593511200000
   * @param {LONG} endTime  -  End Time, e.g 1593512200000
   * @param {INT} limit  -  Number of result sets returned Default:100 Max:1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_queryOptionOrderHistory(symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_queryOptionOrderHistory"]>;
  
  
  /** Query Option Order History (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#query-option-order-history-trade}
   * 
   * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED. 
   * 
   * EndPoint: /eapi/v1/historyOrders
   * 
   * Weight(IP): 3
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol  -  Option trading pair
   * @param {LONG} options.orderId  -  Returns the orderId and subsequent orders, the most recent order is returned by default
   * @param {LONG} options.startTime  -  Start Time, e.g 1593511200000
   * @param {LONG} options.endTime  -  End Time, e.g 1593512200000
   * @param {INT} options.limit  -  Number of result sets returned Default:100 Max:1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_queryOptionOrderHistory(options : { symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderId: number,  // example: 4611922413427360000
       symbol: string,  // example: "BTC-220715-2000-C"
       price: NumberString,  // example: "18000.00000000"
       quantity: NumberString,  // example: "-0.50000000"
       executedQty: NumberString,  // example: "-0.50000000"
       fee: NumberString,  // example: "3.00000000"
       side: OrderSide,  // example: "SELL"
       type: OrderType,  // example: "LIMIT"
       timeInForce: TimeInForce,  // example: "GTC"
       reduceOnly: boolean,  // example: false
       postOnly: boolean,  // example: false
       createTime: number,  // example: 1657867694244
       updateTime: number,  // example: 1657867888216
       status: string,  // example: "FILLED"
       reason: NumberString,  // example: "0"
       avgPrice: NumberString,  // example: "18000.00000000"
       source: string,  // example: "API"
       clientOrderId: string,  // example: ""
       priceScale: number,  // example: 2
       quantityScale: number,  // example: 2
       optionSide: string,  // example: "CALL"
       quoteAsset: string,  // example: "USDT"
       mmp: boolean  // example: false
     }[]>;
  
  
  eapi_queryOptionOrderHistory(...args : any) {
      return this._sendRequest("/eapi/v1/historyOrders", "GET", "TRADE", true, args, ["symbol", "orderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "eapi_queryOptionOrderHistory");
  }
  
  
  /** Option Position Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#option-position-information-user_data}
   * 
   * Get current position information.
   * 
   * EndPoint: /eapi/v1/position
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_optionPositionInformation(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_optionPositionInformation"]>;
  
  
  /** Option Position Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#option-position-information-user_data}
   * 
   * Get current position information.
   * 
   * EndPoint: /eapi/v1/position
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_optionPositionInformation(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       entryPrice: NumberString,  // example: "1000"  // Average entry price
       symbol: string,  // example: "BTC-200730-9000-C"  // Option trading pair
       side: string,  // example: "SHORT"  // Position direction
       quantity: NumberString,  // example: "-0.1"  // Number of positions (positive numbers represent long positions, negative number represent short positions)
       reducibleQty: NumberString,  // example: "0"  // Number of positions that can be reduced
       markValue: NumberString,  // example: "105.00138"  // Current market value
       ror: NumberString,  // example: "-0.05"  // Rate of return
       unrealizedPNL: NumberString,  // example: "-5.00138"  // Unrealized profit/loss
       markPrice: NumberString,  // example: "1050.0138"  // Mark price
       strikePrice: NumberString,  // example: "9000"  // Strike price
       positionCost: NumberString,  // example: "1000.0000"  // Position cost
       expiryDate: number,  // example: 1593511200000  // Exercise time
       priceScale: number,  // example: 2
       quantityScale: number,  // example: 2
       optionSide: string,  // example: "CALL"
       quoteAsset: string  // example: "USDT"
     }[]>;
  
  
  eapi_optionPositionInformation(...args : any) {
      return this._sendRequest("/eapi/v1/position", "GET", "USER_DATA", true, args, ["symbol", "recvWindow", "timestamp"], "eapi_optionPositionInformation");
  }
  
  
  /** Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#account-trade-list-user_data}
   * 
   * Get trades for a specific account and symbol.
   * 
   * EndPoint: /eapi/v1/userTrades
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol  -  Option symbol, e.g BTC-200730-9000-C
   * @param {LONG} fromId  -  Trade id to fetch from. Default gets most recent trades, e.g 4611875134427365376
   * @param {LONG} startTime  -  Start time, e.g 1593511200000
   * @param {LONG} endTime  -  End time, e.g 1593512200000
   * @param {INT} limit  -  Default 100; max 1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_accountTradeList(symbol? :string, fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_accountTradeList"]>;
  
  
  /** Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#account-trade-list-user_data}
   * 
   * Get trades for a specific account and symbol.
   * 
   * EndPoint: /eapi/v1/userTrades
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol  -  Option symbol, e.g BTC-200730-9000-C
   * @param {LONG} options.fromId  -  Trade id to fetch from. Default gets most recent trades, e.g 4611875134427365376
   * @param {LONG} options.startTime  -  Start time, e.g 1593511200000
   * @param {LONG} options.endTime  -  End time, e.g 1593512200000
   * @param {INT} options.limit  -  Default 100; max 1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_accountTradeList(options? : { symbol? :string, fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       id: number,  // example: 4611875134427365000  // unique id
       tradeId: number,  // example: 239  // trade id
       orderId: number,  // example: 4611875134427365000  // order id
       symbol: string,  // example: "BTC-200730-9000-C"  // option symbol
       price: NumberString,  // example: "100"  // trade price
       quantity: NumberString,  // example: "1"  // trade quantity
       fee: NumberString,  // example: "0"  // fee
       realizedProfit: NumberString,  // example: "0.00000000"  // realized profit/loss
       side: OrderSide,  // example: "BUY"  // order side
       type: OrderType,  // example: "LIMIT"  // order type
       volatility: NumberString,  // example: "0.9"  // volatility
       liquidity: string,  // example: "TAKER"  // TAKER or MAKER     
       quoteAsset: string,  // example: "USDT"  // quote asset
       time: number,  // example: 1592465880683  // trade time
       priceScale: number,  // example: 2
       quantityScale: number,  // example: 2
       optionSide: string  // example: "CALL"
     }[]>;
  
  
  eapi_accountTradeList(...args : any) {
      return this._sendRequest("/eapi/v1/userTrades", "GET", "USER_DATA", true, args, ["symbol", "fromId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "eapi_accountTradeList");
  }
  
  
  /** User Exercise Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#user-exercise-record-user_data}
   * 
   * Get account exercise records.
   * 
   * EndPoint: /eapi/v1/exerciseRecord
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} startTime  -  startTime
   * @param {LONG} endTime  -  endTime
   * @param {INT} limit  -  default 1000, max 1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_userExerciseRecord(symbol? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_userExerciseRecord"]>;
  
  
  /** User Exercise Record (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#user-exercise-record-user_data}
   * 
   * Get account exercise records.
   * 
   * EndPoint: /eapi/v1/exerciseRecord
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol  -  Option trading pair, e.g BTC-200730-9000-C
   * @param {LONG} options.startTime  -  startTime
   * @param {LONG} options.endTime  -  endTime
   * @param {INT} options.limit  -  default 1000, max 1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_userExerciseRecord(options? : { symbol? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       id: NumberString,  // example: "1125899906842624042"
       currency: string,  // example: "USDT"
       symbol: string,  // example: "BTC-220721-25000-C"
       exercisePrice: NumberString,  // example: "25000.00000000"
       markPrice: NumberString,  // example: "25000.00000000"
       quantity: NumberString,  // example: "1.00000000"
       amount: NumberString,  // example: "0.00000000"
       fee: NumberString,  // example: "0.00000000"
       createDate: number,  // example: 1658361600000
       priceScale: number,  // example: 2
       quantityScale: number,  // example: 2
       optionSide: string,  // example: "CALL"
       positionSide: PositionSide,  // example: "LONG"
       quoteAsset: string  // example: "USDT"
     }[]>;
  
  
  eapi_userExerciseRecord(...args : any) {
      return this._sendRequest("/eapi/v1/exerciseRecord", "GET", "USER_DATA", true, args, ["symbol", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "eapi_userExerciseRecord");
  }
  
  
  /** Account Funding Flow (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#account-funding-flow-user_data}
   * 
   * Query account funding flows.
   * 
   * EndPoint: /eapi/v1/bill
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} currency  -  Asset type, e.g USDT
   * @param {LONG} recordId  -  Return the recordId and subsequent data, the latest data is returned by default, e.g 100000
   * @param {LONG} startTime  -  Start Time, e.g 1593511200000
   * @param {LONG} endTime  -  End Time, e.g 1593512200000
   * @param {INT} limit  -  Number of result sets returned Default:100 Max:1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_accountFundingFlow(currency :string, recordId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_accountFundingFlow"]>;
  
  
  /** Account Funding Flow (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#account-funding-flow-user_data}
   * 
   * Query account funding flows.
   * 
   * EndPoint: /eapi/v1/bill
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.currency  -  Asset type, e.g USDT
   * @param {LONG} options.recordId  -  Return the recordId and subsequent data, the latest data is returned by default, e.g 100000
   * @param {LONG} options.startTime  -  Start Time, e.g 1593511200000
   * @param {LONG} options.endTime  -  End Time, e.g 1593512200000
   * @param {INT} options.limit  -  Number of result sets returned Default:100 Max:1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_accountFundingFlow(options : { currency :string, recordId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       id: number,  // example: 1125899906842624000
       asset: string,  // example: "USDT"  // Asset type
       amount: NumberString,  // example: "-0.552"  // Amount (positive numbers represent inflow, negative numbers represent outflow)
       type: string,  // example: "FEE"  // type (fees)
       createDate: number  // example: 1592449456000  // Time
     }[]>;
  
  
  eapi_accountFundingFlow(...args : any) {
      return this._sendRequest("/eapi/v1/bill", "GET", "USER_DATA", true, args, ["currency", "recordId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "eapi_accountFundingFlow");
  }
  
  
  /** Get Download Id For Option Transaction History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#get-download-id-for-option-transaction-history-user_data}
   * 
   * EndPoint: /eapi/v1/income/asyn
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} startTime  -  Timestamp in ms
   * @param {LONG} endTime  -  Timestamp in ms
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_getDownloadIdForOptionTransactionHistory(startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_getDownloadIdForOptionTransactionHistory"]>;
  
  
  /** Get Download Id For Option Transaction History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#get-download-id-for-option-transaction-history-user_data}
   * 
   * EndPoint: /eapi/v1/income/asyn
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.startTime  -  Timestamp in ms
   * @param {LONG} options.endTime  -  Timestamp in ms
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_getDownloadIdForOptionTransactionHistory(options : { startTime :LONG, endTime :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgCostTimestampOfLast30d: number,  // example: 7241837  // Average time taken for data download in the past 30 days
     downloadId: NumberString  // example: "546975389218332672"
    }>;
  
  
  eapi_getDownloadIdForOptionTransactionHistory(...args : any) {
      return this._sendRequest("/eapi/v1/income/asyn", "GET", "USER_DATA", true, args, ["startTime", "endTime", "recvWindow", "timestamp"], "eapi_getDownloadIdForOptionTransactionHistory");
  }
  
  
  /** Get Option Transaction History Download Link by Id (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#get-option-transaction-history-download-link-by-id-user_data}
   * 
   * EndPoint: /eapi/v1/income/asyn/id
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} downloadId  -  get by download id api
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_getOptionTransactionHistoryDownloadLinkById(downloadId :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_getOptionTransactionHistoryDownloadLinkById"]>;
  
  
  /** Get Option Transaction History Download Link by Id (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#get-option-transaction-history-download-link-by-id-user_data}
   * 
   * EndPoint: /eapi/v1/income/asyn/id
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.downloadId  -  get by download id api
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_getOptionTransactionHistoryDownloadLinkById(options : { downloadId :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     downloadId: NumberString,  // example: "545923594199212032"
     status: string,  // example: "completed"  // Enum:completed,processing
     url: string,  // example: "www.binance.com"  // The link is mapped to download id
     notified: boolean,  // example: true  // ignore
     expirationTimestamp: number,  // example: 1645009771000  // The link would expire after this timestamp
     isExpired: null  // example: null
    }>;
  
  
  eapi_getOptionTransactionHistoryDownloadLinkById(...args : any) {
      return this._sendRequest("/eapi/v1/income/asyn/id", "GET", "USER_DATA", true, args, ["downloadId", "recvWindow", "timestamp"], "eapi_getOptionTransactionHistoryDownloadLinkById");
  }
  
  
  
  //***** User Data Streams *****
  
  
  /** Start User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#start-user-data-stream-user_stream}
   * 
   * EndPoint: /eapi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  eapi_startUserDataStream() : Promise<{
     listenKey: string,  // example: "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
     expiration: number  // example: 1710140106000
    }> {
      return this._sendRequest("/eapi/v1/listenKey", "POST", "USER_STREAM", false, [], [], "eapi_startUserDataStream");
  }
  
  
  /** Keepalive User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#keepalive-user-data-stream-user_stream}
   * 
   * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 60 minutes.
   * 
   * EndPoint: /eapi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  eapi_keepaliveUserDataStream() : Promise<{
    }> {
      return this._sendRequest("/eapi/v1/listenKey", "PUT", "USER_STREAM", false, [], [], "eapi_keepaliveUserDataStream");
  }
  
  
  /** Close User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#close-user-data-stream-user_stream}
   * 
   * Close out a user data stream.
   * 
   * EndPoint: /eapi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  eapi_closeUserDataStream() : Promise<{
    }> {
      return this._sendRequest("/eapi/v1/listenKey", "DELETE", "USER_STREAM", false, [], [], "eapi_closeUserDataStream");
  }
  
  
  
  //***** Market Maker Endpoints *****
  
  
  /** Option Margin Account Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#option-margin-account-information-user_data}
   * 
   * Get current account information.
   * 
   * EndPoint: /eapi/v1/marginAccount
   * 
   * Weight(IP): 3
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_optionMarginAccountInformation(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_optionMarginAccountInformation"]>;
  
  
  /** Option Margin Account Information (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#option-margin-account-information-user_data}
   * 
   * Get current account information.
   * 
   * EndPoint: /eapi/v1/marginAccount
   * 
   * Weight(IP): 3
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_optionMarginAccountInformation(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     asset: {
         asset: string,  // example: "USDT"  // Asset type
         marginBalance: NumberString,  // example: "10099.448"  // Account balance
         equity: NumberString,  // example: "10094.44662"  // Account equity
         available: NumberString,  // example: "8725.92524"  // Available funds
         initialMargin: NumberString,  // example: "1084.52138"  // Initial margin
         maintMargin: NumberString,  // example: "151.00138"  // Maintenance margin
         unrealizedPNL: NumberString,  // example: "-5.00138"  // Unrealized profit/loss
         lpProfit: NumberString  // example: "-5.00138"  // Unrealized profit for long position
       }[],
     greek: {
         underlying: string,  // example: "BTCUSDT"  // Option Underlying
         delta: NumberString,  // example: "-0.05"  // Account delta
         gamma: NumberString,  // example: "-0.002"  // Account gamma
         theta: NumberString,  // example: "-0.05"  // Account theta
         vega: NumberString  // example: "-0.002"  // Account vega
       }[],
     riskLevel: string,  // example: "NORMAL"  // Account risk level
     time: number  // example: 1592449455993  // Time
    }>;
  
  
  eapi_optionMarginAccountInformation(...args : any) {
      return this._sendRequest("/eapi/v1/marginAccount", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "eapi_optionMarginAccountInformation");
  }
  
  
  /** Set Market Maker Protection Config (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#set-market-maker-protection-config-trade}
   * 
   * Set config for MMP.
   * Market Maker Protection(MMP) is a set of protection mechanism for option market maker, this mechanism is able to prevent mass trading in short period time. Once market maker's account branches the threshold, the Market Maker Protection will be triggered. When Market Maker Protection triggers, all the current MMP orders will be canceled, new MMP orders will be rejected. Market maker can use this time to reevaluate market and modify order price.
   * 
   * EndPoint: /eapi/v1/mmpSet
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} underlying  -  underlying, e.g BTCUSDT
   * @param {LONG} windowTimeInMilliseconds  -  MMP Interval in milliseconds; Range (0,5000]
   * @param {LONG} frozenTimeInMilliseconds  -  MMP frozen time in milliseconds, if set to 0 manual reset is required
   * @param {DECIMAL} qtyLimit  -  quantity limit
   * @param {DECIMAL} deltaLimit  -  net delta limit
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_setMarketMakerProtectionConfig(underlying :string, windowTimeInMilliseconds :LONG, frozenTimeInMilliseconds :LONG, qtyLimit :DECIMAL, deltaLimit :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_setMarketMakerProtectionConfig"]>;
  
  
  /** Set Market Maker Protection Config (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#set-market-maker-protection-config-trade}
   * 
   * Set config for MMP.
   * Market Maker Protection(MMP) is a set of protection mechanism for option market maker, this mechanism is able to prevent mass trading in short period time. Once market maker's account branches the threshold, the Market Maker Protection will be triggered. When Market Maker Protection triggers, all the current MMP orders will be canceled, new MMP orders will be rejected. Market maker can use this time to reevaluate market and modify order price.
   * 
   * EndPoint: /eapi/v1/mmpSet
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.underlying  -  underlying, e.g BTCUSDT
   * @param {LONG} options.windowTimeInMilliseconds  -  MMP Interval in milliseconds; Range (0,5000]
   * @param {LONG} options.frozenTimeInMilliseconds  -  MMP frozen time in milliseconds, if set to 0 manual reset is required
   * @param {DECIMAL} options.qtyLimit  -  quantity limit
   * @param {DECIMAL} options.deltaLimit  -  net delta limit
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_setMarketMakerProtectionConfig(options : { underlying :string, windowTimeInMilliseconds :LONG, frozenTimeInMilliseconds :LONG, qtyLimit :DECIMAL, deltaLimit :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     underlyingId: number,  // example: 2
     underlying: string,  // example: "BTCUSDT"
     windowTimeInMilliseconds: number,  // example: 3000
     frozenTimeInMilliseconds: number,  // example: 300000
     qtyLimit: NumberString,  // example: "2"
     deltaLimit: NumberString,  // example: "2.3"
     lastTriggerTime: number  // example: 0
    }>;
  
  
  eapi_setMarketMakerProtectionConfig(...args : any) {
      return this._sendRequest("/eapi/v1/mmpSet", "POST", "TRADE", true, args, ["underlying", "windowTimeInMilliseconds", "frozenTimeInMilliseconds", "qtyLimit", "deltaLimit", "recvWindow", "timestamp"], "eapi_setMarketMakerProtectionConfig");
  }
  
  
  /** Get Market Maker Protection Config (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#get-market-maker-protection-config-trade}
   * 
   * Get config for MMP.
   * 
   * EndPoint: /eapi/v1/mmp
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} underlying  -  underlying, e.g BTCUSDT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_getMarketMakerProtectionConfig(underlying :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_getMarketMakerProtectionConfig"]>;
  
  
  /** Get Market Maker Protection Config (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#get-market-maker-protection-config-trade}
   * 
   * Get config for MMP.
   * 
   * EndPoint: /eapi/v1/mmp
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.underlying  -  underlying, e.g BTCUSDT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_getMarketMakerProtectionConfig(options : { underlying :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     underlyingId: number,  // example: 2
     underlying: string,  // example: "BTCUSDT"
     windowTimeInMilliseconds: number,  // example: 3000
     frozenTimeInMilliseconds: number,  // example: 300000
     qtyLimit: NumberString,  // example: "2"
     deltaLimit: NumberString,  // example: "2.3"
     lastTriggerTime: number  // example: 0
    }>;
  
  
  eapi_getMarketMakerProtectionConfig(...args : any) {
      return this._sendRequest("/eapi/v1/mmp", "Get", "TRADE", true, args, ["underlying", "recvWindow", "timestamp"], "eapi_getMarketMakerProtectionConfig");
  }
  
  
  /** Reset Market Maker Protection Config (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#reset-market-maker-protection-config-trade}
   * 
   * Reset MMP, start MMP order again.
   * 
   * EndPoint: /eapi/v1/mmpReset
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} underlying  -  underlying, e.g BTCUSDT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_resetMarketMakerProtectionConfig(underlying :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_resetMarketMakerProtectionConfig"]>;
  
  
  /** Reset Market Maker Protection Config (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#reset-market-maker-protection-config-trade}
   * 
   * Reset MMP, start MMP order again.
   * 
   * EndPoint: /eapi/v1/mmpReset
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.underlying  -  underlying, e.g BTCUSDT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_resetMarketMakerProtectionConfig(options : { underlying :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     underlyingId: number,  // example: 2
     underlying: string,  // example: "BTCUSDT"
     windowTimeInMilliseconds: number,  // example: 3000
     frozenTimeInMilliseconds: number,  // example: 300000
     qtyLimit: NumberString,  // example: "2"
     deltaLimit: NumberString,  // example: "2.3"
     lastTriggerTime: number  // example: 0
    }>;
  
  
  eapi_resetMarketMakerProtectionConfig(...args : any) {
      return this._sendRequest("/eapi/v1/mmpReset", "POST", "TRADE", true, args, ["underlying", "recvWindow", "timestamp"], "eapi_resetMarketMakerProtectionConfig");
  }
  
  
  /** Set Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#set-auto-cancel-all-open-orders-kill-switch-config-trade}
   * 
   * This endpoint sets the parameters of the auto-cancel feature which cancels all open orders (both market maker protection and non market maker protection order types) of the underlying symbol at the end of the specified countdown time period if no heartbeat message is sent.  After the countdown time period, all open orders will be cancelled and new orders will be rejected with error code -2010 until either a heartbeat message is sent or the auto-cancel feature is turned off by setting countdownTime to 0.
   * 
   * EndPoint: /eapi/v1/countdownCancelAll
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} underlying  -  Option underlying, e.g BTCUSDT
   * @param {LONG} countdownTime  -  Countdown time in milliseconds (ex. 1,000 for 1 second). 0 to disable the timer. Negative values (ex. -10000) are not accepted. Minimum acceptable value is 5,000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_setAutoCancelAllOpenOrdersKillSwitchConfig(underlying :string, countdownTime :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_setAutoCancelAllOpenOrdersKillSwitchConfig"]>;
  
  
  /** Set Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#set-auto-cancel-all-open-orders-kill-switch-config-trade}
   * 
   * This endpoint sets the parameters of the auto-cancel feature which cancels all open orders (both market maker protection and non market maker protection order types) of the underlying symbol at the end of the specified countdown time period if no heartbeat message is sent.  After the countdown time period, all open orders will be cancelled and new orders will be rejected with error code -2010 until either a heartbeat message is sent or the auto-cancel feature is turned off by setting countdownTime to 0.
   * 
   * EndPoint: /eapi/v1/countdownCancelAll
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.underlying  -  Option underlying, e.g BTCUSDT
   * @param {LONG} options.countdownTime  -  Countdown time in milliseconds (ex. 1,000 for 1 second). 0 to disable the timer. Negative values (ex. -10000) are not accepted. Minimum acceptable value is 5,000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_setAutoCancelAllOpenOrdersKillSwitchConfig(options : { underlying :string, countdownTime :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     underlying: string,  // example: "ETHUSDT"
     countdownTime: number  // example: 30000
    }>;
  
  
  eapi_setAutoCancelAllOpenOrdersKillSwitchConfig(...args : any) {
      return this._sendRequest("/eapi/v1/countdownCancelAll", "POST", "TRADE", true, args, ["underlying", "countdownTime", "recvWindow", "timestamp"], "eapi_setAutoCancelAllOpenOrdersKillSwitchConfig");
  }
  
  
  /** Get Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#get-auto-cancel-all-open-orders-kill-switch-config-trade}
   * 
   * This endpoint returns the auto-cancel parameters for each underlying symbol. Note only active auto-cancel parameters will be returned, if countdownTime is set to 0 (ie. countdownTime has been turned off), the underlying symbol and corresponding countdownTime parameter will not be returned in the response.
   * 
   * EndPoint: /eapi/v1/countdownCancelAll
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} underlying  -  Option underlying, e.g BTCUSDT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_getAutoCancelAllOpenOrdersKillSwitchConfig(underlying? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_getAutoCancelAllOpenOrdersKillSwitchConfig"]>;
  
  
  /** Get Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#get-auto-cancel-all-open-orders-kill-switch-config-trade}
   * 
   * This endpoint returns the auto-cancel parameters for each underlying symbol. Note only active auto-cancel parameters will be returned, if countdownTime is set to 0 (ie. countdownTime has been turned off), the underlying symbol and corresponding countdownTime parameter will not be returned in the response.
   * 
   * EndPoint: /eapi/v1/countdownCancelAll
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.underlying  -  Option underlying, e.g BTCUSDT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_getAutoCancelAllOpenOrdersKillSwitchConfig(options? : { underlying? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     underlying: string,  // example: "ETHUSDT"
     countdownTime: number  // example: 100000
    }>;
  
  
  eapi_getAutoCancelAllOpenOrdersKillSwitchConfig(...args : any) {
      return this._sendRequest("/eapi/v1/countdownCancelAll", "GET", "TRADE", true, args, ["underlying", "recvWindow", "timestamp"], "eapi_getAutoCancelAllOpenOrdersKillSwitchConfig");
  }
  
  
  /** Auto-Cancel All Open Orders (Kill-Switch) Heartbeat (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#auto-cancel-all-open-orders-kill-switch-heartbeat-trade}
   * 
   * This endpoint resets the time from which the countdown will begin to the time this messaged is received.  It should be called repeatedly as heartbeats.  Multiple heartbeats can be updated at once by specifying the underlying symbols as a list (ex. BTCUSDT,ETHUSDT) in the underlyings parameter. 
   * 
   * EndPoint: /eapi/v1/countdownCancelAllHeartBeat
   * 
   * Weight(IP): 10
   * 
   * HMAC SHA256
   * 
   * @param {string} underlyings  -  Option Underlying Symbols, e.g BTCUSDT,ETHUSDT
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  eapi_autoCancelAllOpenOrdersKillSwitchHeartbeat(underlyings :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["eapi_autoCancelAllOpenOrdersKillSwitchHeartbeat"]>;
  
  
  /** Auto-Cancel All Open Orders (Kill-Switch) Heartbeat (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/voptions/en/#auto-cancel-all-open-orders-kill-switch-heartbeat-trade}
   * 
   * This endpoint resets the time from which the countdown will begin to the time this messaged is received.  It should be called repeatedly as heartbeats.  Multiple heartbeats can be updated at once by specifying the underlying symbols as a list (ex. BTCUSDT,ETHUSDT) in the underlyings parameter. 
   * 
   * EndPoint: /eapi/v1/countdownCancelAllHeartBeat
   * 
   * Weight(IP): 10
   * 
   * HMAC SHA256
   * 
   * @param {string} options.underlyings  -  Option Underlying Symbols, e.g BTCUSDT,ETHUSDT
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  eapi_autoCancelAllOpenOrdersKillSwitchHeartbeat(options : { underlyings :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     underlyings: string[]  // example: "BTCUSDT"
    }>;
  
  
  eapi_autoCancelAllOpenOrdersKillSwitchHeartbeat(...args : any) {
      return this._sendRequest("/eapi/v1/countdownCancelAllHeartBeat", "POST", "TRADE", true, args, ["underlyings", "recvWindow", "timestamp"], "eapi_autoCancelAllOpenOrdersKillSwitchHeartbeat");
  }
  
  
  
  //======== PORTFOLIO MARGIN ========
  
  
  //***** Market Data Endpoints *****
  
  
  /** Test Connectivity
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#test-connectivity}
   * 
   * Test connectivity to the Rest API.
   * 
   * EndPoint: /papi/v1/ping
   * 
   * Weight(IP): 1
   * 
   */
  papi_testConnectivity() : Promise<{
    }> {
      return this._sendRequest("/papi/v1/ping", "GET", "MARKET_DATA", false, [], [], "papi_testConnectivity");
  }
  
  
  
  //***** New Order *****
  
  
  /** New UM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#new-um-order-trade}
   * 
   * Additional mandatory parameters based on type:
   * 
   * EndPoint: /papi/v1/um/order
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {"LIMIT"|"MARKET"} type  -  LIMIT, MARKET
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity
   * @param {"true"|"false"} reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode .
   * @param {DECIMAL} price
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,32}$
   * @param {"ACK"|"RESULT"} newOrderRespType  -  ACK, RESULT, default ACK
   * @param {ENUM} selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire taker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers
   * @param {LONG} goodTillDate  -  order cancel time for timeInForce GTD, mandatory when timeInforce set to GTD; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_newUMOrder(symbol :string, side :OrderSide, positionSide :PositionSide|undefined, type :"LIMIT"|"MARKET", timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, newOrderRespType? :"ACK"|"RESULT", selfTradePreventionMode? :ENUM, goodTillDate? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_newUMOrder"]>;
  
  
  /** New UM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#new-um-order-trade}
   * 
   * Additional mandatory parameters based on type:
   * 
   * EndPoint: /papi/v1/um/order
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {"LIMIT"|"MARKET"} options.type  -  LIMIT, MARKET
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity
   * @param {"true"|"false"} options.reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode .
   * @param {DECIMAL} options.price
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,32}$
   * @param {"ACK"|"RESULT"} options.newOrderRespType  -  ACK, RESULT, default ACK
   * @param {ENUM} options.selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire taker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers
   * @param {LONG} options.goodTillDate  -  order cancel time for timeInForce GTD, mandatory when timeInforce set to GTD; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_newUMOrder(options : { symbol :string, side :OrderSide, positionSide? :PositionSide, type :"LIMIT"|"MARKET", timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, newOrderRespType? :"ACK"|"RESULT", selfTradePreventionMode? :ENUM, goodTillDate? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     clientOrderId: string,  // example: "testOrder"
     cumQty: NumberString,  // example: "0"
     cumQuote: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 22542179
     avgPrice: NumberString,  // example: "0.00000"
     origQty: NumberString,  // example: "10"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "NEW"
     symbol: string,  // example: "BTCUSDT"
     timeInForce: string,  // example: "GTD"
     type: OrderType,  // example: "MARKET"
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number,  // example: 1693207680000  //order pre-set auot cancel time for TIF GTD order
     updateTime: number  // example: 1566818724722
    }>;
  
  
  papi_newUMOrder(...args : any) {
      return this._sendRequest("/papi/v1/um/order", "POST", "TRADE", true, args, ["symbol", "side", "positionSide", "type", "timeInForce", "quantity", "reduceOnly", "price", "newClientOrderId", "newOrderRespType", "selfTradePreventionMode", "goodTillDate", "recvWindow", "timestamp"], "papi_newUMOrder");
  }
  
  
  /** New CM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#new-cm-order-trade}
   * 
   * EndPoint: /papi/v1/cm/order
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {"LIMIT"|"MARKET"} type  -  "LIMIT", "MARKET"
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity
   * @param {"true"|"false"} reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode.
   * @param {DECIMAL} price
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,32}$
   * @param {OrderResponseType} newOrderRespType  -  "ACK", "RESULT", default "ACK"
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_newCMOrder(symbol :string, side :OrderSide, positionSide :PositionSide|undefined, type :"LIMIT"|"MARKET", timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, newOrderRespType? :OrderResponseType, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_newCMOrder"]>;
  
  
  /** New CM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#new-cm-order-trade}
   * 
   * EndPoint: /papi/v1/cm/order
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {"LIMIT"|"MARKET"} options.type  -  "LIMIT", "MARKET"
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity
   * @param {"true"|"false"} options.reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode.
   * @param {DECIMAL} options.price
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,32}$
   * @param {OrderResponseType} options.newOrderRespType  -  "ACK", "RESULT", default "ACK"
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_newCMOrder(options : { symbol :string, side :OrderSide, positionSide? :PositionSide, type :"LIMIT"|"MARKET", timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, newClientOrderId? :string, newOrderRespType? :OrderResponseType, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     clientOrderId: string,  // example: "testOrder"
     cumQty: NumberString,  // example: "0"
     cumBase: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 22542179
     avgPrice: NumberString,  // example: "0.0"
     origQty: NumberString,  // example: "10"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "NEW"
     symbol: string,  // example: "BTCUSD_200925"
     pair: string,  // example: "BTCUSD"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "MARKET"
     updateTime: number  // example: 1566818724722
    }>;
  
  
  papi_newCMOrder(...args : any) {
      return this._sendRequest("/papi/v1/cm/order", "POST", "TRADE", true, args, ["symbol", "side", "positionSide", "type", "timeInForce", "quantity", "reduceOnly", "price", "newClientOrderId", "newOrderRespType", "recvWindow", "timestamp"], "papi_newCMOrder");
  }
  
  
  /** New Margin Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#new-margin-order-trade}
   * 
   * EndPoint: /papi/v1/margin/order
   * 
   * Weight(UID): 1
   * 
   * @param {string} symbol
   * @param {OrderSide} side  -  BUY ; SELL
   * @param {OrderType} type
   * @param {DECIMAL} quantity
   * @param {DECIMAL} quoteOrderQty
   * @param {DECIMAL} price
   * @param {DECIMAL} stopPrice  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {string} newClientOrderId  -  A unique id among open orders. Automatically generated if not sent.
   * @param {OrderResponseType} newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {DECIMAL} icebergQty  -  Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order
   * @param {"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY"} sideEffectType  -  NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT.
   * @param {"GTC"|"IOC"|"FOK"} timeInForce  -  GTC,IOC,FOK
   * @param {ENUM} selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire taker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers
   * @param {boolean} autoRepayAtCancel  -  只有在自动借款单或者自动借还单生效，true表示的是撤单后需要把订单产生的借款归还，默认为true
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_newMarginOrder(symbol :string, side :OrderSide, type :OrderType, quantity? :DECIMAL, quoteOrderQty? :DECIMAL, price? :DECIMAL, stopPrice? :DECIMAL, newClientOrderId? :string, newOrderRespType? :OrderResponseType, icebergQty? :DECIMAL, sideEffectType? :"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY", timeInForce? :"GTC"|"IOC"|"FOK", selfTradePreventionMode? :ENUM, autoRepayAtCancel? :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_newMarginOrder"]>;
  
  
  /** New Margin Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#new-margin-order-trade}
   * 
   * EndPoint: /papi/v1/margin/order
   * 
   * Weight(UID): 1
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side  -  BUY ; SELL
   * @param {OrderType} options.type
   * @param {DECIMAL} options.quantity
   * @param {DECIMAL} options.quoteOrderQty
   * @param {DECIMAL} options.price
   * @param {DECIMAL} options.stopPrice  -  Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
   * @param {string} options.newClientOrderId  -  A unique id among open orders. Automatically generated if not sent.
   * @param {OrderResponseType} options.newOrderRespType  -  Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
   * @param {DECIMAL} options.icebergQty  -  Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order
   * @param {"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY"} options.sideEffectType  -  NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT.
   * @param {"GTC"|"IOC"|"FOK"} options.timeInForce  -  GTC,IOC,FOK
   * @param {ENUM} options.selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire taker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers
   * @param {boolean} options.autoRepayAtCancel  -  只有在自动借款单或者自动借还单生效，true表示的是撤单后需要把订单产生的借款归还，默认为true
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_newMarginOrder(options : { symbol :string, side :OrderSide, type :OrderType, quantity? :DECIMAL, quoteOrderQty? :DECIMAL, price? :DECIMAL, stopPrice? :DECIMAL, newClientOrderId? :string, newOrderRespType? :OrderResponseType, icebergQty? :DECIMAL, sideEffectType? :"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY", timeInForce? :"GTC"|"IOC"|"FOK", selfTradePreventionMode? :ENUM, autoRepayAtCancel? :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     orderId: number,  // example: 28
     clientOrderId: string,  // example: "6gCrw2kRUAF9CvJDGP16IP"
     transactTime: number,  // example: 1507725176595
     price: NumberString,  // example: "1.00000000"
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     origQty: NumberString,  // example: "10.00000000"
     executedQty: NumberString,  // example: "10.00000000"
     cummulativeQuoteQty: NumberString,  // example: "10.00000000"
     status: string,  // example: "FILLED"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "MARKET"
     side: OrderSide,  // example: "SELL"
     marginBuyBorrowAmount: number,  // example: 5  // will not return if no margin trade happens
     marginBuyBorrowAsset: string,  // example: "BTC"  // will not return if no margin trade happens
     fills: {
         price: NumberString,  // example: "4000.00000000"
         qty: NumberString,  // example: "1.00000000"
         commission: NumberString,  // example: "4.00000000"
         commissionAsset: string  // example: "USDT"
       }[]
    }>;
  
  
  papi_newMarginOrder(...args : any) {
      return this._sendRequest("/papi/v1/margin/order", "POST", "TRADE", false, args, ["symbol", "side", "type", "quantity", "quoteOrderQty", "price", "stopPrice", "newClientOrderId", "newOrderRespType", "icebergQty", "sideEffectType", "timeInForce", "selfTradePreventionMode", "autoRepayAtCancel", "recvWindow", "timestamp"], "papi_newMarginOrder");
  }
  
  
  /** Margin Account Borrow (MARGIN)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#margin-account-borrow-margin}
   * 
   * Apply for a margin loan.
   * 
   * EndPoint: /papi/v1/marginLoan
   * 
   * Weight(IP): 100
   * 
   * @param {string} asset
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_marginAccountBorrow(asset :string, amount :DECIMAL, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["papi_marginAccountBorrow"]>;
  
  
  /** Margin Account Borrow (MARGIN)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#margin-account-borrow-margin}
   * 
   * Apply for a margin loan.
   * 
   * EndPoint: /papi/v1/marginLoan
   * 
   * Weight(IP): 100
   * 
   * @param {string} options.asset
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_marginAccountBorrow(options : { asset :string, amount :DECIMAL, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     tranId: number  // example: 100000001
    }>;
  
  
  papi_marginAccountBorrow(...args : any) {
      return this._sendRequest("/papi/v1/marginLoan", "POST", "MARGIN", false, args, ["asset", "amount", "recvWindow", "timestamp"], "papi_marginAccountBorrow");
  }
  
  
  /** Margin Account Repay (MARGIN)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#margin-account-repay-margin}
   * 
   * Repay for a margin loan.
   * 
   * EndPoint: /papi/v1/repayLoan
   * 
   * Weight(IP): 100
   * 
   * @param {string} asset
   * @param {DECIMAL} amount
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_marginAccountRepay(asset :string, amount :DECIMAL, recvWindow :LONG|undefined, timestamp :LONG)
  : ReturnType<MyBinanceClient["papi_marginAccountRepay"]>;
  
  
  /** Margin Account Repay (MARGIN)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#margin-account-repay-margin}
   * 
   * Repay for a margin loan.
   * 
   * EndPoint: /papi/v1/repayLoan
   * 
   * Weight(IP): 100
   * 
   * @param {string} options.asset
   * @param {DECIMAL} options.amount
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_marginAccountRepay(options : { asset :string, amount :DECIMAL, recvWindow? :LONG, timestamp :LONG })
  : Promise<{
     tranId: number  // example: 100000001
    }>;
  
  
  papi_marginAccountRepay(...args : any) {
      return this._sendRequest("/papi/v1/repayLoan", "POST", "MARGIN", false, args, ["asset", "amount", "recvWindow", "timestamp"], "papi_marginAccountRepay");
  }
  
  
  /** Margin Account New OCO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#margin-account-new-oco-trade}
   * 
   * Send in a new OCO for a margin account
   * 
   * EndPoint: /papi/v1/margin/order/oco
   * 
   * Weight(UID): 1
   * 
   * @param {string} symbol
   * @param {string} listClientOrderId  -  A unique Id for the entire orderList
   * @param {OrderSide} side
   * @param {DECIMAL} quantity
   * @param {string} limitClientOrderId  -  A unique Id for the limit order
   * @param {DECIMAL} price
   * @param {DECIMAL} limitIcebergQty
   * @param {string} stopClientOrderId  -  A unique Id for the stop loss/stop loss limit leg
   * @param {DECIMAL} stopPrice
   * @param {DECIMAL} stopLimitPrice  -  If provided, stopLimitTimeInForce is required.
   * @param {DECIMAL} stopIcebergQty
   * @param {ENUM} stopLimitTimeInForce  -  Valid values are GTC/FOK/IOC
   * @param {OrderResponseType} newOrderRespType  -  Set the response JSON.
   * @param {"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY"} sideEffectType  -  NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT.
   * @param {ENUM} selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire taker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers
   * @param {boolean} autoRepayAtCancel  -  只有在自动借款单或者自动借还单生效，true表示的是撤单后需要把订单产生的借款归还，默认为true
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_marginAccountNewOCO(symbol :string, listClientOrderId :string|undefined, side :OrderSide, quantity :DECIMAL, limitClientOrderId :string|undefined, price :DECIMAL, limitIcebergQty :DECIMAL|undefined, stopClientOrderId :string|undefined, stopPrice :DECIMAL, stopLimitPrice? :DECIMAL, stopIcebergQty? :DECIMAL, stopLimitTimeInForce? :ENUM, newOrderRespType? :OrderResponseType, sideEffectType? :"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY", selfTradePreventionMode? :ENUM, autoRepayAtCancel? :boolean, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_marginAccountNewOCO"]>;
  
  
  /** Margin Account New OCO (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#margin-account-new-oco-trade}
   * 
   * Send in a new OCO for a margin account
   * 
   * EndPoint: /papi/v1/margin/order/oco
   * 
   * Weight(UID): 1
   * 
   * @param {string} options.symbol
   * @param {string} options.listClientOrderId  -  A unique Id for the entire orderList
   * @param {OrderSide} options.side
   * @param {DECIMAL} options.quantity
   * @param {string} options.limitClientOrderId  -  A unique Id for the limit order
   * @param {DECIMAL} options.price
   * @param {DECIMAL} options.limitIcebergQty
   * @param {string} options.stopClientOrderId  -  A unique Id for the stop loss/stop loss limit leg
   * @param {DECIMAL} options.stopPrice
   * @param {DECIMAL} options.stopLimitPrice  -  If provided, stopLimitTimeInForce is required.
   * @param {DECIMAL} options.stopIcebergQty
   * @param {ENUM} options.stopLimitTimeInForce  -  Valid values are GTC/FOK/IOC
   * @param {OrderResponseType} options.newOrderRespType  -  Set the response JSON.
   * @param {"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY"} options.sideEffectType  -  NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT.
   * @param {ENUM} options.selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire taker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers
   * @param {boolean} options.autoRepayAtCancel  -  只有在自动借款单或者自动借还单生效，true表示的是撤单后需要把订单产生的借款归还，默认为true
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_marginAccountNewOCO(options : { symbol :string, listClientOrderId? :string, side :OrderSide, quantity :DECIMAL, limitClientOrderId? :string, price :DECIMAL, limitIcebergQty? :DECIMAL, stopClientOrderId? :string, stopPrice :DECIMAL, stopLimitPrice? :DECIMAL, stopIcebergQty? :DECIMAL, stopLimitTimeInForce? :ENUM, newOrderRespType? :OrderResponseType, sideEffectType? :"NO_SIDE_EFFECT"|"MARGIN_BUY"|"AUTO_REPAY"|"AUTO_BORROW_REPAY", selfTradePreventionMode? :ENUM, autoRepayAtCancel? :boolean, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 0
     contingencyType: string,  // example: "OCO"
     listStatusType: OCOStatus,  // example: "EXEC_STARTED"
     listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
     listClientOrderId: string,  // example: "JYVpp3F0f5CAG15DhtrqLp"
     transactionTime: number,  // example: 1563417480525
     symbol: string,  // example: "LTCBTC"
     marginBuyBorrowAmount: NumberString,  // example: "5"  // will not return if no margin trade happens
     marginBuyBorrowAsset: string,  // example: "BTC"  // will not return if no margin trade happens
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 2
         clientOrderId: string  // example: "Kk7sqHb9J6mJWTMDVW7Vos"
       }[],
     orderReports: (
       {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 2
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "Kk7sqHb9J6mJWTMDVW7Vos"
         transactTime: number,  // example: 1563417480525
         price: NumberString,  // example: "0.000000"
         origQty: NumberString,  // example: "0.624363"
         executedQty: NumberString,  // example: "0.000000"
         cummulativeQuoteQty: NumberString,  // example: "0.000000"
         status: string,  // example: "NEW"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "STOP_LOSS"
         side: OrderSide,  // example: "BUY"
         stopPrice: NumberString,  // example: "0.960664"
         selfTradePreventionMode: string  // example: "EXPIRE_BOTH"
       } |
       {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 3
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "xTXKaGYd4bluPVp78IVRvl"
         transactTime: number,  // example: 1563417480525
         price: NumberString,  // example: "0.036435"
         origQty: NumberString,  // example: "0.624363"
         executedQty: NumberString,  // example: "0.000000"
         cummulativeQuoteQty: NumberString,  // example: "0.000000"
         status: string,  // example: "NEW"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "LIMIT_MAKER"
         side: OrderSide,  // example: "BUY"
         selfTradePreventionMode: string  // example: "EXPIRE_BOTH"
       }
     )[]
    }>;
  
  
  papi_marginAccountNewOCO(...args : any) {
      return this._sendRequest("/papi/v1/margin/order/oco", "POST", "TRADE", false, args, ["symbol", "listClientOrderId", "side", "quantity", "limitClientOrderId", "price", "limitIcebergQty", "stopClientOrderId", "stopPrice", "stopLimitPrice", "stopIcebergQty", "stopLimitTimeInForce", "newOrderRespType", "sideEffectType", "selfTradePreventionMode", "autoRepayAtCancel", "recvWindow", "timestamp"], "papi_marginAccountNewOCO");
  }
  
  
  /** New UM Conditional Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#new-um-conditional-order-trade}
   * 
   * Additional mandatory parameters based on type:
   * 
   * EndPoint: /papi/v1/um/conditional/order
   * 
   * Weight(UID): 1
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {ENUM} strategyType  -  "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", and "TRAILING_STOP_MARKET"
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity
   * @param {"true"|"false"} reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode ; cannot be sent with closePosition=true
   * @param {DECIMAL} price
   * @param {WorkingType} workingType  -  stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
   * @param {"TRUE"|"FALSE"} priceProtect  -  "TRUE" or "FALSE", default "FALSE". Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders
   * @param {string} newClientStrategyId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,32}$
   * @param {DECIMAL} stopPrice  -  Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {DECIMAL} activationPrice  -  Used with TRAILING_STOP_MARKET orders, default as the mark price
   * @param {DECIMAL} callbackRate  -  Used with TRAILING_STOP_MARKET orders, min 0.1, max 5 where 1 for 1%
   * @param {ENUM} selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire taker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers
   * @param {LONG} goodTillDate  -  order cancel time for timeInForce GTD, mandatory when timeInforce set to GTD; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_newUMConditionalOrder(symbol :string, side :OrderSide, positionSide :PositionSide|undefined, strategyType :ENUM, timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newClientStrategyId? :string, stopPrice? :DECIMAL, activationPrice? :DECIMAL, callbackRate? :DECIMAL, selfTradePreventionMode? :ENUM, goodTillDate? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_newUMConditionalOrder"]>;
  
  
  /** New UM Conditional Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#new-um-conditional-order-trade}
   * 
   * Additional mandatory parameters based on type:
   * 
   * EndPoint: /papi/v1/um/conditional/order
   * 
   * Weight(UID): 1
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {ENUM} options.strategyType  -  "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", and "TRAILING_STOP_MARKET"
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity
   * @param {"true"|"false"} options.reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode ; cannot be sent with closePosition=true
   * @param {DECIMAL} options.price
   * @param {WorkingType} options.workingType  -  stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
   * @param {"TRUE"|"FALSE"} options.priceProtect  -  "TRUE" or "FALSE", default "FALSE". Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders
   * @param {string} options.newClientStrategyId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,32}$
   * @param {DECIMAL} options.stopPrice  -  Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {DECIMAL} options.activationPrice  -  Used with TRAILING_STOP_MARKET orders, default as the mark price
   * @param {DECIMAL} options.callbackRate  -  Used with TRAILING_STOP_MARKET orders, min 0.1, max 5 where 1 for 1%
   * @param {ENUM} options.selfTradePreventionMode  -  NONE:No STP / EXPIRE_TAKER:expire taker order when STP triggers/ EXPIRE_MAKER:expire taker order when STP triggers/ EXPIRE_BOTH:expire both orders when STP triggers
   * @param {LONG} options.goodTillDate  -  order cancel time for timeInForce GTD, mandatory when timeInforce set to GTD; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_newUMConditionalOrder(options : { symbol :string, side :OrderSide, positionSide? :PositionSide, strategyType :ENUM, timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newClientStrategyId? :string, stopPrice? :DECIMAL, activationPrice? :DECIMAL, callbackRate? :DECIMAL, selfTradePreventionMode? :ENUM, goodTillDate? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     newClientStrategyId: string,  // example: "testOrder"
     strategyId: number,  // example: 123445
     strategyStatus: string,  // example: "NEW"
     strategyType: string,  // example: "TRAILING_STOP_MARKET"
     origQty: NumberString,  // example: "10"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     symbol: string,  // example: "BTCUSDT"
     timeInForce: string,  // example: "GTD"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     bookTime: number,  // example: 1566818724710  // order place time
     updateTime: number,  // example: 1566818724722
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean,  // example: false
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 1693207680000  //order pre-set auot cancel time for TIF GTD order
    }>;
  
  
  papi_newUMConditionalOrder(...args : any) {
      return this._sendRequest("/papi/v1/um/conditional/order", "POST", "TRADE", false, args, ["symbol", "side", "positionSide", "strategyType", "timeInForce", "quantity", "reduceOnly", "price", "workingType", "priceProtect", "newClientStrategyId", "stopPrice", "activationPrice", "callbackRate", "selfTradePreventionMode", "goodTillDate", "recvWindow", "timestamp"], "papi_newUMConditionalOrder");
  }
  
  
  /** New CM Conditional Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#new-cm-conditional-order-trade}
   * 
   * Additional mandatory parameters based on type:
   * 
   * EndPoint: /papi/v1/cm/conditional/order
   * 
   * Weight(UID): 1
   * 
   * @param {string} symbol
   * @param {OrderSide} side
   * @param {PositionSide} positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {ENUM} strategyType  -  "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", and "TRAILING_STOP_MARKET"
   * @param {TimeInForce} timeInForce
   * @param {DECIMAL} quantity
   * @param {"true"|"false"} reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode
   * @param {DECIMAL} price
   * @param {WorkingType} workingType  -  stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
   * @param {"TRUE"|"FALSE"} priceProtect  -  "TRUE" or "FALSE", default "FALSE". Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders
   * @param {string} newClientStrategyId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,36}$
   * @param {DECIMAL} stopPrice  -  Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {DECIMAL} activationPrice  -  Used with TRAILING_STOP_MARKET orders, default as the mark price
   * @param {DECIMAL} callbackRate  -  Used with TRAILING_STOP_MARKET orders, min 0.1, max 5 where 1 for 1%
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_newCMConditionalOrder(symbol :string, side :OrderSide, positionSide :PositionSide|undefined, strategyType :ENUM, timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newClientStrategyId? :string, stopPrice? :DECIMAL, activationPrice? :DECIMAL, callbackRate? :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_newCMConditionalOrder"]>;
  
  
  /** New CM Conditional Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#new-cm-conditional-order-trade}
   * 
   * Additional mandatory parameters based on type:
   * 
   * EndPoint: /papi/v1/cm/conditional/order
   * 
   * Weight(UID): 1
   * 
   * @param {string} options.symbol
   * @param {OrderSide} options.side
   * @param {PositionSide} options.positionSide  -  Default BOTH for One-way Mode ; LONG or SHORT for Hedge Mode. It must be sent in Hedge Mode.
   * @param {ENUM} options.strategyType  -  "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", and "TRAILING_STOP_MARKET"
   * @param {TimeInForce} options.timeInForce
   * @param {DECIMAL} options.quantity
   * @param {"true"|"false"} options.reduceOnly  -  "true" or "false". default "false". Cannot be sent in Hedge Mode
   * @param {DECIMAL} options.price
   * @param {WorkingType} options.workingType  -  stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
   * @param {"TRUE"|"FALSE"} options.priceProtect  -  "TRUE" or "FALSE", default "FALSE". Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders
   * @param {string} options.newClientStrategyId  -  A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: ^[\.A-Z\:/a-z0-9_-]{1,36}$
   * @param {DECIMAL} options.stopPrice  -  Used with STOP/STOP_MARKET or TAKE_PROFIT/TAKE_PROFIT_MARKET orders.
   * @param {DECIMAL} options.activationPrice  -  Used with TRAILING_STOP_MARKET orders, default as the mark price
   * @param {DECIMAL} options.callbackRate  -  Used with TRAILING_STOP_MARKET orders, min 0.1, max 5 where 1 for 1%
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_newCMConditionalOrder(options : { symbol :string, side :OrderSide, positionSide? :PositionSide, strategyType :ENUM, timeInForce? :TimeInForce, quantity? :DECIMAL, reduceOnly? :"true"|"false", price? :DECIMAL, workingType? :WorkingType, priceProtect? :"TRUE"|"FALSE", newClientStrategyId? :string, stopPrice? :DECIMAL, activationPrice? :DECIMAL, callbackRate? :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     newClientStrategyId: string,  // example: "testOrder"
     strategyId: number,  // example: 123445
     strategyStatus: string,  // example: "NEW"
     strategyType: string,  // example: "TRAILING_STOP_MARKET"
     origQty: NumberString,  // example: "10"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     symbol: string,  // example: "BTCUSD_200925"
     pair: string,  // example: "BTCUSD"
     timeInForce: TimeInForce,  // example: "GTC"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     bookTime: number,  // example: 1566818724710  // order place time
     updateTime: number,  // example: 1566818724722
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean  // example: false
    }>;
  
  
  papi_newCMConditionalOrder(...args : any) {
      return this._sendRequest("/papi/v1/cm/conditional/order", "POST", "TRADE", false, args, ["symbol", "side", "positionSide", "strategyType", "timeInForce", "quantity", "reduceOnly", "price", "workingType", "priceProtect", "newClientStrategyId", "stopPrice", "activationPrice", "callbackRate", "recvWindow", "timestamp"], "papi_newCMConditionalOrder");
  }
  
  
  /** Modify UM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#modify-um-order-trade}
   * 
   * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
   * 
   * EndPoint: /papi/v1/um/order
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {string} symbol
   * @param {"SELL"|"BUY"} side  -  SELL, BUY
   * @param {DECIMAL} quantity  -  Order quantity
   * @param {DECIMAL} price
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_modifyUMOrder(orderId :LONG|undefined, origClientOrderId :string|undefined, symbol :string, side :"SELL"|"BUY", quantity :DECIMAL, price :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_modifyUMOrder"]>;
  
  
  /** Modify UM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#modify-um-order-trade}
   * 
   * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
   * 
   * EndPoint: /papi/v1/um/order
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {string} options.symbol
   * @param {"SELL"|"BUY"} options.side  -  SELL, BUY
   * @param {DECIMAL} options.quantity  -  Order quantity
   * @param {DECIMAL} options.price
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_modifyUMOrder(options : { orderId? :LONG, origClientOrderId? :string, symbol :string, side :"SELL"|"BUY", quantity :DECIMAL, price :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderId: number,  // example: 20072994037
     symbol: string,  // example: "BTCUSDT"
     status: string,  // example: "NEW"
     clientOrderId: string,  // example: "LJ9R4QZDihCaS8UAOOLpgW"
     price: NumberString,  // example: "30005"
     avgPrice: NumberString,  // example: "0.0"
     origQty: NumberString,  // example: "1"
     executedQty: NumberString,  // example: "0"
     cumQty: NumberString,  // example: "0"
     cumQuote: NumberString,  // example: "0"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "LONG"
     origType: string,  // example: "LIMIT"
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number,  // example: 0  //order pre-set auot cancel time for TIF GTD order
     updateTime: number  // example: 1629182711600
    }>;
  
  
  papi_modifyUMOrder(...args : any) {
      return this._sendRequest("/papi/v1/um/order", "PUT", "TRADE", true, args, ["orderId", "origClientOrderId", "symbol", "side", "quantity", "price", "recvWindow", "timestamp"], "papi_modifyUMOrder");
  }
  
  
  /** Modify CM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#modify-cm-order-trade}
   * 
   * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
   * 
   * EndPoint: /papi/v1/cm/order
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {string} symbol
   * @param {"SELL"|"BUY"} side  -  SELL, BUY
   * @param {DECIMAL} quantity  -  Order quantity
   * @param {DECIMAL} price
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_modifyCMOrder(orderId :LONG|undefined, origClientOrderId :string|undefined, symbol :string, side :"SELL"|"BUY", quantity :DECIMAL, price :DECIMAL, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_modifyCMOrder"]>;
  
  
  /** Modify CM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#modify-cm-order-trade}
   * 
   * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
   * 
   * EndPoint: /papi/v1/cm/order
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {string} options.symbol
   * @param {"SELL"|"BUY"} options.side  -  SELL, BUY
   * @param {DECIMAL} options.quantity  -  Order quantity
   * @param {DECIMAL} options.price
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_modifyCMOrder(options : { orderId? :LONG, origClientOrderId? :string, symbol :string, side :"SELL"|"BUY", quantity :DECIMAL, price :DECIMAL, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderId: number,  // example: 20072994037
     symbol: string,  // example: "BTCUSD_PERP"
     pair: string,  // example: "BTCUSD"
     status: string,  // example: "NEW"
     clientOrderId: string,  // example: "LJ9R4QZDihCaS8UAOOLpgW"
     price: NumberString,  // example: "30005"
     avgPrice: NumberString,  // example: "0.0"
     origQty: NumberString,  // example: "1"
     executedQty: NumberString,  // example: "0"
     cumQty: NumberString,  // example: "0"
     cumBase: NumberString,  // example: "0"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "LONG"
     origType: string,  // example: "LIMIT"
     updateTime: number  // example: 1629182711600
    }>;
  
  
  papi_modifyCMOrder(...args : any) {
      return this._sendRequest("/papi/v1/cm/order", "PUT", "TRADE", true, args, ["orderId", "origClientOrderId", "symbol", "side", "quantity", "price", "recvWindow", "timestamp"], "papi_modifyCMOrder");
  }
  
  
  
  //***** Cancel Order *****
  
  
  /** Cancel UM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-um-order-trade}
   * 
   * Cancel an active UM LIMIT order
   * 
   * EndPoint: /papi/v1/um/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cancelUMOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelUMOrder"]>;
  
  
  /** Cancel UM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-um-order-trade}
   * 
   * Cancel an active UM LIMIT order
   * 
   * EndPoint: /papi/v1/um/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cancelUMOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.00000"
     clientOrderId: string,  // example: "myOrder1"
     cumQty: NumberString,  // example: "0"
     cumQuote: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 4611875134427365000
     origQty: NumberString,  // example: "0.40"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "CANCELED"
     symbol: string,  // example: "BTCUSDT"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     updateTime: number,  // example: 1571110484038
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 0
    }>;
  
  
  papi_cancelUMOrder(...args : any) {
      return this._sendRequest("/papi/v1/um/order", "DELETE", "TRADE", true, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "papi_cancelUMOrder");
  }
  
  
  /** Cancel All UM Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-all-um-open-orders-trade}
   * 
   * Cancel all active LIMIT orders on specific symbol
   * 
   * EndPoint: /papi/v1/um/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cancelAllUMOpenOrders(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelAllUMOpenOrders"]>;
  
  
  /** Cancel All UM Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-all-um-open-orders-trade}
   * 
   * Cancel all active LIMIT orders on specific symbol
   * 
   * EndPoint: /papi/v1/um/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cancelAllUMOpenOrders(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "The operation of cancel all open order is done."
    }>;
  
  
  papi_cancelAllUMOpenOrders(...args : any) {
      return this._sendRequest("/papi/v1/um/allOpenOrders", "DELETE", "TRADE", true, args, ["symbol", "recvWindow", "timestamp"], "papi_cancelAllUMOpenOrders");
  }
  
  
  /** Cancel CM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-cm-order-trade}
   * 
   * Cancel an active LIMIT order
   * 
   * EndPoint: /papi/v1/cm/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cancelCMOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelCMOrder"]>;
  
  
  /** Cancel CM Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-cm-order-trade}
   * 
   * Cancel an active LIMIT order
   * 
   * EndPoint: /papi/v1/cm/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cancelCMOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.0"
     clientOrderId: string,  // example: "myOrder1"
     cumQty: NumberString,  // example: "0"
     cumBase: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 283194212
     origQty: NumberString,  // example: "2"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "CANCELED"
     symbol: string,  // example: "BTCUSD_200925"
     pair: string,  // example: "BTCUSD"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     updateTime: number  // example: 1571110484038
    }>;
  
  
  papi_cancelCMOrder(...args : any) {
      return this._sendRequest("/papi/v1/cm/order", "DELETE", "TRADE", true, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "papi_cancelCMOrder");
  }
  
  
  /** Cancel All CM Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-all-cm-open-orders-trade}
   * 
   * Cancel all active LIMIT orders on specific symbol
   * 
   * EndPoint: /papi/v1/cm/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cancelAllCMOpenOrders(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelAllCMOpenOrders"]>;
  
  
  /** Cancel All CM Open Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-all-cm-open-orders-trade}
   * 
   * Cancel all active LIMIT orders on specific symbol
   * 
   * EndPoint: /papi/v1/cm/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cancelAllCMOpenOrders(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "The operation of cancel all open order is done."
    }>;
  
  
  papi_cancelAllCMOpenOrders(...args : any) {
      return this._sendRequest("/papi/v1/cm/allOpenOrders", "DELETE", "TRADE", true, args, ["symbol", "recvWindow", "timestamp"], "papi_cancelAllCMOpenOrders");
  }
  
  
  /** Cancel Margin Account Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-margin-account-order-trade}
   * 
   * Cancel Margin Account Order
   * 
   * EndPoint: /papi/v1/margin/order
   * 
   * Weight(IP): 2
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {string} newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_cancelMarginAccountOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, newClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelMarginAccountOrder"]>;
  
  
  /** Cancel Margin Account Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-margin-account-order-trade}
   * 
   * Cancel Margin Account Order
   * 
   * EndPoint: /papi/v1/margin/order
   * 
   * Weight(IP): 2
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {string} options.newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_cancelMarginAccountOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, newClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "LTCBTC"
     orderId: number,  // example: 28
     origClientOrderId: string,  // example: "myOrder1"
     clientOrderId: string,  // example: "cancelMyOrder1"
     price: NumberString,  // example: "1.00000000"
     origQty: NumberString,  // example: "10.00000000"
     executedQty: NumberString,  // example: "8.00000000"
     cummulativeQuoteQty: NumberString,  // example: "8.00000000"
     status: string,  // example: "CANCELED"
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     side: OrderSide,  // example: "SELL"
     selfTradePreventionMode: string  // example: "EXPIRE_TAKER"
    }>;
  
  
  papi_cancelMarginAccountOrder(...args : any) {
      return this._sendRequest("/papi/v1/margin/order", "DELETE", "TRADE", true, args, ["symbol", "orderId", "origClientOrderId", "newClientOrderId", "recvWindow", "timestamp"], "papi_cancelMarginAccountOrder");
  }
  
  
  /** Cancel Margin Account All Open Orders on a Symbol (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-margin-account-all-open-orders-on-a-symbol-trade}
   * 
   * EndPoint: /papi/v1/margin/allOpenOrders
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_cancelMarginAccountAllOpenOrdersOnASymbol(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelMarginAccountAllOpenOrdersOnASymbol"]>;
  
  
  /** Cancel Margin Account All Open Orders on a Symbol (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-margin-account-all-open-orders-on-a-symbol-trade}
   * 
   * EndPoint: /papi/v1/margin/allOpenOrders
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_cancelMarginAccountAllOpenOrdersOnASymbol(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: "BTCUSDT"
       origClientOrderId: string,  // example: "E6APeyTJvkMvLMYMqu1KQ4"
       orderId: number,  // example: 11
       orderListId: number,  // example: -1
       clientOrderId: string,  // example: "pXLV6Hz6mprAcVYpVMTGgx"
       price: NumberString,  // example: "0.089853"
       origQty: NumberString,  // example: "0.178622"
       executedQty: NumberString,  // example: "0.000000"
       cummulativeQuoteQty: NumberString,  // example: "0.000000"
       status: string,  // example: "CANCELED"
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       side: OrderSide  // example: "BUY"
     } |
     {
       orderListId: number,  // example: 1929
       contingencyType: string,  // example: "OCO"
       listStatusType: OCOStatus,  // example: "ALL_DONE"
       listOrderStatus: OCOOrderStatus,  // example: "ALL_DONE"
       listClientOrderId: string,  // example: "2inzWQdDvZLHbbAmAozX2N"
       transactionTime: number,  // example: 1585230948299
       symbol: string,  // example: "BTCUSDT"
       orders: {
           symbol: string,  // example: "BTCUSDT"
           orderId: number,  // example: 20
           clientOrderId: string  // example: "CwOOIPHSmYywx6jZX77TdL"
         }[],
       orderReports: (
         {
           symbol: string,  // example: "BTCUSDT"
           origClientOrderId: string,  // example: "CwOOIPHSmYywx6jZX77TdL"
           orderId: number,  // example: 20
           orderListId: number,  // example: 1929
           clientOrderId: string,  // example: "pXLV6Hz6mprAcVYpVMTGgx"
           price: NumberString,  // example: "0.668611"
           origQty: NumberString,  // example: "0.690354"
           executedQty: NumberString,  // example: "0.000000"
           cummulativeQuoteQty: NumberString,  // example: "0.000000"
           status: string,  // example: "CANCELED"
           timeInForce: TimeInForce,  // example: "GTC"
           type: OrderType,  // example: "STOP_LOSS_LIMIT"
           side: OrderSide,  // example: "BUY"
           stopPrice: NumberString,  // example: "0.378131"
           icebergQty: NumberString,  // example: "0.017083"
           selfTradePreventionMode: string  // example: "EXPIRE_TAKER"
         } |
         {
           symbol: string,  // example: "BTCUSDT"
           origClientOrderId: string,  // example: "461cPg51vQjV3zIMOXNz39"
           orderId: number,  // example: 21
           orderListId: number,  // example: 1929
           clientOrderId: string,  // example: "pXLV6Hz6mprAcVYpVMTGgx"
           price: NumberString,  // example: "0.008791"
           origQty: NumberString,  // example: "0.690354"
           executedQty: NumberString,  // example: "0.000000"
           cummulativeQuoteQty: NumberString,  // example: "0.000000"
           status: string,  // example: "CANCELED"
           timeInForce: TimeInForce,  // example: "GTC"
           type: OrderType,  // example: "LIMIT_MAKER"
           side: OrderSide,  // example: "BUY"
           icebergQty: NumberString,  // example: "0.639962"
           selfTradePreventionMode: string  // example: "EXPIRE_TAKER"
         }
       )[]
     }
    )[]>;
  
  
  papi_cancelMarginAccountAllOpenOrdersOnASymbol(...args : any) {
      return this._sendRequest("/papi/v1/margin/allOpenOrders", "DELETE", "TRADE", true, args, ["symbol", "recvWindow", "timestamp"], "papi_cancelMarginAccountAllOpenOrdersOnASymbol");
  }
  
  
  /** Cancel Margin Account OCO Orders(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-margin-account-oco-orders-trade}
   * 
   * Cancel Margin Account OCO Orders
   * 
   * EndPoint: /papi/v1/margin/orderList
   * 
   * Weight(IP): 2
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderListId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} listClientOrderId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_cancelMarginAccountOCOOrders(symbol :string, orderListId? :LONG, listClientOrderId? :string, newClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelMarginAccountOCOOrders"]>;
  
  
  /** Cancel Margin Account OCO Orders(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-margin-account-oco-orders-trade}
   * 
   * Cancel Margin Account OCO Orders
   * 
   * EndPoint: /papi/v1/margin/orderList
   * 
   * Weight(IP): 2
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderListId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} options.listClientOrderId  -  Either orderListId or listClientOrderId must be provided
   * @param {string} options.newClientOrderId  -  Used to uniquely identify this cancel. Automatically generated by default
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_cancelMarginAccountOCOOrders(options : { symbol :string, orderListId? :LONG, listClientOrderId? :string, newClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 0
     contingencyType: string,  // example: "OCO"
     listStatusType: OCOStatus,  // example: "ALL_DONE"
     listOrderStatus: OCOOrderStatus,  // example: "ALL_DONE"
     listClientOrderId: string,  // example: "C3wyj4WVEktd7u9aVBRXcN"
     transactionTime: number,  // example: 1574040868128
     symbol: string,  // example: "LTCBTC"
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 2
         clientOrderId: string  // example: "pO9ufTiFGg3nw2fOdgeOXa"
       }[],
     orderReports: {
         symbol: string,  // example: "LTCBTC"
         origClientOrderId: string,  // example: "pO9ufTiFGg3nw2fOdgeOXa"
         orderId: number,  // example: 2
         orderListId: number,  // example: 0
         clientOrderId: string,  // example: "unfWT8ig8i0uj6lPuYLez6"
         price: NumberString,  // example: "1.00000000"
         origQty: NumberString,  // example: "10.00000000"
         executedQty: NumberString,  // example: "0.00000000"
         cummulativeQuoteQty: NumberString,  // example: "0.00000000"
         status: string,  // example: "CANCELED"
         timeInForce: TimeInForce,  // example: "GTC"
         type: OrderType,  // example: "STOP_LOSS_LIMIT"
         side: OrderSide,  // example: "SELL"
         stopPrice: NumberString,  // example: "1.00000000"
         selfTradePreventionMode: string  // example: "EXPIRE_BOTH"
       }[]
    }>;
  
  
  papi_cancelMarginAccountOCOOrders(...args : any) {
      return this._sendRequest("/papi/v1/margin/orderList", "DELETE", "TRADE", true, args, ["symbol", "orderListId", "listClientOrderId", "newClientOrderId", "recvWindow", "timestamp"], "papi_cancelMarginAccountOCOOrders");
  }
  
  
  /** Cancel UM Conditional Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-um-conditional-order-trade}
   * 
   * EndPoint: /papi/v1/um/conditional/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} strategyId
   * @param {string} newClientStrategyId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cancelUMConditionalOrder(symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelUMConditionalOrder"]>;
  
  
  /** Cancel UM Conditional Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-um-conditional-order-trade}
   * 
   * EndPoint: /papi/v1/um/conditional/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.strategyId
   * @param {string} options.newClientStrategyId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cancelUMConditionalOrder(options : { symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     newClientStrategyId: string,  // example: "myOrder1"
     strategyId: number,  // example: 123445
     strategyStatus: string,  // example: "CANCELED"
     strategyType: string,  // example: "TRAILING_STOP_MARKET"
     origQty: NumberString,  // example: "11"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     symbol: string,  // example: "BTCUSDT"
     timeInForce: TimeInForce,  // example: "GTC"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     bookTime: number,  // example: 1566818724710
     updateTime: number,  // example: 1566818724722
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean,  // example: false
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 0
    }>;
  
  
  papi_cancelUMConditionalOrder(...args : any) {
      return this._sendRequest("/papi/v1/um/conditional/order", "DELETE", "TRADE", true, args, ["symbol", "strategyId", "newClientStrategyId", "recvWindow", "timestamp"], "papi_cancelUMConditionalOrder");
  }
  
  
  /** Cancel All UM Open Conditional Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-all-um-open-conditional-orders-trade}
   * 
   * EndPoint: /papi/v1/um/conditional/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cancelAllUMOpenConditionalOrders(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelAllUMOpenConditionalOrders"]>;
  
  
  /** Cancel All UM Open Conditional Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-all-um-open-conditional-orders-trade}
   * 
   * EndPoint: /papi/v1/um/conditional/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cancelAllUMOpenConditionalOrders(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "200"
     msg: string  // example: "The operation of cancel all conditional open order is done."
    }>;
  
  
  papi_cancelAllUMOpenConditionalOrders(...args : any) {
      return this._sendRequest("/papi/v1/um/conditional/allOpenOrders", "DELETE", "TRADE", true, args, ["symbol", "recvWindow", "timestamp"], "papi_cancelAllUMOpenConditionalOrders");
  }
  
  
  /** Cancel CM Conditional Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-cm-conditional-order-trade}
   * 
   * EndPoint: /papi/v1/cm/conditional/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} strategyId
   * @param {string} newClientStrategyId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cancelCMConditionalOrder(symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelCMConditionalOrder"]>;
  
  
  /** Cancel CM Conditional Order (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-cm-conditional-order-trade}
   * 
   * EndPoint: /papi/v1/cm/conditional/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.strategyId
   * @param {string} options.newClientStrategyId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cancelCMConditionalOrder(options : { symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     newClientStrategyId: string,  // example: "myOrder1"
     strategyId: number,  // example: 123445
     strategyStatus: string,  // example: "CANCELED"
     strategyType: string,  // example: "TRAILING_STOP_MARKET"
     origQty: NumberString,  // example: "11"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     symbol: string,  // example: "BTCUSD"
     timeInForce: TimeInForce,  // example: "GTC"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     bookTime: number,  // example: 1566818724710
     updateTime: number,  // example: 1566818724722
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean  // example: false
    }>;
  
  
  papi_cancelCMConditionalOrder(...args : any) {
      return this._sendRequest("/papi/v1/cm/conditional/order", "DELETE", "TRADE", true, args, ["symbol", "strategyId", "newClientStrategyId", "recvWindow", "timestamp"], "papi_cancelCMConditionalOrder");
  }
  
  
  /** Cancel All CM Open Conditional Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-all-cm-open-conditional-orders-trade}
   * 
   * EndPoint: /papi/v1/cm/conditional/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cancelAllCMOpenConditionalOrders(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cancelAllCMOpenConditionalOrders"]>;
  
  
  /** Cancel All CM Open Conditional Orders (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cancel-all-cm-open-conditional-orders-trade}
   * 
   * EndPoint: /papi/v1/cm/conditional/allOpenOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cancelAllCMOpenConditionalOrders(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: NumberString,  // example: "200"
     msg: string  // example: "The operation of cancel all conditional open order is done."
    }>;
  
  
  papi_cancelAllCMOpenConditionalOrders(...args : any) {
      return this._sendRequest("/papi/v1/cm/conditional/allOpenOrders", "DELETE", "TRADE", true, args, ["symbol", "recvWindow", "timestamp"], "papi_cancelAllCMOpenConditionalOrders");
  }
  
  
  
  //***** Query Order *****
  
  
  /** Query UM Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-um-order-user_data}
   * 
   * Check an UM order's status.
   * 
   * EndPoint: /papi/v1/um/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryUMOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryUMOrder"]>;
  
  
  /** Query UM Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-um-order-user_data}
   * 
   * Check an UM order's status.
   * 
   * EndPoint: /papi/v1/um/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryUMOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.00000"
     clientOrderId: string,  // example: "abc"
     cumQuote: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 1917641
     origQty: NumberString,  // example: "0.40"
     origType: string,  // example: "LIMIT"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "NEW"
     symbol: string,  // example: "BTCUSDT"
     time: number,  // example: 1579276756075  // order time
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     updateTime: number,  // example: 1579276756075  // update time
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 0
    }>;
  
  
  papi_queryUMOrder(...args : any) {
      return this._sendRequest("/papi/v1/um/order", "GET", "USER_DATA", true, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "papi_queryUMOrder");
  }
  
  
  /** Query Current UM Open Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-current-um-open-order-user_data}
   * 
   * Query current UM open order
   * 
   * EndPoint: /papi/v1/um/openOrder
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryCurrentUMOpenOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryCurrentUMOpenOrder"]>;
  
  
  /** Query Current UM Open Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-current-um-open-order-user_data}
   * 
   * Query current UM open order
   * 
   * EndPoint: /papi/v1/um/openOrder
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryCurrentUMOpenOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.00000"
     clientOrderId: string,  // example: "abc"
     cumQuote: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 1917641
     origQty: NumberString,  // example: "0.40"
     origType: string,  // example: "LIMIT"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "NEW"
     symbol: string,  // example: "BTCUSDT"
     time: number,  // example: 1579276756075  // order time
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     updateTime: number,  // example: 1579276756075
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 0
    }>;
  
  
  papi_queryCurrentUMOpenOrder(...args : any) {
      return this._sendRequest("/papi/v1/um/openOrder", "GET", "USER_DATA", true, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "papi_queryCurrentUMOpenOrder");
  }
  
  
  /** Query All Current UM Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-current-um-open-orders-user_data}
   * 
   * Notes:
   * * If the symbol is not sent, orders for all symbols will be returned in an array.
   * 
   * EndPoint: /papi/v1/um/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryAllCurrentUMOpenOrders(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryAllCurrentUMOpenOrders"]>;
  
  
  /** Query All Current UM Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-current-um-open-orders-user_data}
   * 
   * Notes:
   * * If the symbol is not sent, orders for all symbols will be returned in an array.
   * 
   * EndPoint: /papi/v1/um/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryAllCurrentUMOpenOrders(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       avgPrice: NumberString,  // example: "0.00000"
       clientOrderId: string,  // example: "abc"
       cumQuote: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 1917641
       origQty: NumberString,  // example: "0.40"
       origType: string,  // example: "LIMIT"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       symbol: string,  // example: "BTCUSDT"
       time: number,  // example: 1579276756075  // order time
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       updateTime: number,  // example: 1579276756075  // update time
       selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
       goodTillDate: number  // example: 0
     }[]>;
  
  
  papi_queryAllCurrentUMOpenOrders(...args : any) {
      return this._sendRequest("/papi/v1/um/openOrders", "GET", "USER_DATA", true, args, ["symbol", "recvWindow", "timestamp"], "papi_queryAllCurrentUMOpenOrders");
  }
  
  
  /** Query All UM Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-um-orders-user_data}
   * 
   * Get all account UM orders; active, canceled, or filled.
   * 
   * EndPoint: /papi/v1/um/allOrders
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryAllUMOrders(symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryAllUMOrders"]>;
  
  
  /** Query All UM Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-um-orders-user_data}
   * 
   * Get all account UM orders; active, canceled, or filled.
   * 
   * EndPoint: /papi/v1/um/allOrders
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryAllUMOrders(options : { symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       avgPrice: NumberString,  // example: "0.00000"
       clientOrderId: string,  // example: "abc"
       cumQuote: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 1917641
       origQty: NumberString,  // example: "0.40"
       origType: string,  // example: "LIMIT"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       symbol: string,  // example: "BTCUSDT"
       time: number,  // example: 1579276756075  // order time
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       updateTime: number,  // example: 1579276756075  // update time
       selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
       goodTillDate: number  // example: 0
     }[]>;
  
  
  papi_queryAllUMOrders(...args : any) {
      return this._sendRequest("/papi/v1/um/allOrders", "GET", "USER_DATA", true, args, ["symbol", "orderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_queryAllUMOrders");
  }
  
  
  /** Query CM Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-cm-order-user_data}
   * 
   * Check an CM order's status.
   * 
   * EndPoint: /papi/v1/cm/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryCMOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryCMOrder"]>;
  
  
  /** Query CM Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-cm-order-user_data}
   * 
   * Check an CM order's status.
   * 
   * EndPoint: /papi/v1/cm/order
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryCMOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.0"
     clientOrderId: string,  // example: "abc"
     cumBase: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 1917641
     origQty: NumberString,  // example: "0.40"
     origType: string,  // example: "LIMIT"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     status: string,  // example: "NEW"
     symbol: string,  // example: "BTCUSD_200925"
     pair: string,  // example: "BTCUSD"
     positionSide: PositionSide,  // example: "SHORT"
     time: number,  // example: 1579276756075  // order time
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     updateTime: number  // example: 1579276756075  // update time
    }>;
  
  
  papi_queryCMOrder(...args : any) {
      return this._sendRequest("/papi/v1/cm/order", "GET", "USER_DATA", true, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "papi_queryCMOrder");
  }
  
  
  /** Query Current CM Open Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-current-cm-open-order-user_data}
   * 
   * Query current CM open order
   * 
   * EndPoint: /papi/v1/cm/openOrder
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryCurrentCMOpenOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryCurrentCMOpenOrder"]>;
  
  
  /** Query Current CM Open Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-current-cm-open-order-user_data}
   * 
   * Query current CM open order
   * 
   * EndPoint: /papi/v1/cm/openOrder
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryCurrentCMOpenOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     avgPrice: NumberString,  // example: "0.0"
     clientOrderId: string,  // example: "abc"
     cumBase: NumberString,  // example: "0"
     executedQty: NumberString,  // example: "0"
     orderId: number,  // example: 1917641
     origQty: NumberString,  // example: "0.40"
     origType: string,  // example: "LIMIT"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     status: string,  // example: "NEW"
     symbol: string,  // example: "BTCUSD_200925"
     pair: string,  // example: "BTCUSD"
     time: number,  // example: 1579276756075  // order time
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     updateTime: number  // example: 1579276756075  // update time
    }>;
  
  
  papi_queryCurrentCMOpenOrder(...args : any) {
      return this._sendRequest("/papi/v1/cm/openOrder", "GET", "USER_DATA", true, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "papi_queryCurrentCMOpenOrder");
  }
  
  
  /** Query All Current CM Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-current-cm-open-orders-user_data}
   * 
   * Notes: 
   * * If the symbol is not sent, orders for all symbols will be returned in an array.
   * 
   * EndPoint: /papi/v1/cm/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {string} pair
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryAllCurrentCMOpenOrders(symbol? :string, pair? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryAllCurrentCMOpenOrders"]>;
  
  
  /** Query All Current CM Open Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-current-cm-open-orders-user_data}
   * 
   * Notes: 
   * * If the symbol is not sent, orders for all symbols will be returned in an array.
   * 
   * EndPoint: /papi/v1/cm/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {string} options.pair
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryAllCurrentCMOpenOrders(options? : { symbol? :string, pair? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       avgPrice: NumberString,  // example: "0.0"
       clientOrderId: string,  // example: "abc"
       cumBase: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 1917641
       origQty: NumberString,  // example: "0.40"
       origType: string,  // example: "LIMIT"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       symbol: string,  // example: "BTCUSD_200925"
       pair: string,  // example: "BTCUSD"
       time: number,  // example: 1579276756075  // order time
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       updateTime: number  // example: 1579276756075  // update time
     }[]>;
  
  
  papi_queryAllCurrentCMOpenOrders(...args : any) {
      return this._sendRequest("/papi/v1/cm/openOrders", "GET", "USER_DATA", true, args, ["symbol", "pair", "recvWindow", "timestamp"], "papi_queryAllCurrentCMOpenOrders");
  }
  
  
  /** Query All CM Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-cm-orders-user_data}
   * 
   * Get all account CM orders; active, canceled, or filled.
   * 
   * EndPoint: /papi/v1/cm/allOrders
   * 
   * Weight(IP): 20 with symbol 40 with pair
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {string} pair
   * @param {LONG} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 50; max 100.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryAllCMOrders(symbol :string, pair? :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryAllCMOrders"]>;
  
  
  /** Query All CM Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-cm-orders-user_data}
   * 
   * Get all account CM orders; active, canceled, or filled.
   * 
   * EndPoint: /papi/v1/cm/allOrders
   * 
   * Weight(IP): 20 with symbol 40 with pair
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {string} options.pair
   * @param {LONG} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 50; max 100.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryAllCMOrders(options : { symbol :string, pair? :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       avgPrice: NumberString,  // example: "0.0"
       clientOrderId: string,  // example: "abc"
       cumBase: NumberString,  // example: "0"
       executedQty: NumberString,  // example: "0"
       orderId: number,  // example: 1917641
       origQty: NumberString,  // example: "0.40"
       origType: string,  // example: "LIMIT"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       status: string,  // example: "NEW"
       symbol: string,  // example: "BTCUSD_200925"
       pair: string,  // example: "BTCUSD"
       time: number,  // example: 1579276756075  // order time
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       updateTime: number  // example: 1579276756075  // update time
     }[]>;
  
  
  papi_queryAllCMOrders(...args : any) {
      return this._sendRequest("/papi/v1/cm/allOrders", "GET", "USER_DATA", true, args, ["symbol", "pair", "orderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_queryAllCMOrders");
  }
  
  
  /** Query Current UM Open Conditional Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-current-um-open-conditional-order-user_data}
   * 
   * EndPoint: /papi/v1/um/conditional/openOrder
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} strategyId
   * @param {string} newClientStrategyId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryCurrentUMOpenConditionalOrder(symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryCurrentUMOpenConditionalOrder"]>;
  
  
  /** Query Current UM Open Conditional Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-current-um-open-conditional-order-user_data}
   * 
   * EndPoint: /papi/v1/um/conditional/openOrder
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.strategyId
   * @param {string} options.newClientStrategyId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryCurrentUMOpenConditionalOrder(options : { symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     newClientStrategyId: string,  // example: "abc"
     strategyId: number,  // example: 123445
     strategyStatus: string,  // example: "NEW"
     strategyType: string,  // example: "TRAILING_STOP_MARKET"
     origQty: NumberString,  // example: "0.40"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     symbol: string,  // example: "BTCUSDT"
     bookTime: number,  // example: 1566818724710  // order time
     updateTime: number,  // example: 1566818724722
     timeInForce: TimeInForce,  // example: "GTC"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 0
    }>;
  
  
  papi_queryCurrentUMOpenConditionalOrder(...args : any) {
      return this._sendRequest("/papi/v1/um/conditional/openOrder", "GET", "USER_DATA", true, args, ["symbol", "strategyId", "newClientStrategyId", "recvWindow", "timestamp"], "papi_queryCurrentUMOpenConditionalOrder");
  }
  
  
  /** Query All Current UM Open Conditional Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-current-um-open-conditional-orders-user_data}
   * 
   * Notes:
   * * If the symbol is not sent, orders for all symbols will be returned in an array.
   * 
   * EndPoint: /papi/v1/um/conditional/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryAllCurrentUMOpenConditionalOrders(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryAllCurrentUMOpenConditionalOrders"]>;
  
  
  /** Query All Current UM Open Conditional Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-current-um-open-conditional-orders-user_data}
   * 
   * Notes:
   * * If the symbol is not sent, orders for all symbols will be returned in an array.
   * 
   * EndPoint: /papi/v1/um/conditional/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryAllCurrentUMOpenConditionalOrders(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       newClientStrategyId: string,  // example: "abc"
       strategyId: number,  // example: 123445
       strategyStatus: string,  // example: "NEW"
       strategyType: string,  // example: "TRAILING_STOP_MARKET"
       origQty: NumberString,  // example: "0.40"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       symbol: string,  // example: "BTCUSDT"
       bookTime: number,  // example: 1566818724710  // order time
       updateTime: number,  // example: 1566818724722
       timeInForce: TimeInForce,  // example: "GTC"
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
       selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
       goodTillDate: number  // example: 0
     }[]>;
  
  
  papi_queryAllCurrentUMOpenConditionalOrders(...args : any) {
      return this._sendRequest("/papi/v1/um/conditional/openOrders", "GET", "USER_DATA", true, args, ["symbol", "recvWindow", "timestamp"], "papi_queryAllCurrentUMOpenConditionalOrders");
  }
  
  
  /** Query UM Conditional Order History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-um-conditional-order-history-user_data}
   * 
   * EndPoint: /papi/v1/um/conditional/orderHistory
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} strategyId
   * @param {string} newClientStrategyId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryUMConditionalOrderHistory(symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryUMConditionalOrderHistory"]>;
  
  
  /** Query UM Conditional Order History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-um-conditional-order-history-user_data}
   * 
   * EndPoint: /papi/v1/um/conditional/orderHistory
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.strategyId
   * @param {string} options.newClientStrategyId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryUMConditionalOrderHistory(options : { symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     newClientStrategyId: string,  // example: "abc"
     strategyId: number,  // example: 123445
     strategyStatus: string,  // example: "TRIGGERED"
     strategyType: string,  // example: "TRAILING_STOP_MARKET"
     origQty: NumberString,  // example: "0.40"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     symbol: string,  // example: "BTCUSDT"
     orderId: number,  // example: 12132343435  //Normal orderID after trigger if appliable,only have when the strategy is triggered
     status: string,  // example: "NEW"  //Normal order status after trigger if appliable, only have when the strategy is triggered
     bookTime: number,  // example: 1566818724710  // order time
     updateTime: number,  // example: 1566818724722
     triggerTime: number,  // example: 1566818724750
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "MARKET"  //Normal order type after trigger if appliable
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean,  // example: false
     selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
     goodTillDate: number  // example: 0
    }>;
  
  
  papi_queryUMConditionalOrderHistory(...args : any) {
      return this._sendRequest("/papi/v1/um/conditional/orderHistory", "GET", "USER_DATA", true, args, ["symbol", "strategyId", "newClientStrategyId", "recvWindow", "timestamp"], "papi_queryUMConditionalOrderHistory");
  }
  
  
  /** Query All UM Conditional Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-um-conditional-orders-user_data}
   * 
   * EndPoint: /papi/v1/um/conditional/allOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} strategyId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryAllUMConditionalOrders(symbol? :string, strategyId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryAllUMConditionalOrders"]>;
  
  
  /** Query All UM Conditional Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-um-conditional-orders-user_data}
   * 
   * EndPoint: /papi/v1/um/conditional/allOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.strategyId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryAllUMConditionalOrders(options? : { symbol? :string, strategyId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       newClientStrategyId: string,  // example: "abc"
       strategyId: number,  // example: 123445
       strategyStatus: string,  // example: "TRIGGERED"
       strategyType: string,  // example: "TRAILING_STOP_MARKET"
       origQty: NumberString,  // example: "0.40"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       symbol: string,  // example: "BTCUSDT"
       orderId: number,  // example: 12132343435  //Normal orderID after trigger if appliable, only have when the strategy is triggered
       status: string,  // example: "NEW"  //Normal order status after trigger if appliable, only have when the strategy is triggered
       bookTime: number,  // example: 1566818724710  // order time
       updateTime: number,  // example: 1566818724722
       triggerTime: number,  // example: 1566818724750
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "MARKET"  //Normal order type after trigger if appliable
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
       selfTradePreventionMode: string,  // example: "NONE"  //self trading preventation mode
       goodTillDate: number  // example: 0
     }[]>;
  
  
  papi_queryAllUMConditionalOrders(...args : any) {
      return this._sendRequest("/papi/v1/um/conditional/allOrders", "GET", "USER_DATA", true, args, ["symbol", "strategyId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_queryAllUMConditionalOrders");
  }
  
  
  /** Query Current CM Open Conditional Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-current-cm-open-conditional-order-user_data}
   * 
   * EndPoint: /papi/v1/cm/conditional/openOrder
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} strategyId
   * @param {string} newClientStrategyId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryCurrentCMOpenConditionalOrder(symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryCurrentCMOpenConditionalOrder"]>;
  
  
  /** Query Current CM Open Conditional Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-current-cm-open-conditional-order-user_data}
   * 
   * EndPoint: /papi/v1/cm/conditional/openOrder
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.strategyId
   * @param {string} options.newClientStrategyId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryCurrentCMOpenConditionalOrder(options : { symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     newClientStrategyId: string,  // example: "abc"
     strategyId: number,  // example: 123445
     strategyStatus: string,  // example: "NEW"
     strategyType: string,  // example: "TRAILING_STOP_MARKET"
     origQty: NumberString,  // example: "0.40"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     symbol: string,  // example: "BTCUSD"
     bookTime: number,  // example: 1566818724710  // order time
     updateTime: number,  // example: 1566818724722
     timeInForce: TimeInForce,  // example: "GTC"
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
    }>;
  
  
  papi_queryCurrentCMOpenConditionalOrder(...args : any) {
      return this._sendRequest("/papi/v1/cm/conditional/openOrder", "GET", "USER_DATA", true, args, ["symbol", "strategyId", "newClientStrategyId", "recvWindow", "timestamp"], "papi_queryCurrentCMOpenConditionalOrder");
  }
  
  
  /** Query All Current CM Open Conditional Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-current-cm-open-conditional-orders-user_data}
   * 
   * Notes:
   * * If the symbol is not sent, orders for all symbols will be returned in an array.
   * 
   * EndPoint: /papi/v1/cm/conditional/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryAllCurrentCMOpenConditionalOrders(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryAllCurrentCMOpenConditionalOrders"]>;
  
  
  /** Query All Current CM Open Conditional Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-current-cm-open-conditional-orders-user_data}
   * 
   * Notes:
   * * If the symbol is not sent, orders for all symbols will be returned in an array.
   * 
   * EndPoint: /papi/v1/cm/conditional/openOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryAllCurrentCMOpenConditionalOrders(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       newClientStrategyId: string,  // example: "abc"
       strategyId: number,  // example: 123445
       strategyStatus: string,  // example: "NEW"
       strategyType: string,  // example: "TRAILING_STOP_MARKET"
       origQty: NumberString,  // example: "0.40"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       symbol: string,  // example: "BTCUSD"
       bookTime: number,  // example: 1566818724710  // order time
       updateTime: number,  // example: 1566818724722
       timeInForce: TimeInForce,  // example: "GTC"
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     }[]>;
  
  
  papi_queryAllCurrentCMOpenConditionalOrders(...args : any) {
      return this._sendRequest("/papi/v1/cm/conditional/openOrders", "GET", "USER_DATA", true, args, ["symbol", "recvWindow", "timestamp"], "papi_queryAllCurrentCMOpenConditionalOrders");
  }
  
  
  /** Query CM Conditional Order History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-cm-conditional-order-history-user_data}
   * 
   * EndPoint: /papi/v1/cm/conditional/orderHistory
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} strategyId
   * @param {string} newClientStrategyId
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryCMConditionalOrderHistory(symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryCMConditionalOrderHistory"]>;
  
  
  /** Query CM Conditional Order History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-cm-conditional-order-history-user_data}
   * 
   * EndPoint: /papi/v1/cm/conditional/orderHistory
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.strategyId
   * @param {string} options.newClientStrategyId
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryCMConditionalOrderHistory(options : { symbol :string, strategyId? :LONG, newClientStrategyId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     newClientStrategyId: string,  // example: "abc"
     strategyId: number,  // example: 123445
     strategyStatus: string,  // example: "TRIGGERED"
     strategyType: string,  // example: "TRAILING_STOP_MARKET"
     origQty: NumberString,  // example: "0.40"
     price: NumberString,  // example: "0"
     reduceOnly: boolean,  // example: false
     side: OrderSide,  // example: "BUY"
     positionSide: PositionSide,  // example: "SHORT"
     stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
     symbol: string,  // example: "BTCUSD"
     orderId: number,  // example: 12123343534  //Normal orderID after trigger if appliable,only have when the strategy is triggered
     status: string,  // example: "NEW"  //Normal order status after trigger if appliable, only have when the strategy is triggered
     bookTime: number,  // example: 1566818724710  // order time
     updateTime: number,  // example: 1566818724722
     triggerTime: number,  // example: 1566818724750
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "MARKET"  //Normal order type after trigger if appliable
     activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
     priceRate: NumberString,  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     workingType: WorkingType,  // example: "CONTRACT_PRICE"
     priceProtect: boolean  // example: false
    }>;
  
  
  papi_queryCMConditionalOrderHistory(...args : any) {
      return this._sendRequest("/papi/v1/cm/conditional/orderHistory", "GET", "USER_DATA", true, args, ["symbol", "strategyId", "newClientStrategyId", "recvWindow", "timestamp"], "papi_queryCMConditionalOrderHistory");
  }
  
  
  /** Query All CM Conditional Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-cm-conditional-orders-user_data}
   * 
   * EndPoint: /papi/v1/cm/conditional/allOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * @param {string} symbol
   * @param {LONG} strategyId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryAllCMConditionalOrders(symbol? :string, strategyId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryAllCMConditionalOrders"]>;
  
  
  /** Query All CM Conditional Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-cm-conditional-orders-user_data}
   * 
   * EndPoint: /papi/v1/cm/conditional/allOrders
   * 
   * Weight(IP): 1 for a single symbol; 40 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol
   * @param {LONG} options.strategyId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryAllCMConditionalOrders(options? : { symbol? :string, strategyId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       newClientStrategyId: string,  // example: "abc"
       strategyId: number,  // example: 123445
       strategyStatus: string,  // example: "TRIGGERED"
       strategyType: string,  // example: "TRAILING_STOP_MARKET"
       origQty: NumberString,  // example: "0.40"
       price: NumberString,  // example: "0"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "BUY"
       positionSide: PositionSide,  // example: "SHORT"
       stopPrice: NumberString,  // example: "9300"  // please ignore when order type is TRAILING_STOP_MARKET
       symbol: string,  // example: "BTCUSD"
       orderId: number,  // example: 12123343534  //Normal orderID after trigger if appliable, only have when the strategy is triggered
       status: string,  // example: "NEW"  //Normal order status after trigger if appliable, only have when the strategy is triggered
       bookTime: number,  // example: 1566818724710  // order time
       updateTime: number,  // example: 1566818724722
       triggerTime: number,  // example: 1566818724750
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "MARKET"  //Normal order type after trigger if appliable
       activatePrice: NumberString,  // example: "9020"  // activation price, only return with TRAILING_STOP_MARKET order
       priceRate: NumberString  // example: "0.3"  // callback rate, only return with TRAILING_STOP_MARKET order
     }[]>;
  
  
  papi_queryAllCMConditionalOrders(...args : any) {
      return this._sendRequest("/papi/v1/cm/conditional/allOrders", "GET", "USER_DATA", false, args, ["symbol", "strategyId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_queryAllCMConditionalOrders");
  }
  
  
  /** Query Margin Account Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-account-order-user_data}
   * 
   * EndPoint: /papi/v1/margin/order
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryMarginAccountOrder(symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryMarginAccountOrder"]>;
  
  
  /** Query Margin Account Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-account-order-user_data}
   * 
   * EndPoint: /papi/v1/margin/order
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryMarginAccountOrder(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     clientOrderId: string,  // example: "ZwfQzuDIGpceVhKW5DvCmO"
     cummulativeQuoteQty: NumberString,  // example: "0.00000000"
     executedQty: NumberString,  // example: "0.00000000"
     icebergQty: NumberString,  // example: "0.00000000"
     isWorking: boolean,  // example: true
     orderId: number,  // example: 213205622
     origQty: NumberString,  // example: "0.30000000"
     price: NumberString,  // example: "0.00493630"
     side: OrderSide,  // example: "SELL"
     status: string,  // example: "NEW"
     stopPrice: NumberString,  // example: "0.00000000"
     symbol: string,  // example: "BNBBTC"
     time: number,  // example: 1562133008725
     timeInForce: TimeInForce,  // example: "GTC"
     type: OrderType,  // example: "LIMIT"
     updateTime: number,  // example: 1562133008725
     accountId: number,  // example: 152950866
     selfTradePreventionMode: string,  // example: "EXPIRE_TAKER"
     preventedMatchId: null,  // example: null
     preventedQuantity: null  // example: null
    }>;
  
  
  papi_queryMarginAccountOrder(...args : any) {
      return this._sendRequest("/papi/v1/margin/order", "GET", "USER_DATA", false, args, ["symbol", "orderId", "origClientOrderId", "recvWindow", "timestamp"], "papi_queryMarginAccountOrder");
  }
  
  
  /** Query Current Margin Open Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-current-margin-open-order-user_data}
   * 
   * Notes:
   * * If the symbol is not sent, orders for all symbols will be returned in an array.
   * * When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange.
   * 
   * EndPoint: /papi/v1/margin/openOrders
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryCurrentMarginOpenOrder(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryCurrentMarginOpenOrder"]>;
  
  
  /** Query Current Margin Open Order (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-current-margin-open-order-user_data}
   * 
   * Notes:
   * * If the symbol is not sent, orders for all symbols will be returned in an array.
   * * When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange.
   * 
   * EndPoint: /papi/v1/margin/openOrders
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryCurrentMarginOpenOrder(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       clientOrderId: string,  // example: "qhcZw71gAkCCTv0t0k8LUK"
       cummulativeQuoteQty: NumberString,  // example: "0.00000000"
       executedQty: NumberString,  // example: "0.00000000"
       icebergQty: NumberString,  // example: "0.00000000"
       isWorking: boolean,  // example: true
       orderId: number,  // example: 211842552
       origQty: NumberString,  // example: "0.30000000"
       price: NumberString,  // example: "0.00475010"
       side: OrderSide,  // example: "SELL"
       status: string,  // example: "NEW"
       stopPrice: NumberString,  // example: "0.00000000"
       symbol: string,  // example: "BNBBTC"
       time: number,  // example: 1562040170089
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "LIMIT"
       updateTime: number,  // example: 1562040170089
       accountId: number,  // example: 152950866
       selfTradePreventionMode: string,  // example: "EXPIRE_TAKER"
       preventedMatchId: null,  // example: null
       preventedQuantity: null  // example: null
     }[]>;
  
  
  papi_queryCurrentMarginOpenOrder(...args : any) {
      return this._sendRequest("/papi/v1/margin/openOrders", "GET", "USER_DATA", true, args, ["symbol", "recvWindow", "timestamp"], "papi_queryCurrentMarginOpenOrder");
  }
  
  
  /** Query All Margin Account Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-margin-account-orders-user_data}
   * 
   * EndPoint: /papi/v1/margin/allOrders
   * 
   * Weight(IP): 100
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 500; max 500.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryAllMarginAccountOrders(symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryAllMarginAccountOrders"]>;
  
  
  /** Query All Margin Account Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-all-margin-account-orders-user_data}
   * 
   * EndPoint: /papi/v1/margin/allOrders
   * 
   * Weight(IP): 100
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 500; max 500.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryAllMarginAccountOrders(options : { symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       clientOrderId: string,  // example: "D2KDy4DIeS56PvkM13f8cP"
       cummulativeQuoteQty: NumberString,  // example: "0.00000000"
       executedQty: NumberString,  // example: "0.00000000"
       icebergQty: NumberString,  // example: "0.00000000"
       isWorking: boolean,  // example: false
       orderId: number,  // example: 41295
       origQty: NumberString,  // example: "5.31000000"
       price: NumberString,  // example: "0.22500000"
       side: OrderSide,  // example: "SELL"
       status: string,  // example: "CANCELED"
       stopPrice: NumberString,  // example: "0.18000000"
       symbol: string,  // example: "BNBBTC"
       time: number,  // example: 1565769338806
       timeInForce: TimeInForce,  // example: "GTC"
       type: OrderType,  // example: "TAKE_PROFIT_LIMIT"
       updateTime: number,  // example: 1565769342148
       accountId: number,  // example: 152950866
       selfTradePreventionMode: string,  // example: "EXPIRE_TAKER"
       preventedMatchId: null,  // example: null
       preventedQuantity: null  // example: null
     }[]>;
  
  
  papi_queryAllMarginAccountOrders(...args : any) {
      return this._sendRequest("/papi/v1/margin/allOrders", "GET", "USER_DATA", true, args, ["symbol", "orderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_queryAllMarginAccountOrders");
  }
  
  
  /** Query Margin Account's OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-account-39-s-oco-user_data}
   * 
   * Retrieves a specific OCO based on provided optional parameters
   * 
   * EndPoint: /papi/v1/margin/orderList
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} orderListId  -  Either orderListId or origClientOrderId must be provided
   * @param {string} origClientOrderId  -  Either orderListId or origClientOrderId must be provided
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryMarginAccountSOCO(orderListId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryMarginAccountSOCO"]>;
  
  
  /** Query Margin Account's OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-account-39-s-oco-user_data}
   * 
   * Retrieves a specific OCO based on provided optional parameters
   * 
   * EndPoint: /papi/v1/margin/orderList
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.orderListId  -  Either orderListId or origClientOrderId must be provided
   * @param {string} options.origClientOrderId  -  Either orderListId or origClientOrderId must be provided
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryMarginAccountSOCO(options? : { orderListId? :LONG, origClientOrderId? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     orderListId: number,  // example: 27
     contingencyType: string,  // example: "OCO"
     listStatusType: OCOStatus,  // example: "EXEC_STARTED"
     listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
     listClientOrderId: string,  // example: "h2USkA5YQpaXHPIrkd96xE"
     transactionTime: number,  // example: 1565245656253
     symbol: string,  // example: "LTCBTC"
     orders: {
         symbol: string,  // example: "LTCBTC"
         orderId: number,  // example: 4
         clientOrderId: string  // example: "qD1gy3kc3Gx0rihm9Y3xwS"
       }[]
    }>;
  
  
  papi_queryMarginAccountSOCO(...args : any) {
      return this._sendRequest("/papi/v1/margin/orderList", "GET", "USER_DATA", true, args, ["orderListId", "origClientOrderId", "recvWindow", "timestamp"], "papi_queryMarginAccountSOCO");
  }
  
  
  /** Query Margin Account's all OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-account-39-s-all-oco-user_data}
   * 
   * Query all OCO for a specific margin account based on provided optional parameters
   * 
   * EndPoint: /papi/v1/margin/allOrderList
   * 
   * Weight(IP): 100
   * 
   * HMAC SHA256
   * 
   * @param {LONG} fromId  -  If supplied, neither startTime or endTime can be provided
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default Value: 500; Max Value: 1000
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryMarginAccountSAllOCO(fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryMarginAccountSAllOCO"]>;
  
  
  /** Query Margin Account's all OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-account-39-s-all-oco-user_data}
   * 
   * Query all OCO for a specific margin account based on provided optional parameters
   * 
   * EndPoint: /papi/v1/margin/allOrderList
   * 
   * Weight(IP): 100
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.fromId  -  If supplied, neither startTime or endTime can be provided
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default Value: 500; Max Value: 1000
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryMarginAccountSAllOCO(options? : { fromId? :LONG, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderListId: number,  // example: 29
       contingencyType: string,  // example: "OCO"
       listStatusType: OCOStatus,  // example: "EXEC_STARTED"
       listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
       listClientOrderId: string,  // example: "amEEAXryFzFwYF1FeRpUoZ"
       transactionTime: number,  // example: 1565245913483
       symbol: string,  // example: "LTCBTC"
       orders: {
           symbol: string,  // example: "LTCBTC"
           orderId: number,  // example: 4
           clientOrderId: string  // example: "oD7aesZqjEGlZrbtRpy5zB"
         }[]
     }[]>;
  
  
  papi_queryMarginAccountSAllOCO(...args : any) {
      return this._sendRequest("/papi/v1/margin/allOrderList", "GET", "USER_DATA", true, args, ["fromId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_queryMarginAccountSAllOCO");
  }
  
  
  /** Query Margin Account's Open OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-account-39-s-open-oco-user_data}
   * 
   * EndPoint: /papi/v1/margin/openOrderList
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryMarginAccountSOpenOCO(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryMarginAccountSOpenOCO"]>;
  
  
  /** Query Margin Account's Open OCO (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-account-39-s-open-oco-user_data}
   * 
   * EndPoint: /papi/v1/margin/openOrderList
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryMarginAccountSOpenOCO(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderListId: number,  // example: 31
       contingencyType: string,  // example: "OCO"
       listStatusType: OCOStatus,  // example: "EXEC_STARTED"
       listOrderStatus: OCOOrderStatus,  // example: "EXECUTING"
       listClientOrderId: string,  // example: "wuB13fmulKj3YjdqWEcsnp"
       transactionTime: number,  // example: 1565246080644
       symbol: string,  // example: "LTCBTC"
       orders: {
           symbol: string,  // example: "LTCBTC"
           orderId: number,  // example: 4
           clientOrderId: string  // example: "r3EH2N76dHfLoSZWIUw1bT"
         }[]
     }[]>;
  
  
  papi_queryMarginAccountSOpenOCO(...args : any) {
      return this._sendRequest("/papi/v1/margin/openOrderList", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "papi_queryMarginAccountSOpenOCO");
  }
  
  
  /** Margin Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#margin-account-trade-list-user_data}
   * 
   * EndPoint: /papi/v1/margin/myTrades
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} fromId  -  TradeId to fetch from. Default gets most recent trades.
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_marginAccountTradeList(symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_marginAccountTradeList"]>;
  
  
  /** Margin Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#margin-account-trade-list-user_data}
   * 
   * EndPoint: /papi/v1/margin/myTrades
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.fromId  -  TradeId to fetch from. Default gets most recent trades.
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_marginAccountTradeList(options : { symbol :string, orderId? :LONG, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       commission: NumberString,  // example: "0.00006000"
       commissionAsset: string,  // example: "BTC"
       id: number,  // example: 34
       isBestMatch: boolean,  // example: true
       isBuyer: boolean,  // example: false
       isMaker: boolean,  // example: false
       orderId: number,  // example: 39324
       price: NumberString,  // example: "0.02000000"
       qty: NumberString,  // example: "3.00000000"
       symbol: string,  // example: "BNBBTC"
       time: number  // example: 1561973357171
     }[]>;
  
  
  papi_marginAccountTradeList(...args : any) {
      return this._sendRequest("/papi/v1/margin/myTrades", "GET", "USER_DATA", true, args, ["symbol", "orderId", "startTime", "endTime", "fromId", "limit", "recvWindow", "timestamp"], "papi_marginAccountTradeList");
  }
  
  
  /** Query UM Modify Order History (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-um-modify-order-history-trade}
   * 
   * Get order modification history
   * 
   * EndPoint: /papi/v1/um/orderAmendment
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} startTime  -  Timestamp in ms to get modification history from INCLUSIVE
   * @param {LONG} endTime  -  Timestamp in ms to get modification history until INCLUSIVE
   * @param {INT} limit  -  Default 500, max 1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryUMModifyOrderHistory(symbol :string, orderId? :LONG, origClientOrderId? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryUMModifyOrderHistory"]>;
  
  
  /** Query UM Modify Order History (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-um-modify-order-history-trade}
   * 
   * Get order modification history
   * 
   * EndPoint: /papi/v1/um/orderAmendment
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.startTime  -  Timestamp in ms to get modification history from INCLUSIVE
   * @param {LONG} options.endTime  -  Timestamp in ms to get modification history until INCLUSIVE
   * @param {INT} options.limit  -  Default 500, max 1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryUMModifyOrderHistory(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       amendmentId: number,  // example: 5363  // Order modification ID
       symbol: string,  // example: "BTCUSDT"
       pair: string,  // example: "BTCUSDT"
       orderId: number,  // example: 20072994037
       clientOrderId: string,  // example: "LJ9R4QZDihCaS8UAOOLpgW"
       time: number,  // example: 1629184560899  // Order modification time
       amendment: {
         price: {
           before: NumberString,  // example: "30004"
           after: NumberString  // example: "30003.2"
         },
         origQty: {
           before: NumberString,  // example: "1"
           after: NumberString  // example: "1"
         },
         count: number  // example: 3  // Order modification count, representing the number of times the order has been modified
       }
     }[]>;
  
  
  papi_queryUMModifyOrderHistory(...args : any) {
      return this._sendRequest("/papi/v1/um/orderAmendment", "GET", "TRADE", true, args, ["symbol", "orderId", "origClientOrderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_queryUMModifyOrderHistory");
  }
  
  
  /** Query CM Modify Order History (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-cm-modify-order-history-trade}
   * 
   * Get order modification history
   * 
   * EndPoint: /papi/v1/cm/orderAmendment
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} orderId
   * @param {string} origClientOrderId
   * @param {LONG} startTime  -  Timestamp in ms to get modification history from INCLUSIVE
   * @param {LONG} endTime  -  Timestamp in ms to get modification history until INCLUSIVE
   * @param {INT} limit  -  Default 50, max 100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryCMModifyOrderHistory(symbol :string, orderId? :LONG, origClientOrderId? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryCMModifyOrderHistory"]>;
  
  
  /** Query CM Modify Order History (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-cm-modify-order-history-trade}
   * 
   * Get order modification history
   * 
   * EndPoint: /papi/v1/cm/orderAmendment
   * 
   * Weight(UID): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.orderId
   * @param {string} options.origClientOrderId
   * @param {LONG} options.startTime  -  Timestamp in ms to get modification history from INCLUSIVE
   * @param {LONG} options.endTime  -  Timestamp in ms to get modification history until INCLUSIVE
   * @param {INT} options.limit  -  Default 50, max 100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryCMModifyOrderHistory(options : { symbol :string, orderId? :LONG, origClientOrderId? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       amendmentId: number,  // example: 5363  // Order modification ID
       symbol: string,  // example: "BTCUSD_PERP"
       pair: string,  // example: "BTCUSD"
       orderId: number,  // example: 20072994037
       clientOrderId: string,  // example: "LJ9R4QZDihCaS8UAOOLpgW"
       time: number,  // example: 1629184560899  // Order modification time
       amendment: {
         price: {
           before: NumberString,  // example: "30004"
           after: NumberString  // example: "30003.2"
         },
         origQty: {
           before: NumberString,  // example: "1"
           after: NumberString  // example: "1"
         },
         count: number  // example: 3  // Order modification count, representing the number of times the order has been modified
       }
     }[]>;
  
  
  papi_queryCMModifyOrderHistory(...args : any) {
      return this._sendRequest("/papi/v1/cm/orderAmendment", "GET", "TRADE", true, args, ["symbol", "orderId", "origClientOrderId", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_queryCMModifyOrderHistory");
  }
  
  
  
  //***** Account *****
  
  
  /** Account Balance(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#account-balance-user_data}
   * 
   * query account balance
   * 
   * EndPoint: /papi/v1/balance
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {string} asset
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_accountBalance(asset? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_accountBalance"]>;
  
  
  /** Account Balance(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#account-balance-user_data}
   * 
   * query account balance
   * 
   * EndPoint: /papi/v1/balance
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {string} options.asset
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_accountBalance(options? : { asset? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       asset: string,  // example: "USDT"  // asset name
       totalWalletBalance: NumberString,  // example: "122607.35137903"  // wallet balance =  cross margin free + cross margin locked + UM wallet balance + CM wallet balance
       crossMarginAsset: NumberString,  // example: "92.27530794"  // crossMarginAsset = crossMarginFree + crossMarginLocked
       crossMarginBorrowed: NumberString,  // example: "10.00000000"  // principal of cross margin
       crossMarginFree: NumberString,  // example: "100.00000000"  // free asset of cross margin
       crossMarginInterest: NumberString,  // example: "0.72469206"  // interest of cross margin
       crossMarginLocked: NumberString,  // example: "3.00000000"  //lock asset of cross margin
       umWalletBalance: NumberString,  // example: "0.00000000"  // wallet balance of um
       umUnrealizedPNL: NumberString,  // example: "23.72469206"  // unrealized profit of um
       cmWalletBalance: NumberString,  // example: "23.72469206"  // wallet balance of cm
       cmUnrealizedPNL: string,  // example: ""  // unrealized profit of cm
       updateTime: number,  // example: 1617939110373
       negativeBalance: NumberString  // example: "0"
     }[] | {  // OR (when symbol sent)
     asset: string,  // example: "USDT"  // asset name
     totalWalletBalance: NumberString,  // example: "122607.35137903"  // wallet balance =  cross margin free + cross margin locked + UM wallet balance + CM wallet balance
     crossMarginBorrowed: NumberString,  // example: "10.00000000"  // principal of cross margin
     crossMarginFree: NumberString,  // example: "100.00000000"  // free asset of cross margin
     crossMarginInterest: NumberString,  // example: "0.72469206"  // interest of cross margin
     crossMarginLocked: NumberString,  // example: "3.00000000"  //lock asset of cross margin
     umWalletBalance: NumberString,  // example: "0.00000000"  // wallet balance of um
     umUnrealizedPNL: NumberString,  // example: "23.72469206"  // unrealized profit of um
     cmWalletBalance: NumberString,  // example: "23.72469206"  // wallet balance of cm
     cmUnrealizedPNL: string,  // example: ""  // unrealized profit of cm
     updateTime: number,  // example: 1617939110373
     negativeBalance: NumberString  // example: "0"
    }>;
  
  
  papi_accountBalance(...args : any) {
      return this._sendRequest("/papi/v1/balance", "GET", "USER_DATA", true, args, ["asset", "recvWindow", "timestamp"], "papi_accountBalance");
  }
  
  
  /** Account Information(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#account-information-user_data}
   * 
   * Query account information
   * 
   * EndPoint: /papi/v1/account
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_accountInformation(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["papi_accountInformation"]>;
  
  
  /** Account Information(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#account-information-user_data}
   * 
   * Query account information
   * 
   * EndPoint: /papi/v1/account
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_accountInformation(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     uniMMR: NumberString,  // example: "5167.92171923"  // Portfolio margin account maintenance margin rate
     accountEquity: NumberString,  // example: "122607.35137903"  // Account equity, in USD value
     actualEquity: NumberString,  // example: "73.47428058"  //Account equity calculated without discount on collateral rate, in USD value
     accountInitialMargin: NumberString,  // example: "23.72469206"
     accountMaintMargin: NumberString,  // example: "23.72469206"  // Portfolio margin account maintenance margin, unit:USD
     accountStatus: string,  // example: "NORMAL"  // Portfolio margin account status:"NORMAL", "MARGIN_CALL", "SUPPLY_MARGIN", "REDUCE_ONLY", "ACTIVE_LIQUIDATION", "FORCE_LIQUIDATION", "BANKRUPTED"
     virtualMaxWithdrawAmount: NumberString,  // example: "1627523.32459208"  // Portfolio margin maximum amount for transfer out in USD
     totalAvailableBalance: string,  // example: ""
     totalMarginOpenLoss: string,  // example: ""  // in USD margin open order
     updateTime: number  // example: 1657707212154  // last update time
    }>;
  
  
  papi_accountInformation(...args : any) {
      return this._sendRequest("/papi/v1/account", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "papi_accountInformation");
  }
  
  
  /** Margin Max Borrow(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#margin-max-borrow-user_data}
   * 
   * Query margin max borrow
   * 
   * EndPoint: /papi/v1/margin/maxBorrowable
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} asset
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_marginMaxBorrow(asset :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_marginMaxBorrow"]>;
  
  
  /** Margin Max Borrow(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#margin-max-borrow-user_data}
   * 
   * Query margin max borrow
   * 
   * EndPoint: /papi/v1/margin/maxBorrowable
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.asset
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_marginMaxBorrow(options : { asset :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     amount: number,  // example: 125  // account's currently max borrowable amount with sufficient system availability
     borrowLimit: number  // example: 60  // max borrowable amount limited by the account level
    }>;
  
  
  papi_marginMaxBorrow(...args : any) {
      return this._sendRequest("/papi/v1/margin/maxBorrowable", "GET", "USER_DATA", true, args, ["asset", "recvWindow", "timestamp"], "papi_marginMaxBorrow");
  }
  
  
  /** Query Margin Max Withdraw(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-max-withdraw-user_data}
   * 
   * EndPoint: /papi/v1/margin/maxWithdraw
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} asset
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryMarginMaxWithdraw(asset :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryMarginMaxWithdraw"]>;
  
  
  /** Query Margin Max Withdraw(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-max-withdraw-user_data}
   * 
   * EndPoint: /papi/v1/margin/maxWithdraw
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.asset
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryMarginMaxWithdraw(options : { asset :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     amount: NumberString  // example: "60"
    }>;
  
  
  papi_queryMarginMaxWithdraw(...args : any) {
      return this._sendRequest("/papi/v1/margin/maxWithdraw", "GET", "USER_DATA", true, args, ["asset", "recvWindow", "timestamp"], "papi_queryMarginMaxWithdraw");
  }
  
  
  /** Query UM Position Information(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-um-position-information-user_data}
   * 
   * Get current UM position information.
   * 
   * EndPoint: /papi/v1/um/positionRisk
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryUMPositionInformation(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryUMPositionInformation"]>;
  
  
  /** Query UM Position Information(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-um-position-information-user_data}
   * 
   * Get current UM position information.
   * 
   * EndPoint: /papi/v1/um/positionRisk
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryUMPositionInformation(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  //  For One-way position mode(only return with position):
       entryPrice: NumberString,  // example: "0.00000"
       leverage: NumberString,  // example: "10"
       markPrice: NumberString,  // example: "6679.50671178"
       maxNotionalValue: NumberString,  // example: "20000000"
       positionAmt: NumberString,  // example: "0.000"
       notional: NumberString,  // example: "0"
       symbol: string,  // example: "BTCUSDT"
       unRealizedProfit: NumberString,  // example: "0.00000000"
       liquidationPrice: NumberString,  // example: "6170.20509059"
       positionSide: PositionSide,  // example: "BOTH"
       updateTime: number  // example: 1625474304765
     }[] | {  //  For Hedge position mode(only return with position):
       symbol: string,  // example: "BTCUSDT"
       positionAmt: NumberString,  // example: "0.001"
       entryPrice: NumberString,  // example: "22185.2"
       markPrice: NumberString,  // example: "21123.05052574"
       unRealizedProfit: NumberString,  // example: "-1.06214947"
       liquidationPrice: NumberString,  // example: "6170.20509059"
       leverage: NumberString,  // example: "4"
       maxNotionalValue: NumberString,  // example: "100000000"
       positionSide: PositionSide,  // example: "LONG"
       notional: NumberString,  // example: "21.12305052"
       updateTime: number  // example: 1655217461579
     }[]>;
  
  
  papi_queryUMPositionInformation(...args : any) {
      return this._sendRequest("/papi/v1/um/positionRisk", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "papi_queryUMPositionInformation");
  }
  
  
  /** Query CM Position Information(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-cm-position-information-user_data}
   * 
   * Get current CM position information.
   * 
   * EndPoint: /papi/v1/cm/positionRisk
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} marginAsset
   * @param {string} pair
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryCMPositionInformation(marginAsset? :string, pair? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryCMPositionInformation"]>;
  
  
  /** Query CM Position Information(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-cm-position-information-user_data}
   * 
   * Get current CM position information.
   * 
   * EndPoint: /papi/v1/cm/positionRisk
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.marginAsset
   * @param {string} options.pair
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryCMPositionInformation(options? : { marginAsset? :string, pair? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{  //  For One-way position mode:
       symbol: string,  // example: "BTCUSD_201225"
       positionAmt: NumberString,  // example: "1"
       entryPrice: NumberString,  // example: "11707.70000003"
       markPrice: NumberString,  // example: "11788.66626667"
       liquidationPrice: NumberString,  // example: "6170.20509059"
       unRealizedProfit: NumberString,  // example: "0.00005866"
       leverage: NumberString,  // example: "125"
       positionSide: PositionSide,  // example: "LONG"
       updateTime: number,  // example: 1627026881327
       maxQty: NumberString,  // example: "50"
       notionalValue: NumberString,  // example: "0.00084827"
       breakEvenPrice: NumberString  // example: "0.00000"
     }[] | {  //  For Hedge position mode(only return with position):
       symbol: string,  // example: "BTCUSD_201225"
       positionAmt: NumberString,  // example: "1"
       entryPrice: NumberString,  // example: "11707.70000003"
       markPrice: NumberString,  // example: "11788.66626667"
       unRealizedProfit: NumberString,  // example: "0.00005866"
       liquidationPrice: NumberString,  // example: "6170.20509059"
       leverage: NumberString,  // example: "125"
       positionSide: PositionSide,  // example: "LONG"
       updateTime: number,  // example: 1627026881327
       maxQty: NumberString,  // example: "50"
       notionalValue: NumberString,  // example: "0.00084827"
       breakEvenPrice: NumberString  // example: "0.00000"
     }[]>;
  
  
  papi_queryCMPositionInformation(...args : any) {
      return this._sendRequest("/papi/v1/cm/positionRisk", "GET", "USER_DATA", true, args, ["marginAsset", "pair", "recvWindow", "timestamp"], "papi_queryCMPositionInformation");
  }
  
  
  /** Change UM Initial Leverage (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#change-um-initial-leverage-trade}
   * 
   * Change user's initial leverage of specific symbol in UM.
   * 
   * EndPoint: /papi/v1/um/leverage
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {INT} leverage  -  target initial leverage: int from 1 to 125
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_changeUMInitialLeverage(symbol :string, leverage :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_changeUMInitialLeverage"]>;
  
  
  /** Change UM Initial Leverage (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#change-um-initial-leverage-trade}
   * 
   * Change user's initial leverage of specific symbol in UM.
   * 
   * EndPoint: /papi/v1/um/leverage
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {INT} options.leverage  -  target initial leverage: int from 1 to 125
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_changeUMInitialLeverage(options : { symbol :string, leverage :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     leverage: number,  // example: 21
     maxNotionalValue: NumberString,  // example: "1000000"
     symbol: string  // example: "BTCUSDT"
    }>;
  
  
  papi_changeUMInitialLeverage(...args : any) {
      return this._sendRequest("/papi/v1/um/leverage", "POST", "TRADE", true, args, ["symbol", "leverage", "recvWindow", "timestamp"], "papi_changeUMInitialLeverage");
  }
  
  
  /** Change CM Initial Leverage (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#change-cm-initial-leverage-trade}
   * 
   * Change user's initial leverage of specific symbol in CM.
   * 
   * EndPoint: /papi/v1/cm/leverage
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {INT} leverage  -  target initial leverage: int from 1 to 125
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_changeCMInitialLeverage(symbol :string, leverage :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_changeCMInitialLeverage"]>;
  
  
  /** Change CM Initial Leverage (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#change-cm-initial-leverage-trade}
   * 
   * Change user's initial leverage of specific symbol in CM.
   * 
   * EndPoint: /papi/v1/cm/leverage
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {INT} options.leverage  -  target initial leverage: int from 1 to 125
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_changeCMInitialLeverage(options : { symbol :string, leverage :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     leverage: number,  // example: 21
     maxQty: NumberString,  // example: "1000"
     symbol: string  // example: "BTCUSD_200925"
    }>;
  
  
  papi_changeCMInitialLeverage(...args : any) {
      return this._sendRequest("/papi/v1/cm/leverage", "POST", "TRADE", true, args, ["symbol", "leverage", "recvWindow", "timestamp"], "papi_changeCMInitialLeverage");
  }
  
  
  /** Change UM Position Mode(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#change-um-position-mode-trade}
   * 
   * Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
   * 
   * EndPoint: /papi/v1/um/positionSide/dual
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} dualSidePosition  -  "true": Hedge Mode; "false": One-way Mode
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_changeUMPositionMode(dualSidePosition :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_changeUMPositionMode"]>;
  
  
  /** Change UM Position Mode(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#change-um-position-mode-trade}
   * 
   * Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
   * 
   * EndPoint: /papi/v1/um/positionSide/dual
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.dualSidePosition  -  "true": Hedge Mode; "false": One-way Mode
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_changeUMPositionMode(options : { dualSidePosition :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "success"
    }>;
  
  
  papi_changeUMPositionMode(...args : any) {
      return this._sendRequest("/papi/v1/um/positionSide/dual", "POST", "TRADE", true, args, ["dualSidePosition", "recvWindow", "timestamp"], "papi_changeUMPositionMode");
  }
  
  
  /** Change CM Position Mode(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#change-cm-position-mode-trade}
   * 
   * Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
   * 
   * EndPoint: /papi/v1/cm/positionSide/dual
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} dualSidePosition  -  "true": Hedge Mode; "false": One-way Mode
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_changeCMPositionMode(dualSidePosition :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_changeCMPositionMode"]>;
  
  
  /** Change CM Position Mode(TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#change-cm-position-mode-trade}
   * 
   * Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
   * 
   * EndPoint: /papi/v1/cm/positionSide/dual
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.dualSidePosition  -  "true": Hedge Mode; "false": One-way Mode
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_changeCMPositionMode(options : { dualSidePosition :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     code: number,  // example: 200
     msg: string    // example: "success"
    }>;
  
  
  papi_changeCMPositionMode(...args : any) {
      return this._sendRequest("/papi/v1/cm/positionSide/dual", "POST", "TRADE", true, args, ["dualSidePosition", "recvWindow", "timestamp"], "papi_changeCMPositionMode");
  }
  
  
  /** Get UM Current Position Mode(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-um-current-position-mode-user_data}
   * 
   * Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
   * 
   * EndPoint: /papi/v1/um/positionSide/dual
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_getUMCurrentPositionMode(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_getUMCurrentPositionMode"]>;
  
  
  /** Get UM Current Position Mode(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-um-current-position-mode-user_data}
   * 
   * Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
   * 
   * EndPoint: /papi/v1/um/positionSide/dual
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_getUMCurrentPositionMode(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     dualSidePosition: boolean  // example: true  // "true": Hedge Mode; "false": One-way Mode
    }>;
  
  
  papi_getUMCurrentPositionMode(...args : any) {
      return this._sendRequest("/papi/v1/um/positionSide/dual", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "papi_getUMCurrentPositionMode");
  }
  
  
  /** Get CM Current Position Mode(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-cm-current-position-mode-user_data}
   * 
   * Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
   * 
   * EndPoint: /papi/v1/cm/positionSide/dual
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_getCMCurrentPositionMode(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_getCMCurrentPositionMode"]>;
  
  
  /** Get CM Current Position Mode(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-cm-current-position-mode-user_data}
   * 
   * Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
   * 
   * EndPoint: /papi/v1/cm/positionSide/dual
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_getCMCurrentPositionMode(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     dualSidePosition: boolean  // example: true  // "true": Hedge Mode; "false": One-way Mode
    }>;
  
  
  papi_getCMCurrentPositionMode(...args : any) {
      return this._sendRequest("/papi/v1/cm/positionSide/dual", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "papi_getCMCurrentPositionMode");
  }
  
  
  /** UM Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#um-account-trade-list-user_data}
   * 
   * Get trades for a specific account and UM symbol.
   * 
   * EndPoint: /papi/v1/um/userTrades
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {INT} orderId
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} fromId  -  Trade id to fetch from. Default gets most recent trades.
   * @param {INT} limit  -  Default 500; max 1000.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_umAccountTradeList(symbol :string, orderId? :INT, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_umAccountTradeList"]>;
  
  
  /** UM Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#um-account-trade-list-user_data}
   * 
   * Get trades for a specific account and UM symbol.
   * 
   * EndPoint: /papi/v1/um/userTrades
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {INT} options.orderId
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.fromId  -  Trade id to fetch from. Default gets most recent trades.
   * @param {INT} options.limit  -  Default 500; max 1000.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_umAccountTradeList(options : { symbol :string, orderId? :INT, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSDT"
       id: number,  // example: 67880589
       orderId: number,  // example: 270093109
       side: OrderSide,  // example: "SELL"
       price: NumberString,  // example: "28511.00"
       qty: NumberString,  // example: "0.010"
       realizedPnl: NumberString,  // example: "2.58500000"
       marginAsset: string,  // example: "USDT"
       quoteQty: NumberString,  // example: "285.11000"
       commission: NumberString,  // example: "-0.11404400"
       commissionAsset: string,  // example: "USDT"
       time: number,  // example: 1680688557875
       buyer: boolean,  // example: false
       maker: boolean,  // example: false
       positionSide: PositionSide  // example: "BOTH"
     }[]>;
  
  
  papi_umAccountTradeList(...args : any) {
      return this._sendRequest("/papi/v1/um/userTrades", "GET", "USER_DATA", true, args, ["symbol", "orderId", "startTime", "endTime", "fromId", "limit", "recvWindow", "timestamp"], "papi_umAccountTradeList");
  }
  
  
  /** CM Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cm-account-trade-list-user_data}
   * 
   * Get trades for a specific account and CM symbol.
   * 
   * EndPoint: /papi/v1/cm/userTrades
   * 
   * Weight(IP): 20 with symbol 40 with pair
   * 
   * @param {string} symbol
   * @param {string} pair
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} fromId  -  Trade id to fetch from. Default gets most recent trades.
   * @param {INT} limit  -  Default 50; max 1000.
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cmAccountTradeList(symbol? :string, pair? :string, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cmAccountTradeList"]>;
  
  
  /** CM Account Trade List (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cm-account-trade-list-user_data}
   * 
   * Get trades for a specific account and CM symbol.
   * 
   * EndPoint: /papi/v1/cm/userTrades
   * 
   * Weight(IP): 20 with symbol 40 with pair
   * 
   * @param {string} options.symbol
   * @param {string} options.pair
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.fromId  -  Trade id to fetch from. Default gets most recent trades.
   * @param {INT} options.limit  -  Default 50; max 1000.
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cmAccountTradeList(options? : { symbol? :string, pair? :string, startTime? :LONG, endTime? :LONG, fromId? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSD_200626"
       id: number,  // example: 6
       orderId: number,  // example: 28
       pair: string,  // example: "BTCUSD"
       side: OrderSide,  // example: "SELL"
       price: NumberString,  // example: "8800"
       qty: NumberString,  // example: "1"
       realizedPnl: NumberString,  // example: "0"
       marginAsset: string,  // example: "BTC"
       baseQty: NumberString,  // example: "0.01136364"
       commission: NumberString,  // example: "0.00000454"
       commissionAsset: string,  // example: "BTC"
       time: number,  // example: 1590743483586
       positionSide: PositionSide,  // example: "BOTH"
       buyer: boolean,  // example: false
       maker: boolean  // example: false
     }[]>;
  
  
  papi_cmAccountTradeList(...args : any) {
      return this._sendRequest("/papi/v1/cm/userTrades", "GET", "USER_DATA", false, args, ["symbol", "pair", "startTime", "endTime", "fromId", "limit", "recvWindow", "timestamp"], "papi_cmAccountTradeList");
  }
  
  
  /** UM Notional and Leverage Brackets (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#um-notional-and-leverage-brackets-user_data}
   * 
   * Query UM notional and leverage brackets
   * 
   * EndPoint: /papi/v1/um/leverageBracket
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_umNotionalAndLeverageBrackets(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_umNotionalAndLeverageBrackets"]>;
  
  
  /** UM Notional and Leverage Brackets (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#um-notional-and-leverage-brackets-user_data}
   * 
   * Query UM notional and leverage brackets
   * 
   * EndPoint: /papi/v1/um/leverageBracket
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_umNotionalAndLeverageBrackets(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "ETHUSDT"
       notionalCoef: NumberString,  // example: "4.0"
       brackets: {
           bracket: number,  // example: 1  // Notional bracket
           initialLeverage: number,  // example: 75  // Max initial leverage for this bracket
           notionalCap: number,  // example: 10000  // Cap notional of this bracket
           notionalFloor: number,  // example: 0  // Notional threshold of this bracket
           maintMarginRatio: number,  // example: 0.0065  // Maintenance ratio for this bracket
           cum: number  // example: 0  // Auxiliary number for quick calculation
         }[]
     }[]>;
  
  
  papi_umNotionalAndLeverageBrackets(...args : any) {
      return this._sendRequest("/papi/v1/um/leverageBracket", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "papi_umNotionalAndLeverageBrackets");
  }
  
  
  /** CM Notional and Leverage Brackets (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cm-notional-and-leverage-brackets-user_data}
   * 
   * Query CM notional and leverage brackets
   * 
   * EndPoint: /papi/v1/cm/leverageBracket
   * 
   * Weight(IP): 1
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cmNotionalAndLeverageBrackets(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cmNotionalAndLeverageBrackets"]>;
  
  
  /** CM Notional and Leverage Brackets (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cm-notional-and-leverage-brackets-user_data}
   * 
   * Query CM notional and leverage brackets
   * 
   * EndPoint: /papi/v1/cm/leverageBracket
   * 
   * Weight(IP): 1
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cmNotionalAndLeverageBrackets(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       symbol: string,  // example: "BTCUSD_PERP"
       notionalCoef: NumberString,  // example: "4.0"
       brackets: {
           bracket: number,  // example: 1  // bracket level
           initialLeverage: number,  // example: 125  // the maximum leverage
           qtyCap: number,  // example: 50  // upper edge of base asset quantity
           qtyFloor: number,  // example: 0  // lower edge of base asset quantity
           maintMarginRatio: number,  // example: 0.004  // maintenance margin rate
           cum: number  // example: 0  // Auxiliary number for quick calculation
         }[]
     }[]>;
  
  
  papi_cmNotionalAndLeverageBrackets(...args : any) {
      return this._sendRequest("/papi/v1/cm/leverageBracket", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "papi_cmNotionalAndLeverageBrackets");
  }
  
  
  /** Query User's Margin Force Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-user-39-s-margin-force-orders-user_data}
   * 
   * Query user's margin force orders
   * 
   * EndPoint: /papi/v1/margin/forceOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10 Max:100
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryUserSMarginForceOrders(startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryUserSMarginForceOrders"]>;
  
  
  /** Query User's Margin Force Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-user-39-s-margin-force-orders-user_data}
   * 
   * Query user's margin force orders
   * 
   * EndPoint: /papi/v1/margin/forceOrders
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryUserSMarginForceOrders(options? : { startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         avgPrice: NumberString,  // example: "0.00388359"
         executedQty: NumberString,  // example: "31.39000000"
         orderId: number,  // example: 180015097
         price: NumberString,  // example: "0.00388110"
         qty: NumberString,  // example: "31.39000000"
         side: OrderSide,  // example: "SELL"
         symbol: string,  // example: "BNBBTC"
         timeInForce: TimeInForce,  // example: "GTC"
         updatedTime: number  // example: 1558941374745
       }[],
     total: number  // example: 1
    }>;
  
  
  papi_queryUserSMarginForceOrders(...args : any) {
      return this._sendRequest("/papi/v1/margin/forceOrders", "GET", "USER_DATA", true, args, ["startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "papi_queryUserSMarginForceOrders");
  }
  
  
  /** Query User's UM Force Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-user-39-s-um-force-orders-user_data}
   * 
   * Query User's UM Force Orders
   * 
   * EndPoint: /papi/v1/um/forceOrders
   * 
   * Weight(IP): 20 with symbol, 50 without symbol
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {ENUM} autoCloseType  -  LIQUIDATION for liquidation orders, ADL for ADL orders.
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 50; max 100.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryUserSUMForceOrders(symbol? :string, autoCloseType? :ENUM, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryUserSUMForceOrders"]>;
  
  
  /** Query User's UM Force Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-user-39-s-um-force-orders-user_data}
   * 
   * Query User's UM Force Orders
   * 
   * EndPoint: /papi/v1/um/forceOrders
   * 
   * Weight(IP): 20 with symbol, 50 without symbol
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {ENUM} options.autoCloseType  -  LIQUIDATION for liquidation orders, ADL for ADL orders.
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 50; max 100.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryUserSUMForceOrders(options? : { symbol? :string, autoCloseType? :ENUM, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderId: number,  // example: 6071832819
       symbol: string,  // example: "BTCUSDT"
       status: string,  // example: "FILLED"
       clientOrderId: string,  // example: "autoclose-1596107620040000020"
       price: NumberString,  // example: "10871.09"
       avgPrice: NumberString,  // example: "10913.21000"
       origQty: NumberString,  // example: "0.001"
       executedQty: NumberString,  // example: "0.001"
       cumQuote: NumberString,  // example: "10.91321"
       timeInForce: TimeInForce,  // example: "IOC"
       type: OrderType,  // example: "LIMIT"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "SELL"
       positionSide: PositionSide,  // example: "BOTH"
       origType: string,  // example: "LIMIT"
       time: number,  // example: 1596107620044
       updateTime: number  // example: 1596107620087
     }[]>;
  
  
  papi_queryUserSUMForceOrders(...args : any) {
      return this._sendRequest("/papi/v1/um/forceOrders", "GET", "USER_DATA", true, args, ["symbol", "autoCloseType", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_queryUserSUMForceOrders");
  }
  
  
  /** Query User's CM Force Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-user-39-s-cm-force-orders-user_data}
   * 
   * Query User's CM Force Orders
   * 
   * EndPoint: /papi/v1/cm/forceOrders
   * 
   * Weight(IP): 20 with symbol, 50 without symbol
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {ENUM} autoCloseType  -  "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {INT} limit  -  Default 50; max 100.
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryUserSCMForceOrders(symbol? :string, autoCloseType? :ENUM, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryUserSCMForceOrders"]>;
  
  
  /** Query User's CM Force Orders (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-user-39-s-cm-force-orders-user_data}
   * 
   * Query User's CM Force Orders
   * 
   * EndPoint: /papi/v1/cm/forceOrders
   * 
   * Weight(IP): 20 with symbol, 50 without symbol
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {ENUM} options.autoCloseType  -  "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {INT} options.limit  -  Default 50; max 100.
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryUserSCMForceOrders(options? : { symbol? :string, autoCloseType? :ENUM, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       orderId: number,  // example: 165123080
       symbol: string,  // example: "BTCUSD_200925"
       pair: string,  // example: "BTCUSD"
       status: string,  // example: "FILLED"
       clientOrderId: string,  // example: "autoclose-1596542005017000006"
       price: NumberString,  // example: "11326.9"
       avgPrice: NumberString,  // example: "11326.9"
       origQty: NumberString,  // example: "1"
       executedQty: NumberString,  // example: "1"
       cumBase: NumberString,  // example: "0.00882854"
       timeInForce: TimeInForce,  // example: "IOC"
       type: OrderType,  // example: "LIMIT"
       reduceOnly: boolean,  // example: false
       side: OrderSide,  // example: "SELL"
       positionSide: PositionSide,  // example: "BOTH"
       origType: string,  // example: "LIMIT"
       time: number,  // example: 1596542005019
       updateTime: number  // example: 1596542005050
     }[]>;
  
  
  papi_queryUserSCMForceOrders(...args : any) {
      return this._sendRequest("/papi/v1/cm/forceOrders", "GET", "USER_DATA", true, args, ["symbol", "autoCloseType", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_queryUserSCMForceOrders");
  }
  
  
  /** Portfolio Margin UM Trading Quantitative Rules Indicators (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#portfolio-margin-um-trading-quantitative-rules-indicators-user_data}
   * 
   * Or (account violation triggered)
   * 
   * EndPoint: /papi/v1/um/apiTradingStatus
   * 
   * Weight(IP): 
   *   1 for a single symbol
   *   10 when the symbol parameter is omitted
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_portfolioMarginUMTradingQuantitativeRulesIndicators(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_portfolioMarginUMTradingQuantitativeRulesIndicators"]>;
  
  
  /** Portfolio Margin UM Trading Quantitative Rules Indicators (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#portfolio-margin-um-trading-quantitative-rules-indicators-user_data}
   * 
   * Or (account violation triggered)
   * 
   * EndPoint: /papi/v1/um/apiTradingStatus
   * 
   * Weight(IP): 
   *   1 for a single symbol
   *   10 when the symbol parameter is omitted
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_portfolioMarginUMTradingQuantitativeRulesIndicators(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     indicators: {
       BTCUSDT: {
           isLocked: boolean,  // example: true
           plannedRecoverTime: number,  // example: 1545741270000
           indicator: string,  // example: "UFR"  // Unfilled Ratio (UFR)
           value: number,  // example: 0.05  // Current value
           triggerValue: number  // example: 0.995  // Trigger value
         }[]
     },
     updateTime: number  // example: 1545741270000
    }>;
  
  
  papi_portfolioMarginUMTradingQuantitativeRulesIndicators(...args : any) {
      return this._sendRequest("/papi/v1/um/apiTradingStatus", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "papi_portfolioMarginUMTradingQuantitativeRulesIndicators");
  }
  
  
  /** Get User Commission Rate for UM (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-user-commission-rate-for-um-user_data}
   * 
   * EndPoint: /papi/v1/um/commissionRate
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_getUserCommissionRateForUM(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_getUserCommissionRateForUM"]>;
  
  
  /** Get User Commission Rate for UM (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-user-commission-rate-for-um-user_data}
   * 
   * EndPoint: /papi/v1/um/commissionRate
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_getUserCommissionRateForUM(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "BTCUSDT"
     makerCommissionRate: NumberString,  // example: "0.0002"  // 0.02%
     takerCommissionRate: NumberString  // example: "0.0004"  // 0.04%
    }>;
  
  
  papi_getUserCommissionRateForUM(...args : any) {
      return this._sendRequest("/papi/v1/um/commissionRate", "GET", "USER_DATA", true, args, ["symbol", "recvWindow", "timestamp"], "papi_getUserCommissionRateForUM");
  }
  
  
  /** Get User Commission Rate for CM (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-user-commission-rate-for-cm-user_data}
   * 
   * EndPoint: /papi/v1/cm/commissionRate
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_getUserCommissionRateForCM(symbol :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_getUserCommissionRateForCM"]>;
  
  
  /** Get User Commission Rate for CM (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-user-commission-rate-for-cm-user_data}
   * 
   * EndPoint: /papi/v1/cm/commissionRate
   * 
   * Weight(IP): 20
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_getUserCommissionRateForCM(options : { symbol :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     symbol: string,  // example: "BTCUSD_PERP"
     makerCommissionRate: NumberString,  // example: "0.00015"  // 0.015%
     takerCommissionRate: NumberString  // example: "0.00040"  // 0.040%
    }>;
  
  
  papi_getUserCommissionRateForCM(...args : any) {
      return this._sendRequest("/papi/v1/cm/commissionRate", "GET", "USER_DATA", true, args, ["symbol", "recvWindow", "timestamp"], "papi_getUserCommissionRateForCM");
  }
  
  
  /** Query Margin Loan Record(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-loan-record-user_data}
   * 
   * Query margin loan record
   * 
   * EndPoint: /papi/v1/margin/marginLoan
   * 
   * Weight(IP): 10
   * 
   * @param {string} asset
   * @param {LONG} txId  -  the tranId in POST/papi/v1/marginLoan
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10 Max:100
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryMarginLoanRecord(asset :string, txId? :LONG, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryMarginLoanRecord"]>;
  
  
  /** Query Margin Loan Record(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-loan-record-user_data}
   * 
   * Query margin loan record
   * 
   * EndPoint: /papi/v1/margin/marginLoan
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.asset
   * @param {LONG} options.txId  -  the tranId in POST/papi/v1/marginLoan
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryMarginLoanRecord(options : { asset :string, txId? :LONG, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         txId: number,  // example: 12807067523
         asset: string,  // example: "BNB"
         principal: NumberString,  // example: "0.84624403"
         timestamp: number,  // example: 1555056425000
         status: string  // example: "CONFIRMED"  //one of PENDING (pending execution), CONFIRMED (successfully loaned), FAILED (execution failed, nothing happened to your account);
       }[],
     total: number  // example: 1
    }>;
  
  
  papi_queryMarginLoanRecord(...args : any) {
      return this._sendRequest("/papi/v1/margin/marginLoan", "GET", "USER_DATA", false, args, ["asset", "txId", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "papi_queryMarginLoanRecord");
  }
  
  
  /** Query Margin repay Record(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-repay-record-user_data}
   * 
   * Query margin repay record.
   * 
   * EndPoint: /papi/v1/margin/repayLoan
   * 
   * Weight(IP): 10
   * 
   * @param {string} asset
   * @param {LONG} txId  -  the tranId in POST/papi/v1/repayLoan
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10 Max:100
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_queryMarginRepayRecord(asset :string, txId? :LONG, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryMarginRepayRecord"]>;
  
  
  /** Query Margin repay Record(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-margin-repay-record-user_data}
   * 
   * Query margin repay record.
   * 
   * EndPoint: /papi/v1/margin/repayLoan
   * 
   * Weight(IP): 10
   * 
   * @param {string} options.asset
   * @param {LONG} options.txId  -  the tranId in POST/papi/v1/repayLoan
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_queryMarginRepayRecord(options : { asset :string, txId? :LONG, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         amount: NumberString,  // example: "14.00000000"  //Total amount repaid
         asset: string,  // example: "BNB"
         interest: NumberString,  // example: "0.01866667"  //Interest repaid
         principal: NumberString,  // example: "13.98133333"  //Principal repaid
         status: string,  // example: "CONFIRMED"  //one of PENDING (pending execution), CONFIRMED (successfully execution), FAILED (execution failed, nothing happened to your account)
         timestamp: number,  // example: 1563438204000
         txId: number  // example: 2970933056
       }[],
     total: number  // example: 1
    }>;
  
  
  papi_queryMarginRepayRecord(...args : any) {
      return this._sendRequest("/papi/v1/margin/repayLoan", "GET", "USER_DATA", false, args, ["asset", "txId", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "papi_queryMarginRepayRecord");
  }
  
  
  /** Get Margin Borrow/Loan Interest History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-margin-borrow-loan-interest-history-user_data}
   * 
   * EndPoint: /papi/v1/margin/marginInterestHistory
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} size  -  Default:10 Max:100
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_getMarginBorrowLoanInterestHistory(asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_getMarginBorrowLoanInterestHistory"]>;
  
  
  /** Get Margin Borrow/Loan Interest History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-margin-borrow-loan-interest-history-user_data}
   * 
   * EndPoint: /papi/v1/margin/marginInterestHistory
   * 
   * Weight(IP): 1
   * 
   * HMAC SHA256
   * 
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.current  -  Currently querying page. Start from 1. Default:1
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_getMarginBorrowLoanInterestHistory(options? : { asset? :string, startTime? :LONG, endTime? :LONG, current? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     rows: {
         txId: number,  // example: 1352286576452864800
         interestAccuredTime: number,  // example: 1672160400000
         asset: string,  // example: "USDT"
         rawAsset: string,  // example: "USDT"
         principal: NumberString,  // example: "45.3313"
         interest: NumberString,  // example: "0.00024995"
         interestRate: NumberString,  // example: "0.00013233"
         type: string  // example: "ON_BORROW"
       }[],
     total: number  // example: 1
    }>;
  
  
  papi_getMarginBorrowLoanInterestHistory(...args : any) {
      return this._sendRequest("/papi/v1/margin/marginInterestHistory", "GET", "USER_DATA", true, args, ["asset", "startTime", "endTime", "current", "size", "recvWindow", "timestamp"], "papi_getMarginBorrowLoanInterestHistory");
  }
  
  
  /** Query Portfolio Margin Negative Balance Interest History(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-portfolio-margin-negative-balance-interest-history-user_data}
   * 
   * Query interest history of negative balance for portfolio margin.
   * 
   * EndPoint: /papi/v1/portfolio/interest-history
   * 
   * Weight(IP): 50
   * 
   * @param {string} asset
   * @param {LONG} startTime
   * @param {LONG} endTime
   * @param {LONG} size  -  Default:10 Max:100
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_queryPortfolioMarginNegativeBalanceInterestHistory(asset? :string, startTime? :LONG, endTime? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_queryPortfolioMarginNegativeBalanceInterestHistory"]>;
  
  
  /** Query Portfolio Margin Negative Balance Interest History(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#query-portfolio-margin-negative-balance-interest-history-user_data}
   * 
   * Query interest history of negative balance for portfolio margin.
   * 
   * EndPoint: /papi/v1/portfolio/interest-history
   * 
   * Weight(IP): 50
   * 
   * @param {string} options.asset
   * @param {LONG} options.startTime
   * @param {LONG} options.endTime
   * @param {LONG} options.size  -  Default:10 Max:100
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_queryPortfolioMarginNegativeBalanceInterestHistory(options? : { asset? :string, startTime? :LONG, endTime? :LONG, size? :LONG, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
       asset: string,  // example: "USDT"
       interest: NumberString,  // example: "24.4440"  //interest amount
       interestAccuredTime: number,  // example: 1670227200000
       interestRate: NumberString,  // example: "0.0001164"  //daily interest rate
       principal: NumberString  // example: "210000"
     }[]>;
  
  
  papi_queryPortfolioMarginNegativeBalanceInterestHistory(...args : any) {
      return this._sendRequest("/papi/v1/portfolio/interest-history", "GET", "USER_DATA", false, args, ["asset", "startTime", "endTime", "size", "recvWindow", "timestamp"], "papi_queryPortfolioMarginNegativeBalanceInterestHistory");
  }
  
  
  /** Fund Auto-collection (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#fund-auto-collection-trade}
   * 
   * Fund collection for Portfolio Margin
   * 
   * EndPoint: /papi/v1/auto-collection
   * 
   * Weight(IP): 750
   * 
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_fundAutoCollection(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["papi_fundAutoCollection"]>;
  
  
  /** Fund Auto-collection (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#fund-auto-collection-trade}
   * 
   * Fund collection for Portfolio Margin
   * 
   * EndPoint: /papi/v1/auto-collection
   * 
   * Weight(IP): 750
   * 
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_fundAutoCollection(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     msg: string  // example: "success"
    }>;
  
  
  papi_fundAutoCollection(...args : any) {
      return this._sendRequest("/papi/v1/auto-collection", "POST", "TRADE", false, args, ["recvWindow", "timestamp"], "papi_fundAutoCollection");
  }
  
  
  /** Fund Collection by Asset (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#fund-collection-by-asset-trade}
   * 
   * Transfers specific asset from Futures Account to Margin account
   * 
   * EndPoint: /papi/v1/asset-collection
   * 
   * Weight(IP): 30
   * 
   * @param {string} asset
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_fundCollectionByAsset(asset :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_fundCollectionByAsset"]>;
  
  
  /** Fund Collection by Asset (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#fund-collection-by-asset-trade}
   * 
   * Transfers specific asset from Futures Account to Margin account
   * 
   * EndPoint: /papi/v1/asset-collection
   * 
   * Weight(IP): 30
   * 
   * @param {string} options.asset
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_fundCollectionByAsset(options : { asset :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     msg: string  // example: "success"
    }>;
  
  
  papi_fundCollectionByAsset(...args : any) {
      return this._sendRequest("/papi/v1/asset-collection", "POST", "TRADE", false, args, ["asset", "recvWindow", "timestamp"], "papi_fundCollectionByAsset");
  }
  
  
  /** BNB transfer (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#bnb-transfer-trade}
   * 
   * EndPoint: /papi/v1/bnb-transfer
   * 
   * Weight(IP): 750
   * 
   * @param {DECIMAL} amount
   * @param {"TO_UM"|"FROM_UM"} transferSide  -  "TO_UM","FROM_UM"
   * @param {LONG} recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} timestamp
   */
  papi_bnBTransfer(amount :DECIMAL, transferSide :"TO_UM"|"FROM_UM", recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_bnBTransfer"]>;
  
  
  /** BNB transfer (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#bnb-transfer-trade}
   * 
   * EndPoint: /papi/v1/bnb-transfer
   * 
   * Weight(IP): 750
   * 
   * @param {DECIMAL} options.amount
   * @param {"TO_UM"|"FROM_UM"} options.transferSide  -  "TO_UM","FROM_UM"
   * @param {LONG} options.recvWindow  -  The value cannot be greater than 60000
   * @param {LONG} options.timestamp
   */
  papi_bnBTransfer(options : { amount :DECIMAL, transferSide :"TO_UM"|"FROM_UM", recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     tranId: number  // example: 100000001  //transaction id
    }>;
  
  
  papi_bnBTransfer(...args : any) {
      return this._sendRequest("/papi/v1/bnb-transfer", "POST", "TRADE", false, args, ["amount", "transferSide", "recvWindow", "timestamp"], "papi_bnBTransfer");
  }
  
  
  /** Get UM Income History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-um-income-history-user_data}
   * 
   * EndPoint: /papi/v1/um/income
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {string} incomeType  -  TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
   * @param {LONG} startTime  -  Timestamp in ms to get funding from INCLUSIVE.
   * @param {LONG} endTime  -  Timestamp in ms to get funding until INCLUSIVE.
   * @param {INT} limit  -  Default 100; max 1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_getUMIncomeHistory(symbol? :string, incomeType? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_getUMIncomeHistory"]>;
  
  
  /** Get UM Income History (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-um-income-history-user_data}
   * 
   * EndPoint: /papi/v1/um/income
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {string} options.incomeType  -  TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
   * @param {LONG} options.startTime  -  Timestamp in ms to get funding from INCLUSIVE.
   * @param {LONG} options.endTime  -  Timestamp in ms to get funding until INCLUSIVE.
   * @param {INT} options.limit  -  Default 100; max 1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_getUMIncomeHistory(options? : { symbol? :string, incomeType? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: ""  // trade symbol, if existing
       incomeType: string,  // example: "TRANSFER"  // income type
       income: NumberString,  // example: "-0.37500000"  // income amount
       asset: string,  // example: "USDT"  // income asset
       info: string,  // example: "TRANSFER"  // extra information
       time: number,  // example: 1570608000000
       tranId: NumberString,  // example: "9689322392"  // transaction id
       tradeId: string  // example: ""  // trade id, if existing
     } |
     {
       symbol: string,  // example: "BTCUSDT"
       incomeType: string,  // example: "COMMISSION"
       income: NumberString,  // example: "-0.01000000"
       asset: string,  // example: "USDT"
       info: string,  // example: "COMMISSION"
       time: number,  // example: 1570636800000
       tranId: NumberString,  // example: "9689322392"
       tradeId: NumberString  // example: "2059192"
     }
    )[]>;
  
  
  papi_getUMIncomeHistory(...args : any) {
      return this._sendRequest("/papi/v1/um/income", "GET", "USER_DATA", true, args, ["symbol", "incomeType", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_getUMIncomeHistory");
  }
  
  
  /** Get CM Income History(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-cm-income-history-user_data}
   * 
   * EndPoint: /papi/v1/cm/income
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {string} symbol
   * @param {string} incomeType  -  "TRANSFER","WELCOME_BONUS", "FUNDING_FEE", "REALIZED_PNL", "COMMISSION", "INSURANCE_CLEAR", and "DELIVERED_SETTELMENT"
   * @param {LONG} startTime  -  Timestamp in ms to get funding from INCLUSIVE.
   * @param {LONG} endTime  -  Timestamp in ms to get funding until INCLUSIVE.
   * @param {INT} limit  -  Default 100; max 1000
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_getCMIncomeHistory(symbol? :string, incomeType? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_getCMIncomeHistory"]>;
  
  
  /** Get CM Income History(USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-cm-income-history-user_data}
   * 
   * EndPoint: /papi/v1/cm/income
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {string} options.symbol
   * @param {string} options.incomeType  -  "TRANSFER","WELCOME_BONUS", "FUNDING_FEE", "REALIZED_PNL", "COMMISSION", "INSURANCE_CLEAR", and "DELIVERED_SETTELMENT"
   * @param {LONG} options.startTime  -  Timestamp in ms to get funding from INCLUSIVE.
   * @param {LONG} options.endTime  -  Timestamp in ms to get funding until INCLUSIVE.
   * @param {INT} options.limit  -  Default 100; max 1000
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_getCMIncomeHistory(options? : { symbol? :string, incomeType? :string, startTime? :LONG, endTime? :LONG, limit? :INT, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: ""  // trade symbol, if existing
       incomeType: string,  // example: "TRANSFER"  // income type
       income: NumberString,  // example: "-0.37500000"  // income amount
       asset: string,  // example: "BTC"  // income asset
       info: string,  // example: "WITHDRAW"  // extra information
       time: number,  // example: 1570608000000
       tranId: NumberString,  // example: "9689322392"  // transaction id
       tradeId: string  // example: ""  // trade id, if existing
     } |
     {
       symbol: string,  // example: "BTCUSD_200925"
       incomeType: string,  // example: "COMMISSION"
       income: NumberString,  // example: "-0.01000000"
       asset: string,  // example: "BTC"
       info: string,  // example: ""
       time: number,  // example: 1570636800000
       tranId: NumberString,  // example: "9689322392"
       tradeId: NumberString  // example: "2059192"
     }
    )[]>;
  
  
  papi_getCMIncomeHistory(...args : any) {
      return this._sendRequest("/papi/v1/cm/income", "GET", "USER_DATA", true, args, ["symbol", "incomeType", "startTime", "endTime", "limit", "recvWindow", "timestamp"], "papi_getCMIncomeHistory");
  }
  
  
  /** Get UM Account Detail (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-um-account-detail-user_data}
   * 
   * Get current UM account asset and position information.
   * 
   * EndPoint: /papi/v1/um/account
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_getUMAccountDetail(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["papi_getUMAccountDetail"]>;
  
  
  /** Get UM Account Detail (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-um-account-detail-user_data}
   * 
   * Get current UM account asset and position information.
   * 
   * EndPoint: /papi/v1/um/account
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_getUMAccountDetail(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     tradeGroupId: number,  // example: -1
     assets: {
         asset: string,  // example: "USDT"  // asset name
         crossWalletBalance: NumberString,  // example: "23.72469206"  // wallet balance
         crossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit
         maintMargin: NumberString,  // example: "0.00000000"  // maintenance margin required
         initialMargin: NumberString,  // example: "0.00000000"  // total initial margin required with current mark price
         positionInitialMargin: NumberString,  // example: "0.00000000"  //initial margin required for positions with current mark price
         openOrderInitialMargin: NumberString,  // example: "0.00000000"  // initial margin required for open orders with current mark price
         updateTime: number  // example: 1625474304765  // last update time
       }[],
     positions: {
         symbol: string,  // example: "BTCUSDT"  // symbol name
         initialMargin: NumberString,  // example: "0"  // initial margin required with current mark price
         maintMargin: NumberString,  // example: "0"  // maintenance margin required
         unrealizedProfit: NumberString,  // example: "0.00000000"  // unrealized profit
         positionInitialMargin: NumberString,  // example: "0"  // initial margin required for positions with current mark price
         openOrderInitialMargin: NumberString,  // example: "0"  // initial margin required for open orders with current mark price
         leverage: NumberString,  // example: "100"  // current initial leverage
         entryPrice: NumberString,  // example: "0.00000"  // average entry price
         maxNotional: NumberString,  // example: "250000"  // maximum available notional with current leverage
         bidNotional: NumberString,  // example: "0"  // bids notional, ignore
         askNotional: NumberString,  // example: "0"  // ask notional, ignore
         positionSide: PositionSide,  // example: "BOTH"  // position side
         positionAmt: NumberString,  // example: "0"  // position amount
         updateTime: number,  // example: 0  // last update time
         breakEvenPrice: NumberString  // example: "0.0"
       }[]
    }>;
  
  
  papi_getUMAccountDetail(...args : any) {
      return this._sendRequest("/papi/v1/um/account", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "papi_getUMAccountDetail");
  }
  
  
  /** Get CM Account Detail (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-cm-account-detail-user_data}
   * 
   * Get current CM account asset and position information.
   * 
   * EndPoint: /papi/v1/cm/account
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_getCMAccountDetail(recvWindow? :LONG, timestamp? :LONG)  : ReturnType<MyBinanceClient["papi_getCMAccountDetail"]>;
  
  
  /** Get CM Account Detail (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-cm-account-detail-user_data}
   * 
   * Get current CM account asset and position information.
   * 
   * EndPoint: /papi/v1/cm/account
   * 
   * Weight(IP): 5
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_getCMAccountDetail(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     assets: {
         asset: string,  // example: "BTC"  // asset name
         crossWalletBalance: NumberString,  // example: "0.00241969"  // total wallet balance
         crossUnPnl: NumberString,  // example: "0.00000000"  // unrealized profit or loss
         maintMargin: NumberString,  // example: "0.00000000"  // maintenance margin
         initialMargin: NumberString,  // example: "0.00000000"  // total intial margin required with the latest mark price
         positionInitialMargin: NumberString,  // example: "0.00000000"  // positions" margin required with the latest mark price
         openOrderInitialMargin: NumberString,  // example: "0.00000000"  // open orders" intial margin required with the latest mark price
         updateTime: number  // example: 1625474304765  // last update time
       }[],
     positions: {
         symbol: string,  // example: "BTCUSD_201225"
         positionAmt: NumberString,  // example: "0"  // position amount
         initialMargin: NumberString,  // example: "0"
         maintMargin: NumberString,  // example: "0"
         unrealizedProfit: NumberString,  // example: "0.00000000"
         positionInitialMargin: NumberString,  // example: "0"
         openOrderInitialMargin: NumberString,  // example: "0"
         leverage: NumberString,  // example: "125"
         positionSide: PositionSide,  // example: "BOTH"  // BOTH means that it is the position of One-way Mode
         entryPrice: NumberString,  // example: "0.0"
         maxQty: NumberString,  // example: "50"  // maximum quantity of base asset
         updateTime: number,  // example: 0
         breakEvenPrice: NumberString  // example: "0.0"
       }[]
    }>;
  
  
  papi_getCMAccountDetail(...args : any) {
      return this._sendRequest("/papi/v1/cm/account", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "papi_getCMAccountDetail");
  }
  
  
  /** Change Auto-repay-futures Status (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#change-auto-repay-futures-status-trade}
   * 
   * Change Auto-repay-futures Status
   * 
   * EndPoint: /papi/v1/repay-futures-switch
   * 
   * Weight(IP): 750
   * 
   * HMAC SHA256
   * 
   * @param {string} autoRepay  -  Default: true; false for turn off the auto-repay futures negative balance function
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_changeAutoRepayFuturesStatus(autoRepay :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_changeAutoRepayFuturesStatus"]>;
  
  
  /** Change Auto-repay-futures Status (TRADE)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#change-auto-repay-futures-status-trade}
   * 
   * Change Auto-repay-futures Status
   * 
   * EndPoint: /papi/v1/repay-futures-switch
   * 
   * Weight(IP): 750
   * 
   * HMAC SHA256
   * 
   * @param {string} options.autoRepay  -  Default: true; false for turn off the auto-repay futures negative balance function
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_changeAutoRepayFuturesStatus(options : { autoRepay :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     msg: string  // example: "success"
    }>;
  
  
  papi_changeAutoRepayFuturesStatus(...args : any) {
      return this._sendRequest("/papi/v1/repay-futures-switch", "POST", "TRADE", true, args, ["autoRepay", "recvWindow", "timestamp"], "papi_changeAutoRepayFuturesStatus");
  }
  
  
  /** Get Auto-repay-futures Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-auto-repay-futures-status-user_data}
   * 
   * Query Auto-repay-futures Status
   * 
   * EndPoint: /papi/v1/repay-futures-switch
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_getAutoRepayFuturesStatus(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_getAutoRepayFuturesStatus"]>;
  
  
  /** Get Auto-repay-futures Status (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#get-auto-repay-futures-status-user_data}
   * 
   * Query Auto-repay-futures Status
   * 
   * EndPoint: /papi/v1/repay-futures-switch
   * 
   * Weight(IP): 30
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_getAutoRepayFuturesStatus(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     autoRepay: boolean  // example: true  //  "true" for turn on the auto-repay futures; "false" for turn off the auto-repay futures
    }>;
  
  
  papi_getAutoRepayFuturesStatus(...args : any) {
      return this._sendRequest("/papi/v1/repay-futures-switch", "GET", "USER_DATA", true, args, ["recvWindow", "timestamp"], "papi_getAutoRepayFuturesStatus");
  }
  
  
  /** Repay futures Negative Balance (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#repay-futures-negative-balance-user_data}
   * 
   * Repay futures Negative Balance
   * 
   * EndPoint: /papi/v1/repay-futures-negative-balance
   * 
   * Weight(IP): 750
   * 
   * HMAC SHA256
   * 
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_repayFuturesNegativeBalance(recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_repayFuturesNegativeBalance"]>;
  
  
  /** Repay futures Negative Balance (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#repay-futures-negative-balance-user_data}
   * 
   * Repay futures Negative Balance
   * 
   * EndPoint: /papi/v1/repay-futures-negative-balance
   * 
   * Weight(IP): 750
   * 
   * HMAC SHA256
   * 
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_repayFuturesNegativeBalance(options? : { recvWindow? :LONG, timestamp? :LONG })
  : Promise<{
     msg: string  // example: "success"
    }>;
  
  
  papi_repayFuturesNegativeBalance(...args : any) {
      return this._sendRequest("/papi/v1/repay-futures-negative-balance", "POST", "USER_DATA", true, args, ["recvWindow", "timestamp"], "papi_repayFuturesNegativeBalance");
  }
  
  
  /** UM Position ADL Quantile Estimation (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#um-position-adl-quantile-estimation-user_data}
   * 
   * EndPoint: /papi/v1/um/adlQuantile
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_umPositionADLQuantileEstimation(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_umPositionADLQuantileEstimation"]>;
  
  
  /** UM Position ADL Quantile Estimation (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#um-position-adl-quantile-estimation-user_data}
   * 
   * EndPoint: /papi/v1/um/adlQuantile
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_umPositionADLQuantileEstimation(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: "ETHUSDT"
       adlQuantile: {
         LONG: number,   // example: 3
         SHORT: number,  // example: 3
         HEDGE: number   // example: 0  // only a sign, ignore the value
       }
     } |
     {
       symbol: string,  // example: "BTCUSDT"
       adlQuantile: {
         LONG: number,   // example: 1  // adl quantile for "LONG" position in hedge mode
         SHORT: number,  // example: 2  // adl qauntile for "SHORT" position in hedge mode
         BOTH: number    // example: 0  // adl qunatile for position in one-way mode
       }
     }
    )[]>;
  
  
  papi_umPositionADLQuantileEstimation(...args : any) {
      return this._sendRequest("/papi/v1/um/adlQuantile", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "papi_umPositionADLQuantileEstimation");
  }
  
  
  /** CM Position ADL Quantile Estimation (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cm-position-adl-quantile-estimation-user_data}
   * 
   * EndPoint: /papi/v1/cm/adlQuantile
   * 
   * Weight(IP): 5
   * 
   * @param {string} symbol
   * @param {LONG} recvWindow
   * @param {LONG} timestamp
   */
  papi_cmPositionADLQuantileEstimation(symbol? :string, recvWindow? :LONG, timestamp? :LONG)
  : ReturnType<MyBinanceClient["papi_cmPositionADLQuantileEstimation"]>;
  
  
  /** CM Position ADL Quantile Estimation (USER_DATA)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#cm-position-adl-quantile-estimation-user_data}
   * 
   * EndPoint: /papi/v1/cm/adlQuantile
   * 
   * Weight(IP): 5
   * 
   * @param {string} options.symbol
   * @param {LONG} options.recvWindow
   * @param {LONG} options.timestamp
   */
  papi_cmPositionADLQuantileEstimation(options? : { symbol? :string, recvWindow? :LONG, timestamp? :LONG })
  : Promise<(
     {
       symbol: string,  // example: "BTCUSD_200925"
       adlQuantile: {
         LONG: number,   // example: 3
         SHORT: number,  // example: 3
         HEDGE: number   // example: 0  // only a sign, ignore the value
       }
     } |
     {
       symbol: string,  // example: "BTCUSD_201225"
       adlQuantile: {
         LONG: number,   // example: 1  // adl quantile for "LONG" position in hedge mode
         SHORT: number,  // example: 2  // adl qauntile for "SHORT" position in hedge mode
         BOTH: number    // example: 0  // adl qunatile for position in one-way mode
       }
     }
    )[]>;
  
  
  papi_cmPositionADLQuantileEstimation(...args : any) {
      return this._sendRequest("/papi/v1/cm/adlQuantile", "GET", "USER_DATA", false, args, ["symbol", "recvWindow", "timestamp"], "papi_cmPositionADLQuantileEstimation");
  }
  
  
  
  //***** User Data Streams *****
  
  
  /** Start User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#start-user-data-stream-user_stream}
   * 
   * EndPoint: /papi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  papi_startUserDataStream() : Promise<{
     listenKey: string  // example: "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
    }> {
      return this._sendRequest("/papi/v1/listenKey", "POST", "USER_STREAM", false, [], [], "papi_startUserDataStream");
  }
  
  
  /** Keepalive User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#keepalive-user-data-stream-user_stream}
   * 
   * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 60 minutes.
   * 
   * EndPoint: /papi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  papi_keepaliveUserDataStream() : Promise<{
    }> {
      return this._sendRequest("/papi/v1/listenKey", "PUT", "USER_STREAM", false, [], [], "papi_keepaliveUserDataStream");
  }
  
  
  /** Close User Data Stream (USER_STREAM)
   * 
   * {@link https://binance-docs.github.io/apidocs/pm/en#close-user-data-stream-user_stream}
   * 
   * Close out a user data stream.
   * 
   * EndPoint: /papi/v1/listenKey
   * 
   * Weight(IP): 1
   * 
   */
  papi_closeUserDataStream() : Promise<{
    }> {
      return this._sendRequest("/papi/v1/listenKey", "DELETE", "USER_STREAM", false, [], [], "papi_closeUserDataStream");
  }
  

  static getWeight<TFunc extends BinanceFunctionName> (functionName :TFunc, ...params : Parameters<MyBinanceClient[TFunc]> & [QueryStruct]) : WeightVal;
  static getWeight<TFunc extends BinanceFunctionName> (functionName :TFunc, ...params : Parameters<MyBinanceClient[TFunc]> & undefined[]) : WeightVal;

  static getWeight<TFunc extends BinanceFunctionName> (functionName :TFunc, params : Extract<Parameters<MyBinanceClient[TFunc]>[0], QueryStruct>)
  {
    return getWeight(this.weights, functionName, params) ?? (()=>{throw new Error("Wrong function name: "+functionName)})();
  }

  getWeight<TFunc extends BinanceFunctionName> (functionName :TFunc, ...params : Parameters<MyBinanceClient[TFunc]> & [QueryStruct]) : WeightVal;
  getWeight<TFunc extends BinanceFunctionName> (functionName :TFunc, ...params : Parameters<MyBinanceClient[TFunc]> & undefined[]) : WeightVal;
  getWeight<TFunc extends BinanceFunctionName> (functionName :TFunc, ...params : [QueryStruct]|undefined[]) : WeightVal {
      return this._getWeight(functionName, params[0] ?? {});
  }

  //getFunctionInfo<TFunc extends BinanceFunctionName>(functionName :TFunc) { return }

  protected override _getWeight(functionName :string, params :QueryStruct)
  {
    return getWeight(MyBinanceClient.weights, functionName, params) ?? (()=>{throw new Error("Wrong function name: "+functionName)})();
  }

  private static weights : {[func :string] :tWeights} = {
      systemStatus: {
        IP: 1,
      },
      allCoinsInformation: {
        IP: 10,
      },
      dailyAccountSnapshot: {
        IP: 2400,
      },
      disableFastWithdrawSwitch: {
        IP: 1,
      },
      enableFastWithdrawSwitch: {
        IP: 1,
      },
      withdraw: {
        UID: 600,
      },
      depositHistorySupportingNetwork: {
        IP: 1,
      },
      withdrawHistorySupportingNetwork: {
        UID: 18000,
      },
      depositAddressSupportingNetwork: {
        IP: 10,
      },
      accountStatus: {
        IP: 1,
      },
      accountAPITradingStatus: {
        IP: 1,
      },
      dustLog: {
        IP: 1,
      },
      getAssetsThatCanBeConvertedIntoBNB: {
        IP: 1,
      },
      dustTransfer_UserData: {
        UID: 10,
      },
      assetDividendRecord: {
        IP: 10,
      },
      assetDetail: {
        IP: 1,
      },
      tradeFee: {
        IP: 1,
      },
      userUniversalTransfer: {
        UID: 900,
      },
      queryUserUniversalTransferHistory: {
        IP: 1,
      },
      fundingWallet: {
        IP: 1,
      },
      userAsset: {
        IP: 5,
      },
      buSDConvert: {
        UID: 5,
      },
      buSDConvertHistory: {
        UID: 5,
      },
      getCloudMiningPaymentAndRefundHistory: {
        UID: 600,
      },
      getAPIKeyPermission: {
        IP: 1,
      },
      queryAutoConvertingStableCoins: {
        UID: 600,
      },
      switchOnOffBUSDAndStableCoinsConversion: {
        UID: 600,
      },
      oneClickArrivalDepositApplyForExpiredAddressDeposit: {
        IP: 1,
      },
      fetchDepositAddressListWithNetwork: {
        IP: 10,
      },
      queryUserWalletBalance: {
        IP: 60,
      },
      queryUserDelegationHistoryForMasterAccount: {
        IP: 60,
      },
      getSymbolsDelistScheduleForSpot: {
        IP: 100,
      },
      fetchWithdrawAddressList: {
        IP: 10,
      },
      accountInfo: {
        IP: 1,
      },
      createAVirtualSubAccount: {
        IP: 1,
      },
      querySubAccountList: {
        IP: 1,
      },
      querySubAccountSpotAssetTransferHistory: {
        IP: 1,
      },
      querySubAccountFuturesAssetTransferHistory: {
        IP: 1,
      },
      subAccountFuturesAssetTransfer: {
        IP: 1,
      },
      querySubAccountAssets: {
        UID: 60,
      },
      querySubAccountSpotAssetsSummary: {
        IP: 1,
      },
      getSubAccountDepositAddress: {
        IP: 1,
      },
      getSubAccountDepositHistory: {
        IP: 1,
      },
      getSubAccountSStatusOnMarginFutures: {
        IP: 10,
      },
      enableMarginForSubAccount: {
        IP: 1,
      },
      getDetailOnSubAccountSMarginAccount: {
        IP: 10,
      },
      getSummaryOfSubAccountSMarginAccount: {
        IP: 10,
      },
      enableFuturesForSubAccount: {
        IP: 1,
      },
      getDetailOnSubAccountSFuturesAccount: {
        IP: 10,
      },
      getSummaryOfSubAccountSFuturesAccount: {
        IP: 1,
      },
      getFuturesPositionRiskOfSubAccount: {
        IP: 10,
      },
      futuresTransferForSubAccount: {
        IP: 1,
      },
      marginTransferForSubAccount: {
        IP: 1,
      },
      transferToSubAccountOfSameMaster: {
        IP: 1,
      },
      transferToMaster: {
        IP: 1,
      },
      subAccountTransferHistory: {
        IP: 1,
      },
      universalTransfer: {
        IP: 1,
      },
      queryUniversalTransferHistory: {
        IP: 1,
      },
      getDetailOnSubAccountSFuturesAccountV2: {
        IP: 1,
      },
      getSummaryOfSubAccountSFuturesAccountV2: {
        IP: 10,
      },
      getFuturesPositionRiskOfSubAccountV2: {
        IP: 1,
      },
      getIPRestrictionForASubAccountAPIKey: {
        UID: 3000,
      },
      deleteIPListForASubAccountAPIKey: {
        UID: 3000,
      },
      addIPRestrictionForSubAccountAPIKey: {
        UID: 3000,
      },
      depositAssetsIntoTheManagedSubAccount: {
        IP: 1,
      },
      queryManagedSubAccountAssetDetails: {
        IP: 1,
      },
      withdrawlAssetsFromTheManagedSubAccount: {
        IP: 1,
      },
      queryManagedSubAccountSnapshot: {
        IP: 2400,
      },
      queryManagedSubAccountTransferLogForInvestorMasterAccount: {
        IP: 1,
      },
      queryManagedSubAccountTransferLogForTradingTeamMasterAccount: {
        UID: 60,
      },
      queryManagedSubAccountFuturesAssetDetailsForInvestorMasterAccount: {
        UID: 60,
      },
      queryManagedSubAccountMarginAssetDetailsForInvestorMasterAccount: {
        IP: 1,
      },
      querySubAccountAssetsForMasterAccount: {
        UID: 60,
      },
      queryManagedSubAccountListForInvestor: {
        UID: 60,
      },
      querySubAccountTransactionStatisticsForMasterAccount: {
        UID: 60,
      },
      getManagedSubAccountDepositAddressForInvestorMasterAccount: {
        UID: 1,
      },
      enableOptionsForSubAccountForMasterAccount: {
        IP: 1,
      },
      queryManagedSubAccountTransferLogForTradingTeamSubAccount: {
        UID: 60,
      },
      testConnectivity: {
        IP: 1,
      },
      checkServerTime: {
        IP: 1,
      },
      exchangeInformation: {
        IP: 20,
      },
      orderBook: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,250],[501,50],[101,25],[1,5]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      recentTradesList: {
        IP: 25,
      },
      oldTradeLookup: {
        IP: 25,
      },
      compressedAggregateTradesList: {
        IP: 2,
      },
      klineCandlestickData: {
        IP: 2,
      },
      uiKlines: {
        IP: 2,
      },
      currentAveragePrice: {
        IP: 2,
      },
      tickerPriceChangeStatistics24hr: {
        IP: (params :QueryStruct) =>
            Array.isArray(params["symbols"]) 
            ? [[101,80],[21,40],[1,2]].find((item, i)=> (params["symbols"] as []).length >= item[0] || i==0)! [1]
            : params["symbol"] ? 2 : 80,
      },
      tradingDayTicker: {
        IP: (params) => Math.min(200, (Array.isArray(params["symbols"]) ? params["symbols"].length * 4 : 0) + (params["symbol"] ? 4 : 0)),
      },
      symbolPriceTicker: {
        IP: (params :QueryStruct) =>
            Array.isArray(params["symbols"]) ? 4 : params["symbol"] ? 2 : 4,
      },
      symbolOrderBookTicker: {
        IP: (params :QueryStruct) =>
            Array.isArray(params["symbols"]) ? 4 : params["symbol"] ? 2 : 4,
      },
      rollingWindowPriceChangeStatistics: {
        IP: (params) => Math.min(200, (Array.isArray(params["symbols"]) ? params["symbols"].length * 4 : 0) + (params["symbol"] ? 4 : 0)),
      },
      testNewOrder: {
        IP: (params) => params["computeCommissionRates"] ? 20 : 1,
      },
      newOrder: {
        IP: 1,
        UID: 1,
      },
      cancelOrder: {
        IP: 1,
      },
      cancelAllOpenOrdersOnASymbol: {
        IP: 1,
      },
      queryOrder: {
        IP: 4,
      },
      cancelAnExistingOrderAndSendANewOrder: {
        IP: 1,
      },
      currentOpenOrders: {
        IP: (params) => params["symbol"] ? 6 : 80,
      },
      allOrders: {
        IP: 20,
      },
      newOCODeprecated: {
        IP: 1,
        UID: 2,
      },
      newOrderListOCO: {
        IP: 1,
      },
      newOrderListOTO: {
        IP: 1,
      },
      newOrderListOTOCO: {
        IP: 1,
      },
      cancelOrderLists: {
        IP: 1,
      },
      queryOrderLists: {
        IP: 4,
      },
      queryAllOrderLists: {
        IP: 20,
      },
      queryOpenOrderLists: {
        IP: 6,
      },
      newOrderUsingSOR: {
        IP: 1,
      },
      testNewOrderUsingSOR: {
        IP: (params) => params["computeCommissionRates"] ? 20 : 1,
      },
      accountInformation: {
        IP: 20,
      },
      accountTradeList: {
        IP: 20,
      },
      queryUnfilledOrderCount: {
        IP: 40,
      },
      queryPreventedMatches: {
        IP: (params) => params["orderId"] != null ? 20 : 2,
      },
      queryAllocations: {
        IP: 20,
      },
      queryCommissionRates: {
        IP: 20,
      },
      marginAccountBorrowRepay: {
        UID: 1500,
      },
      queryBorrowRepayRecordsInMarginAccount: {
        IP: 10,
      },
      getAllMarginAssets: {
        IP: 1,
      },
      getAllCrossMarginPairs: {
        IP: 1,
      },
      queryMarginPriceIndex: {
        IP: 10,
      },
      marginAccountNewOrder: {
        UID: 6,
      },
      marginAccountCancelOrder: {
        IP: 10,
      },
      marginAccountCancelAllOpenOrdersOnASymbol: {
        IP: 1,
      },
      adjustCrossMarginMaxLeverage: {
        UID: 3000,
      },
      getCrossMarginTransferHistory: {
        IP: 1,
      },
      getInterestHistory: {
        IP: 1,
      },
      getForceLiquidationRecord: {
        IP: 1,
      },
      queryCrossMarginAccountDetails: {
        IP: 10,
      },
      queryMarginAccountSOrder: {
        IP: 10,
      },
      queryMarginAccountSOpenOrders: {
        IP: 10,
      },
      queryMarginAccountSAllOrders: {
        IP: 200,
      },
      marginAccountNewOCO: {
        UID: 6,
      },
      marginAccountCancelOCO: {
        UID: 1,
      },
      queryMarginAccountSOCO: {
        IP: 10,
      },
      queryMarginAccountSAllOCO: {
        IP: 200,
      },
      queryMarginAccountSOpenOCO: {
        IP: 10,
      },
      queryMarginAccountSTradeList: {
        IP: 10,
      },
      queryMaxBorrow: {
        IP: 50,
      },
      queryMaxTransferOutAmount: {
        IP: 50,
      },
      getSummaryOfMarginAccount: {
        IP: 10,
      },
      queryIsolatedMarginAccountInfo: {
        IP: 10,
      },
      disableIsolatedMarginAccount: {
        UID: 300,
      },
      enableIsolatedMarginAccount: {
        UID: 300,
      },
      queryEnabledIsolatedMarginAccountLimit: {
        IP: 1,
      },
      getAllIsolatedMarginSymbol: {
        IP: 10,
      },
      toggleBNBBurnOnSpotTradeAndMarginInterest: {
        IP: 1,
      },
      getBNBBurnStatus: {
        IP: 1,
      },
      queryMarginInterestRateHistory: {
        IP: 1,
      },
      queryCrossMarginFeeData: {
        IP: (params) => params["coin"] ? 1 : 5,
      },
      queryIsolatedMarginFeeData: {
        IP: (params) => params["symbol"] ? 1 : 10,
      },
      queryIsolatedMarginTierData: {
        IP: 1,
      },
      queryCurrentMarginOrderCountUsage: {
        IP: 20,
      },
      crossMarginCollateralRatio: {
        IP: 100,
      },
      getSmallLiabilityExchangeCoinList: {
        IP: 100,
      },
      smallLiabilityExchange: {
        UID: 3000,
      },
      getSmallLiabilityExchangeHistory: {
        UID: 100,
      },
      getAFutureHourlyInterestRate: {
        IP: 100,
      },
      getCrossOrIsolatedMarginCapitalFlow: {
        IP: 100,
      },
      getTokensOrSymbolsDelistScheduleForCrossMarginAndIsolatedMargin: {
        IP: 100,
      },
      queryMarginAvailableInventory: {
        UID: 50,
      },
      marginManualLiquidation: {
        UID: 3000,
      },
      queryLiabilityCoinLeverageBracketInCrossMarginProMode: {
        IP: 1,
      },
      createAListenKey_Spot: {
        IP: 2,
      },
      pingKeepAliveAListenKey_Spot: {
        IP: 2,
      },
      closeAListenKey_Spot: {
        IP: 2,
      },
      createAListenKey_Margin: {
        IP: 1,
      },
      pingKeepAliveAListenKey_Margin: {
        IP: 1,
      },
      closeAListenKey_Margin: {
        IP: 1,
      },
      generateAListenKey_MarginIso: {
        IP: 1,
      },
      pingKeepAliveAListenKey_MarginIso: {
        IP: 1,
      },
      closeAListenKey_MarginIso: {
        IP: 1,
      },
      createAMarginListenKey: {
        UID: 1,
      },
      keepAliveAMarginListenKey: {
        UID: 1,
      },
      closeAMarginListenKey: {
        UID: 3000,
      },
      getSimpleEarnFlexibleProductList: {
        IP: 150,
      },
      getSimpleEarnLockedProductList: {
        IP: 150,
      },
      subscribeFlexibleProduct: {
        IP: 1,
      },
      subscribeLockedProduct: {
        IP: 1,
      },
      redeemFlexibleProduct: {
        IP: 1,
      },
      redeemLockedProduct: {
        IP: 1,
      },
      getFlexibleProductPosition: {
        IP: 150,
      },
      getLockedProductPosition: {
        IP: 150,
      },
      simpleAccount: {
        IP: 150,
      },
      getFlexibleSubscriptionRecord: {
        IP: 150,
      },
      getLockedSubscriptionRecord: {
        IP: 150,
      },
      getFlexibleRedemptionRecord: {
        IP: 150,
      },
      getLockedRedemptionRecord: {
        IP: 150,
      },
      getFlexibleRewardsHistory: {
        IP: 150,
      },
      getLockedRewardsHistory: {
        IP: 150,
      },
      setFlexibleAutoSubscribe: {
        IP: 150,
      },
      setLockedAutoSubscribe: {
        IP: 150,
      },
      getFlexiblePersonalLeftQuota: {
        IP: 150,
      },
      getLockedPersonalLeftQuota: {
        IP: 150,
      },
      getFlexibleSubscriptionPreview: {
        IP: 150,
      },
      getLockedSubscriptionPreview: {
        IP: 150,
      },
      getRateHistory: {
        IP: 150,
      },
      getCollateralRecord: {
        IP: 1,
      },
      getDualInvestmentProductList: {
        IP: 1,
      },
      subscribeDualInvestmentProducts: {
        IP: 1,
      },
      getDualInvestmentPositions: {
        IP: 1,
      },
      checkDualInvestmentAccounts: {
        IP: 1,
      },
      changeAutoCompoundStatus: {
        IP: 1,
      },
      getTargetAssetList: {
        IP: 1,
      },
      getTargetAssetROIData: {
        IP: 1,
      },
      queryAllSourceAssetAndTargetAsset: {
        IP: 1,
      },
      querySourceAssetList: {
        IP: 1,
      },
      investmentPlanCreation: {
        IP: 1,
      },
      investmentPlanAdjustment: {
        IP: 1,
      },
      changePlanStatus: {
        IP: 1,
      },
      getListOfPlans: {
        IP: 1,
      },
      queryHoldingDetailsOfThePlan: {
        IP: 1,
      },
      querySubscriptionTransactionHistory: {
        IP: 1,
      },
      queryIndexDetails: {
        IP: 1,
      },
      queryIndexLinkedPlanPositionDetails: {
        IP: 1,
      },
      oneTimeTransaction: {
        IP: 1,
      },
      queryOneTimeTransactionStatus: {
        IP: 1,
      },
      indexLinkedPlanRedemption_Trade: {
        IP: 1,
      },
      indexLinkedPlanRedemption_UserData: {
        IP: 1,
      },
      indexLinkedPlanRebalanceDetails: {
        IP: 1,
      },
      subscribeETHStaking: {
        IP: 150,
      },
      subscribeETHStakingV2: {
        IP: 150,
      },
      redeemETH: {
        IP: 150,
      },
      getETHStakingHistory: {
        IP: 150,
      },
      getETHRedemptionHistory: {
        IP: 150,
      },
      getBETHRewardsDistributionHistory: {
        IP: 150,
      },
      getCurrentETHStakingQuota: {
        IP: 150,
      },
      getWBETHRateHistory: {
        IP: 150,
      },
      etHStakingAccount: {
        IP: 150,
      },
      etHStakingAccountV2: {
        IP: 150,
      },
      wrapBETH: {
        IP: 150,
      },
      getWBETHWrapHistory: {
        IP: 150,
      },
      getWBETHUnwrapHistory: {
        IP: 150,
      },
      getWBETHRewardsHistory: {
        IP: 150,
      },
      acquiringAlgorithm: {
        IP: 1,
      },
      acquiringCoinName: {
        IP: 1,
      },
      requestForDetailMinerList: {
        IP: 5,
      },
      requestForMinerList: {
        IP: 5,
      },
      earningsList: {
        IP: 5,
      },
      extraBonusList: {
        IP: 5,
      },
      hashrateResaleList: {
        IP: 5,
      },
      hashrateResaleDetail: {
        IP: 5,
      },
      hashrateResaleRequest: {
        IP: 5,
      },
      cancelHashrateResaleConfiguration: {
        IP: 5,
      },
      statisticList: {
        IP: 5,
      },
      accountList: {
        IP: 5,
      },
      miningAccountEarning: {
        IP: 5,
      },
      newFutureAccountTransfer: {
        IP: 1,
      },
      getFutureAccountTransactionHistoryList: {
        IP: 10,
      },
      getFutureTickLevelOrderbookHistoricalDataDownloadLink: {
        IP: 200,
      },
      volumeParticipationVPNewOrder: {
        UID: 3000,
      },
      timeWeightedAveragePriceTwapNewOrder: {
        UID: 3000,
      },
      cancelAlgoOrderFutures: {
        IP: 1,
      },
      queryCurrentAlgoOpenOrdersFutures: {
        IP: 1,
      },
      queryHistoricalAlgoOrdersFutures: {
        IP: 1,
      },
      querySubOrdersFutures: {
        IP: 1,
      },
      timeWeightedAveragePriceNewOrder: {
        UID: 3000,
      },
      cancelAlgoOrder: {
        IP: 1,
      },
      queryCurrentAlgoOpenOrders: {
        IP: 1,
      },
      queryHistoricalAlgoOrders: {
        IP: 1,
      },
      querySubOrders: {
        IP: 1,
      },
      getPortfolioMarginProAccountInfo: {
        IP: 5,
      },
      portfolioMarginProCollateralRate: {
        IP: 50,
      },
      queryPortfolioMarginProBankruptcyLoanAmount: {
        UID: 500,
      },
      portfolioMarginProBankruptcyLoanRepay: {
        UID: 3000,
      },
      queryPortfolioMarginProNegativeBalanceInterestHistory: {
        IP: 50,
      },
      queryPortfolioMarginAssetIndexPrice: {
        IP: (params) => params["asset"] ? 1 : 50,
      },
      fundAutoCollection: {
        IP: 1500,
      },
      fundCollectionByAsset: {
        IP: 60,
      },
      bnBTransfer: {
        IP: 1500,
      },
      changeAutoRepayFuturesStatus: {
        IP: 1500,
      },
      getAutoRepayFuturesStatus: {
        IP: 30,
      },
      repayFuturesNegativeBalance: {
        IP: 1500,
      },
      getPortfolioMarginAssetLeverage: {
        IP: 50,
      },
      getFiatDepositWithdrawHistory: {
        UID: 90000,
      },
      getFiatPaymentsHistory: {
        IP: 1,
      },
      getC2CTradeHistory: {
        IP: 1,
      },
      getVIPLoanOngoingOrders: {
        IP: 400,
      },
      viPLoanRepay: {
        UID: 6000,
      },
      getVIPLoanRepaymentHistory: {
        IP: 400,
      },
      viPLoanRenew: {
        UID: 6000,
      },
      checkLockedValueOfVIPCollateralAccount: {
        IP: 6000,
      },
      viPLoanBorrow: {
        UID: 6000,
      },
      getLoanableAssetsDataVIP: {
        IP: 400,
      },
      getCollateralAssetData: {
        IP: 400,
      },
      queryApplicationStatus: {
        UID: 400,
      },
      getBorrowInterestRate: {
        UID: 400,
      },
      getCryptoLoansIncomeHistory: {
        UID: 6000,
      },
      borrowCryptoLoanBorrow: {
        UID: 36000,
      },
      borrowGetLoanBorrowHistory: {
        IP: 400,
      },
      borrowGetLoanOngoingOrders: {
        IP: 300,
      },
      repayCryptoLoanRepay: {
        UID: 6000,
      },
      repayGetLoanRepaymentHistory: {
        IP: 400,
      },
      adjustLTVCryptoLoanAdjustLTV: {
        UID: 6000,
      },
      adjustLTVGetLoanLTVAdjustmentHistory: {
        IP: 400,
      },
      getLoanableAssetsData: {
        IP: 400,
      },
      getCollateralAssetsData: {
        IP: 400,
      },
      checkCollateralRepayRate: {
        IP: 6000,
      },
      cryptoLoanCustomizeMarginCall: {
        UID: 6000,
      },
      borrowFlexibleLoanBorrow: {
        UID: 6000,
      },
      borrowGetFlexibleLoanOngoingOrders: {
        IP: 300,
      },
      borrowGetFlexibleLoanBorrowHistory: {
        IP: 400,
      },
      repayFlexibleLoanRepay: {
        UID: 6000,
      },
      repayGetFlexibleLoanRepaymentHistory: {
        IP: 400,
      },
      adjustLTVFlexibleLoanAdjustLTV: {
        UID: 6000,
      },
      adjustLTVGetFlexibleLoanLTVAdjustmentHistory: {
        IP: 400,
      },
      getFlexibleLoanAssetsData: {
        IP: 400,
      },
      getFlexibleLoanCollateralAssetsData: {
        IP: 400,
      },
      getFuturesLeadTraderStatus: {
        UID: 20,
      },
      getFuturesLeadTradingSymbolWhitelist: {
        UID: 20,
      },
      getPayTradeHistory: {
        UID: 3000,
      },
      listAllConvertPairs: {
        IP: 20,
      },
      queryOrderQuantityPrecisionPerAsset: {
        IP: 100,
      },
      sendQuoteRequest: {
        UID: 200,
      },
      acceptQuote: {
        UID: 500,
      },
      orderStatus: {
        UID: 100,
      },
      placeLimitOrder: {
        UID: 500,
      },
      cancelLimitOrder: {
        UID: 200,
      },
      queryLimitOpenOrders: {
        UID: 3000,
      },
      getConvertTradeHistory: {
        UID: 3000,
      },
      getSpotRebateHistoryRecords: {
        UID: 12000,
      },
      getNFTTransactionHistory: {
        UID: 3000,
      },
      getNFTDepositHistory: {
        UID: 3000,
      },
      getNFTWithdrawHistory: {
        UID: 3000,
      },
      getNFTAsset: {
        UID: 3000,
      },
      createASingleTokenGiftCard: {
        IP: 1,
      },
      createADualTokenGiftCardFixedValueDiscountFeature: {
        IP: 1,
      },
      redeemABinanceGiftCard: {
        IP: 1,
      },
      verifyBinanceGiftCardByGiftCardNumber: {
        IP: 1,
      },
      fetchRSAPublicKey: {
        IP: 1,
      },
      fetchTokenLimit: {
        IP: 1,
      },
      fapi_testConnectivity: {
        IP: 1,
      },
      fapi_checkServerTime: {
        IP: 1,
      },
      fapi_exchangeInformation: {
        IP: 1,
      },
      fapi_orderBook: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1000,20],[500,10],[100,5],[5,2]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      fapi_recentTradesList: {
        IP: 5,
      },
      fapi_oldTradesLookup: {
        IP: 20,
      },
      fapi_compressedAggregateTradesList: {
        IP: 20,
      },
      fapi_klineCandlestickData: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,10],[500,5],[100,2],[1,1]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      fapi_continuousContractKlineCandlestickData: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,10],[500,5],[100,2],[1,1]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      fapi_indexPriceKlineCandlestickData: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,10],[500,5],[100,2],[1,1]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      fapi_markPriceKlineCandlestickData: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,10],[500,5],[100,2],[1,1]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      fapi_premiumIndexKlineData: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,10],[500,5],[100,2],[1,1]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      fapi_markPrice: {
        IP: (params) => params["symbol"] ? 1 : 10,
      },
      fapi_tickerPriceChangeStatistics24hr: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      fapi_symbolPriceTicker: {
        IP: (params) => params["symbol"] ? 1 : 2,
      },
      fapi_symbolPriceTickerV2: {
        IP: (params) => params["symbol"] ? 1 : 2,
      },
      fapi_symbolOrderBookTicker: {
        IP: (params) => params["symbol"] ? 2 : 5,
      },
      fapi_openInterest: {
        IP: 1,
      },
      fapi_compositeIndexSymbolInformation: {
        IP: (params) => params["symbol"] ? 1 : 10,
      },
      fapi_multiAssetsModeAssetIndex: {
        IP: (params) => params["symbol"] ? 1 : 10,
      },
      fapi_queryIndexPriceConstituents: {
        IP: 2,
      },
      fapi_changePositionMode: {
        IP: 1,
      },
      fapi_getCurrentPositionMode: {
        IP: 30,
      },
      fapi_changeMultiAssetsMode: {
        IP: 1,
      },
      fapi_getCurrentMultiAssetsMode: {
        IP: 30,
      },
      fapi_toggleBNBBurnOnFuturesTrade: {
        IP: 1,
      },
      fapi_getBNBBurnStatus: {
        IP: 30,
      },
      fapi_modifyOrder: {
        IP: 1,
      },
      fapi_placeMultipleOrders: {
        IP: 5,
      },
      fapi_modifyMultipleOrders: {
        IP: 5,
      },
      fapi_getOrderModifyHistory: {
        IP: 1,
      },
      fapi_queryOrder: {
        IP: 1,
      },
      fapi_cancelOrder: {
        IP: 1,
      },
      fapi_cancelAllOpenOrders: {
        IP: 1,
      },
      fapi_cancelMultipleOrders: {
        IP: 1,
      },
      fapi_autoCancelAllOpenOrders: {
        IP: 10,
      },
      fapi_queryCurrentOpenOrder: {
        IP: 1,
      },
      fapi_currentAllOpenOrders: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      fapi_allOrders: {
        IP: 5,
      },
      fapi_futuresAccountBalanceV3: {
        IP: 5,
      },
      fapi_futuresAccountBalanceV2: {
        IP: 5,
      },
      fapi_accountInformationV3: {
        IP: 5,
      },
      fapi_accountInformationV2: {
        IP: 5,
      },
      fapi_changeInitialLeverage: {
        IP: 1,
      },
      fapi_changeMarginType: {
        IP: 1,
      },
      fapi_modifyIsolatedPositionMargin: {
        IP: 1,
      },
      fapi_getPositionMarginChangeHistory: {
        IP: 1,
      },
      fapi_positionInformationV3: {
        IP: 5,
      },
      fapi_positionInformationV2: {
        IP: 5,
      },
      fapi_accountTradeList: {
        IP: 5,
      },
      fapi_getIncomeHistory: {
        IP: 30,
      },
      fapi_notionalAndLeverageBrackets: {
        IP: 1,
      },
      fapi_positionADLQuantileEstimation: {
        IP: 5,
      },
      fapi_userSForceOrders: {
        IP: (params) => params["symbol"] ? 20 : 50,
      },
      fapi_futuresTradingQuantitativeRulesIndicators: {
        IP: (params) => params["symbol"] ? 1 : 10,
      },
      fapi_futuresAccountConfiguration: {
        IP: 5,
      },
      fapi_symbolConfiguration: {
        IP: 5,
      },
      fapi_userCommissionRate: {
        IP: 20,
      },
      fapi_queryUserRateLimit: {
        IP: 1,
      },
      fapi_getDownloadIdForFuturesTransactionHistory: {
        IP: 1500,
      },
      fapi_getFuturesTransactionHistoryDownloadLinkById: {
        IP: 10,
      },
      fapi_getDownloadIdForFuturesOrderHistory: {
        IP: 1500,
      },
      fapi_getFuturesOrderHistoryDownloadLinkById: {
        IP: 10,
      },
      fapi_getDownloadIdForFuturesTradeHistory: {
        IP: 1500,
      },
      fapi_getFuturesTradeDownloadLinkById: {
        IP: 10,
      },
      fapi_startUserDataStream: {
        IP: 1,
      },
      fapi_keepaliveUserDataStream: {
        IP: 1,
      },
      fapi_closeUserDataStream: {
        IP: 1,
      },
      fapi_portfolioMarginProAccountInformation: {
        IP: 5,
      },
      dapi_testConnectivity: {
        IP: 1,
      },
      dapi_checkServerTime: {
        IP: 1,
      },
      dapi_exchangeInformation: {
        IP: 1,
      },
      dapi_orderBook: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1000,20],[500,10],[100,5],[5,2]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      dapi_recentTradesList: {
        IP: 5,
      },
      dapi_oldTradesLookup: {
        IP: 20,
      },
      dapi_compressedAggregateTradesList: {
        IP: 20,
      },
      dapi_indexPriceAndMarkPrice: {
        IP: 10,
      },
      dapi_getFundingRateHistoryOfPerpetualFutures: {
        IP: 1,
      },
      dapi_klineCandlestickData: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,10],[500,5],[100,2],[1,1]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      dapi_continuousContractKlineCandlestickData: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,10],[500,5],[100,2],[1,1]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      dapi_indexPriceKlineCandlestickData: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,10],[500,5],[100,2],[1,1]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      dapi_markPriceKlineCandlestickData: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,10],[500,5],[100,2],[1,1]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      dapi_premiumIndexKlineData: {
        IP: (params :QueryStruct) =>
            typeof(params["limit"])=="number"
                ? [[1001,10],[500,5],[100,2],[1,1]].find((item,i)=> (params["limit"] as number)>=item[0] || i==0)! [1]
                : (()=>{throw new Error("Parameter \'limit\' is not a number")})(),
      },
      dapi_tickerPriceChangeStatistics24hr: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      dapi_symbolPriceTicker: {
        IP: (params) => params["symbol"] ? 1 : 2,
      },
      dapi_symbolOrderBookTicker: {
        IP: (params) => params["symbol"] ? 2 : 5,
      },
      dapi_queryIndexPriceConstituents: {
        IP: 2,
      },
      dapi_openInterest: {
        IP: 1,
      },
      dapi_openInterestStatistics: {
        IP: 1,
      },
      dapi_topTraderLongShortAccountRatio: {
        IP: 1,
      },
      dapi_topTraderLongShortPositionRatio: {
        IP: 1,
      },
      dapi_longShortRatio: {
        IP: 1,
      },
      dapi_takerBuySellVolume: {
        IP: 1,
      },
      dapi_changePositionMode: {
        IP: 1,
      },
      dapi_getCurrentPositionMode: {
        IP: 30,
      },
      dapi_modifyOrder: {
        IP: 1,
      },
      dapi_placeMultipleOrders: {
        IP: 5,
      },
      dapi_modifyMultipleOrders: {
        IP: 5,
      },
      dapi_getOrderModifyHistory: {
        IP: 1,
      },
      dapi_queryOrder: {
        IP: 1,
      },
      dapi_cancelOrder: {
        IP: 1,
      },
      dapi_cancelAllOpenOrders: {
        IP: 1,
      },
      dapi_cancelMultipleOrders: {
        IP: 1,
      },
      dapi_autoCancelAllOpenOrders: {
        IP: 10,
      },
      dapi_queryCurrentOpenOrder: {
        IP: 1,
      },
      dapi_currentAllOpenOrders: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      dapi_allOrders: {
        IP: (params) => params["pair"] || !params["symbol"] ? 40 : 20,
      },
      dapi_futuresAccountBalance: {
        IP: 1,
      },
      dapi_accountInformation: {
        IP: 5,
      },
      dapi_changeInitialLeverage: {
        IP: 1,
      },
      dapi_changeMarginType: {
        IP: 1,
      },
      dapi_modifyIsolatedPositionMargin: {
        IP: 1,
      },
      dapi_getPositionMarginChangeHistory: {
        IP: 1,
      },
      dapi_positionInformation: {
        IP: 1,
      },
      dapi_accountTradeList: {
        IP: (params) => params["pair"] || !params["symbol"] ? 40 : 20,
      },
      dapi_getIncomeHistory: {
        IP: 20,
      },
      dapi_notionalBracketForPair: {
        IP: 1,
      },
      dapi_notionalBracketForSymbol: {
        IP: 1,
      },
      dapi_userSForceOrders: {
        IP: (params) => params["symbol"] ? 20 : 50,
      },
      dapi_positionADLQuantileEstimation: {
        IP: 5,
      },
      dapi_userCommissionRate: {
        IP: 20,
      },
      dapi_getDownloadIdForFuturesTransactionHistory: {
        IP: 5,
      },
      dapi_getFuturesTransactionHistoryDownloadLinkById: {
        IP: 5,
      },
      dapi_startUserDataStream: {
        IP: 1,
      },
      dapi_keepaliveUserDataStream: {
        IP: 1,
      },
      dapi_closeUserDataStream: {
        IP: 1,
      },
      dapi_queryClassicPortfolioMarginNotionalLimit: {
        IP: 5,
      },
      dapi_classicPortfolioMarginAccountInformation: {
        IP: 5,
      },
      eapi_testConnectivity: {
        IP: 1,
      },
      eapi_checkServerTime: {
        IP: 1,
      },
      eapi_exchangeInformation: {
        IP: 1,
      },
      eapi_orderBook: {
        IP: 1,
      },
      eapi_recentTradesList: {
        IP: 5,
      },
      eapi_oldTradesLookup: {
        IP: 20,
      },
      eapi_klineCandlestickData: {
        IP: 1,
      },
      eapi_optionMarkPrice: {
        IP: 5,
      },
      eapi_tickerPriceChangeStatistics24hr: {
        IP: 5,
      },
      eapi_symbolPriceTicker: {
        IP: 1,
      },
      eapi_historicalExerciseRecords: {
        IP: 3,
      },
      eapi_optionAccountInformation: {
        IP: 3,
      },
      eapi_newOrder: {
        IP: 5,
      },
      eapi_placeMultipleOrders: {
        IP: 5,
      },
      eapi_querySingleOrder: {
        IP: 1,
      },
      eapi_cancelOptionOrder: {
        IP: 1,
      },
      eapi_cancelMultipleOptionOrders: {
        IP: 1,
      },
      eapi_cancelAllOptionOrdersOnSpecificSymbol: {
        IP: 1,
      },
      eapi_cancelAllOptionOrdersByUnderlying: {
        IP: 1,
      },
      eapi_queryCurrentOpenOptionOrders: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      eapi_queryOptionOrderHistory: {
        IP: 3,
      },
      eapi_optionPositionInformation: {
        IP: 5,
      },
      eapi_accountTradeList: {
        IP: 5,
      },
      eapi_userExerciseRecord: {
        IP: 5,
      },
      eapi_accountFundingFlow: {
        IP: 1,
      },
      eapi_getDownloadIdForOptionTransactionHistory: {
        IP: 5,
      },
      eapi_getOptionTransactionHistoryDownloadLinkById: {
        IP: 5,
      },
      eapi_startUserDataStream: {
        IP: 1,
      },
      eapi_keepaliveUserDataStream: {
        IP: 1,
      },
      eapi_closeUserDataStream: {
        IP: 1,
      },
      eapi_optionMarginAccountInformation: {
        IP: 3,
      },
      eapi_setMarketMakerProtectionConfig: {
        IP: 1,
      },
      eapi_getMarketMakerProtectionConfig: {
        IP: 1,
      },
      eapi_resetMarketMakerProtectionConfig: {
        IP: 1,
      },
      eapi_setAutoCancelAllOpenOrdersKillSwitchConfig: {
        IP: 1,
      },
      eapi_getAutoCancelAllOpenOrdersKillSwitchConfig: {
        IP: 1,
      },
      eapi_autoCancelAllOpenOrdersKillSwitchHeartbeat: {
        IP: 10,
      },
      papi_testConnectivity: {
        IP: 1,
      },
      papi_newUMOrder: {
        UID: 1,
      },
      papi_newCMOrder: {
        UID: 1,
      },
      papi_newMarginOrder: {
        UID: 1,
      },
      papi_marginAccountBorrow: {
        IP: 100,
      },
      papi_marginAccountRepay: {
        IP: 100,
      },
      papi_marginAccountNewOCO: {
        UID: 1,
      },
      papi_newUMConditionalOrder: {
        UID: 1,
      },
      papi_newCMConditionalOrder: {
        UID: 1,
      },
      papi_modifyUMOrder: {
        UID: 1,
      },
      papi_modifyCMOrder: {
        UID: 1,
      },
      papi_cancelUMOrder: {
        IP: 1,
      },
      papi_cancelAllUMOpenOrders: {
        IP: 1,
      },
      papi_cancelCMOrder: {
        IP: 1,
      },
      papi_cancelAllCMOpenOrders: {
        IP: 1,
      },
      papi_cancelMarginAccountOrder: {
        IP: 2,
      },
      papi_cancelMarginAccountAllOpenOrdersOnASymbol: {
        IP: 5,
      },
      papi_cancelMarginAccountOCOOrders: {
        IP: 2,
      },
      papi_cancelUMConditionalOrder: {
        IP: 1,
      },
      papi_cancelAllUMOpenConditionalOrders: {
        IP: 1,
      },
      papi_cancelCMConditionalOrder: {
        IP: 1,
      },
      papi_cancelAllCMOpenConditionalOrders: {
        IP: 1,
      },
      papi_queryUMOrder: {
        IP: 1,
      },
      papi_queryCurrentUMOpenOrder: {
        IP: 1,
      },
      papi_queryAllCurrentUMOpenOrders: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      papi_queryAllUMOrders: {
        IP: 5,
      },
      papi_queryCMOrder: {
        IP: 1,
      },
      papi_queryCurrentCMOpenOrder: {
        IP: 1,
      },
      papi_queryAllCurrentCMOpenOrders: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      papi_queryAllCMOrders: {
        IP: (params) => params["pair"] || !params["symbol"] ? 40 : 20,
      },
      papi_queryCurrentUMOpenConditionalOrder: {
        IP: 1,
      },
      papi_queryAllCurrentUMOpenConditionalOrders: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      papi_queryUMConditionalOrderHistory: {
        IP: 1,
      },
      papi_queryAllUMConditionalOrders: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      papi_queryCurrentCMOpenConditionalOrder: {
        IP: 1,
      },
      papi_queryAllCurrentCMOpenConditionalOrders: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      papi_queryCMConditionalOrderHistory: {
        IP: 1,
      },
      papi_queryAllCMConditionalOrders: {
        IP: (params) => params["symbol"] ? 1 : 40,
      },
      papi_queryMarginAccountOrder: {
        IP: 5,
      },
      papi_queryCurrentMarginOpenOrder: {
        IP: 5,
      },
      papi_queryAllMarginAccountOrders: {
        IP: 100,
      },
      papi_queryMarginAccountSOCO: {
        IP: 5,
      },
      papi_queryMarginAccountSAllOCO: {
        IP: 100,
      },
      papi_queryMarginAccountSOpenOCO: {
        IP: 5,
      },
      papi_marginAccountTradeList: {
        IP: 5,
      },
      papi_queryUMModifyOrderHistory: {
        UID: 1,
      },
      papi_queryCMModifyOrderHistory: {
        UID: 1,
      },
      papi_accountBalance: {
        IP: 20,
      },
      papi_accountInformation: {
        IP: 20,
      },
      papi_marginMaxBorrow: {
        IP: 5,
      },
      papi_queryMarginMaxWithdraw: {
        IP: 5,
      },
      papi_queryUMPositionInformation: {
        IP: 5,
      },
      papi_queryCMPositionInformation: {
        IP: 1,
      },
      papi_changeUMInitialLeverage: {
        IP: 1,
      },
      papi_changeCMInitialLeverage: {
        IP: 1,
      },
      papi_changeUMPositionMode: {
        IP: 1,
      },
      papi_changeCMPositionMode: {
        IP: 1,
      },
      papi_getUMCurrentPositionMode: {
        IP: 30,
      },
      papi_getCMCurrentPositionMode: {
        IP: 30,
      },
      papi_umAccountTradeList: {
        IP: 5,
      },
      papi_cmAccountTradeList: {
        IP: (params) => params["pair"] || !params["symbol"] ? 40 : 20,
      },
      papi_umNotionalAndLeverageBrackets: {
        IP: 1,
      },
      papi_cmNotionalAndLeverageBrackets: {
        IP: 1,
      },
      papi_queryUserSMarginForceOrders: {
        IP: 1,
      },
      papi_queryUserSUMForceOrders: {
        IP: (params) => params["symbol"] ? 20 : 50,
      },
      papi_queryUserSCMForceOrders: {
        IP: (params) => params["symbol"] ? 20 : 50,
      },
      papi_portfolioMarginUMTradingQuantitativeRulesIndicators: {
        IP: (params) => params["symbol"] ? 1 : 10,
      },
      papi_getUserCommissionRateForUM: {
        IP: 20,
      },
      papi_getUserCommissionRateForCM: {
        IP: 20,
      },
      papi_queryMarginLoanRecord: {
        IP: 10,
      },
      papi_queryMarginRepayRecord: {
        IP: 10,
      },
      papi_getMarginBorrowLoanInterestHistory: {
        IP: 1,
      },
      papi_queryPortfolioMarginNegativeBalanceInterestHistory: {
        IP: 50,
      },
      papi_fundAutoCollection: {
        IP: 750,
      },
      papi_fundCollectionByAsset: {
        IP: 30,
      },
      papi_bnBTransfer: {
        IP: 750,
      },
      papi_getUMIncomeHistory: {
        IP: 30,
      },
      papi_getCMIncomeHistory: {
        IP: 30,
      },
      papi_getUMAccountDetail: {
        IP: 5,
      },
      papi_getCMAccountDetail: {
        IP: 5,
      },
      papi_changeAutoRepayFuturesStatus: {
        IP: 750,
      },
      papi_getAutoRepayFuturesStatus: {
        IP: 30,
      },
      papi_repayFuturesNegativeBalance: {
        IP: 750,
      },
      papi_umPositionADLQuantileEstimation: {
        IP: 5,
      },
      papi_cmPositionADLQuantileEstimation: {
        IP: 5,
      },
      papi_startUserDataStream: {
        IP: 1,
      },
      papi_keepaliveUserDataStream: {
        IP: 1,
      },
      papi_closeUserDataStream: {
        IP: 1,
      },
  }
}
